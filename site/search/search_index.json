{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dear imgui \u00b6 (This library is available under a free and permissive license, but needs financial support to sustain its continued improvements. In addition to maintenance and stability there are many desirable features yet to be added. If your company is using dear imgui, please consider reaching out.) Businesses: support continued development via invoiced technical support, maintenance, sponsoring contracts: E-mail: contact @ dearimgui dot org Individuals: support continued maintenance and development with PayPal . Dear ImGui is a bloat-free graphical user interface library for C++ . It outputs optimized vertex buffers that you can render anytime in your 3D-pipeline enabled application. It is fast, portable, renderer agnostic and self-contained (no external dependencies). Dear ImGui is designed to enable fast iterations and to empower programmers to create content creation tools and visualization / debug tools (as opposed to UI for the average end-user). It favors simplicity and productivity toward this goal, and lacks certain features normally found in more high-level libraries. Dear ImGui is particularly suited to integration in games engine (for tooling), real-time 3D applications, fullscreen applications, embedded applications, or any applications on consoles platforms where operating system features are non-standard. Usage - How it works - Demo - Integration Upcoming changes - Gallery - Support, FAQ - How to help - Sponsors - Credits - License Wiki - Language & frameworks bindings - Software using Dear ImGui - User quotes Usage \u00b6 The core of Dear ImGui is self-contained within a few platform-agnostic files which you can easily compile in your application/engine. They are all the files in the root folder of the repository (imgui.cpp, imgui.h, imgui_demo.cpp, imgui_draw.cpp etc.). No specific build process is required . You can add the .cpp files to your existing project. You will need a backend to integrate Dear ImGui in your app. The backend passes mouse/keyboard/gamepad inputs and variety of settings to Dear ImGui, and is in charge of rendering the resulting vertices. Backends for a variety of graphics api and rendering platforms are provided in the examples/ folder, along with example applications. See the Integration section of this document for details. You may also create your own backend. Anywhere where you can render textured triangles, you can render Dear ImGui. After Dear ImGui is setup in your application, you can use it from _anywhere_ in your program loop: Code: ImGui :: Text ( \"Hello, world %d\" , 123 ); if ( ImGui :: Button ( \"Save\" )) MySaveFunction (); ImGui :: InputText ( \"string\" , buf , IM_ARRAYSIZE ( buf )); ImGui :: SliderFloat ( \"float\" , & f , 0.0 f , 1.0 f ); Result: (settings: Dark style (left), Light style (right) / Font: Roboto-Medium, 16px / Rounding: 5) Code: // Create a window called \"My First Tool\", with a menu bar. ImGui :: Begin ( \"My First Tool\" , & my_tool_active , ImGuiWindowFlags_MenuBar ); if ( ImGui :: BeginMenuBar ()) { if ( ImGui :: BeginMenu ( \"File\" )) { if ( ImGui :: MenuItem ( \"Open..\" , \"Ctrl+O\" )) { /* Do stuff */ } if ( ImGui :: MenuItem ( \"Save\" , \"Ctrl+S\" )) { /* Do stuff */ } if ( ImGui :: MenuItem ( \"Close\" , \"Ctrl+W\" )) { my_tool_active = false ; } ImGui :: EndMenu (); } ImGui :: EndMenuBar (); } // Edit a color (stored as ~4 floats) ImGui :: ColorEdit4 ( \"Color\" , my_color ); // Plot some values const float my_values [] = { 0.2f , 0.1f , 1.0f , 0.5f , 0.9f , 2.2f }; ImGui :: PlotLines ( \"Frame Times\" , my_values , IM_ARRAYSIZE ( my_values )); // Display contents in a scrolling region ImGui :: TextColored ( ImVec4 ( 1 , 1 , 0 , 1 ), \"Important Stuff\" ); ImGui :: BeginChild ( \"Scrolling\" ); for ( int n = 0 ; n < 50 ; n ++ ) ImGui :: Text ( \"%04d: Some text\" , n ); ImGui :: EndChild (); ImGui :: End (); Result: Dear ImGui allows you to create elaborate tools as well as very short-lived ones. On the extreme side of short-livedness: using the Edit&Continue (hot code reload) feature of modern compilers you can add a few widgets to tweaks variables while your application is running, and remove the code a minute later! Dear ImGui is not just for tweaking values. You can use it to trace a running algorithm by just emitting text commands. You can use it along with your own reflection data to browse your dataset live. You can use it to expose the internals of a subsystem in your engine, to create a logger, an inspection tool, a profiler, a debugger, an entire game making editor/framework, etc. How it works \u00b6 Check out the Wiki's About the IMGUI paradigm section if you want to understand the core principles behind the IMGUI paradigm. An IMGUI tries to minimize superfluous state duplication, state synchronization and state retention from the user's point of view. It is less error prone (less code and less bugs) than traditional retained-mode interfaces, and lends itself to create dynamic user interfaces. Dear ImGui outputs vertex buffers and command lists that you can easily render in your application. The number of draw calls and state changes required to render them is fairly small. Because Dear ImGui doesn't know or touch graphics state directly, you can call its functions anywhere in your code (e.g. in the middle of a running algorithm, or in the middle of your own rendering process). Refer to the sample applications in the examples/ folder for instructions on how to integrate dear imgui with your existing codebase. A common misunderstanding is to mistake immediate mode gui for immediate mode rendering, which usually implies hammering your driver/GPU with a bunch of inefficient draw calls and state changes as the gui functions are called. This is NOT what Dear ImGui does. Dear ImGui outputs vertex buffers and a small list of draw calls batches. It never touches your GPU directly. The draw call batches are decently optimal and you can render them later, in your app or even remotely. Demo \u00b6 Calling the ImGui::ShowDemoWindow() function will create a demo window showcasing variety of features and examples. The code is always available for reference in imgui_demo.cpp . You should be able to build the examples from sources (tested on Windows/Mac/Linux). If you don't, let me know! If you want to have a quick look at some Dear ImGui features, you can download Windows binaries of the demo app here: - imgui-demo-binaries-20190715.zip (Windows binaries, 1.76, built 2020/04/12, master branch) or older demo binaries . The demo applications are not DPI aware so expect some blurriness on a 4K screen. For DPI awareness in your application, you can load/reload your font at different scale, and scale your style with style.ScaleAllSizes() . Integration \u00b6 On most platforms and when using C++, you should be able to use a combination of the imgui_impl_xxxx files without modification (e.g. imgui_impl_win32.cpp + imgui_impl_dx11.cpp ). If your engine supports multiple platforms, consider using more of the imgui_impl_xxxx files instead of rewriting them: this will be less work for you and you can get Dear ImGui running immediately. You can later decide to rewrite a custom binding using your custom engine functions if you wish so. Integrating Dear ImGui within your custom engine is a matter of 1) wiring mouse/keyboard/gamepad inputs 2) uploading one texture to your GPU/render engine 3) providing a render function that can bind textures and render textured triangles. The examples/ folder is populated with applications doing just that. If you are an experienced programmer at ease with those concepts, it should take you less than two hours to integrate Dear ImGui in your custom engine. Make sure to spend time reading the FAQ , comments, and some of the examples/ application! Officially maintained bindings (in repository): - Renderers: DirectX9, DirectX10, DirectX11, DirectX12, OpenGL (legacy), OpenGL3/ES/ES2 (modern), Vulkan, Metal. - Platforms: GLFW, SDL2, Win32, Glut, OSX. - Frameworks: Emscripten, Allegro5, Marmalade. Third-party bindings (see Bindings page): - Languages: C, C#/.Net, ChaiScript, D, Go, Haskell, Haxe/hxcpp, Java, JavaScript, Julia, Kotlin, Lua, Odin, Pascal, PureBasic, Python, Ruby, Rust, Swift... - Frameworks: AGS/Adventure Game Studio, Amethyst, bsf, Cinder, Cocos2d-x, Diligent Engine, Flexium, GML/Game Maker Studio2, GTK3+OpenGL3, Irrlicht Engine, L\u00d6VE+LUA, Magnum, NanoRT, Nim Game Lib, Ogre, openFrameworks, OSG/OpenSceneGraph, Orx, Photoshop, px_render, Qt/QtDirect3D, SFML, Sokol, Unity, Unreal Engine 4, vtk, Win32 GDI, WxWidgets. - Note that C bindings ( cimgui ) are auto-generated, you can use its json/lua output to generate bindings for other languages. Also see Wiki for more links and ideas. Upcoming Changes \u00b6 Some of the goals for 2020 are: - Finish work on docking, tabs. (see #2109 , in public docking branch looking for feedback) - Finish work on multiple viewports / multiple OS windows. (see #1542 , in public docking branch looking for feedback) - Finish work on gamepad/keyboard controls. (see #787 ) - Finish work on new Tables API (to replace Columns). (see #2957 ) - Add an automation and testing system, both to test the library and end-user apps. (see #435 ) - Make the examples look better, improve styles, improve font support, make the examples hi-DPI and multi-DPI aware. Gallery \u00b6 For more user-submitted screenshots of projects using Dear ImGui, check out the Gallery Threads ! Custom engine Custom engine Tracy Profiler Support, Frequently Asked Questions (FAQ) \u00b6 Most common questions will be answered by the Frequently Asked Questions (FAQ) page. See: Wiki for many links, references, articles. See: Articles about the IMGUI paradigm to read/learn about the Immediate Mode GUI paradigm. If you are new to Dear ImGui and have issues with: compiling, linking, adding fonts, wiring inputs, running or displaying Dear ImGui: you can use Discord server . Otherwise, for any other questions, bug reports, requests, feedback, you may post on https://github.com/ocornut/imgui/issues . Please read and fill the New Issue template carefully. Paid private support is available for business customers (E-mail: contact @ dearimgui dot org ). Which version should I get? I occasionally tag Releases but it is generally safe and recommended to sync to master/latest. The library is fairly stable and regressions tend to be fixed fast when reported. You may also peak at the Multi-Viewport and Docking features in the docking branch. Many projects are using this branch and it is kept in sync with master regularly. Who uses Dear ImGui? See the Quotes , Sponsors , Software using dear imgui Wiki pages for an idea of who is using Dear ImGui. Please add your game/software if you can! Also see the Gallery Threads ! How to help \u00b6 How can I help? You may participate in the Discord server , GitHub forum/issues . You may help with development and submit pull requests! Please understand that by submitting a PR you are also submitting a request for the maintainer to review your code and then take over its maintenance forever. PR should be crafted both in the interest in the end-users and also to ease the maintainer into understanding and accepting it. See Help wanted on the Wiki for some more ideas. Have your company financially support this project. How can I help financing further development of Dear ImGui? Your contributions are keeping this project alive. The library is available under a free and permissive license, but continued maintenance and development are a full-time endeavor and I would like to grow the team. In addition to maintenance and stability there are many desirable features yet to be added. If your company is using dear imgui, please consider reaching out for invoiced technical support and maintenance contracts. Thank you! Businesses: support continued development via invoiced technical support, maintenance, sponsoring contracts: E-mail: contact @ dearimgui dot org Individuals: support continued maintenance and development with PayPal . Sponsors \u00b6 Ongoing Dear ImGui development is financially supported by users and private sponsors, recently: Platinum-chocolate sponsors - Blizzard , Google , Nvidia , Ubisoft Double-chocolate and Salty caramel sponsors - Activision , Arkane Studios , Dotemu , Framefield , Hexagon , Kylotonn , Media Molecule , Mesh Consultants , Mobigame , Nadeo , Next Level Games , Supercell , Remedy Entertainment , Unit 2 Games From November 2014 to December 2019, ongoing development has also been financially supported by its users on Patreon and through individual donations. Please see detailed list of Dear ImGui supporters . THANK YOU to all past and present supporters for helping to keep this project alive and thriving! Dear ImGui is using software and services provided free of charge for open source projects: - PVS-Studio for static analysis. - GitHub actions for continuous integration systems. - OpenCppCoverage for code coverage analysis. Credits \u00b6 Developed by Omar Cornut and every direct or indirect contributors to the GitHub. The early version of this library was developed with the support of Media Molecule and first used internally on the game Tearaway (PS Vita). I first discovered the IMGUI paradigm at Q-Games where Atman Binstock had dropped his own simple implementation in the codebase, which I spent quite some time improving and thinking about. It turned out that Atman was exposed to the concept directly by working with Casey. When I moved to Media Molecule I rewrote a new library trying to overcome the flaws and limitations of the first one I've worked with. It became this library and since then I have spent an unreasonable amount of time iterating and improving it. Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). Embeds stb_textedit.h, stb_truetype.h, stb_rect_pack.h by Sean Barrett (public domain). Inspiration, feedback, and testing for early versions: Casey Muratori, Atman Binstock, Mikko Mononen, Emmanuel Briney, Stefan Kamoda, Anton Mikhailov, Matt Willis. And everybody posting feedback, questions and patches on the GitHub. License \u00b6 Dear ImGui is licensed under the MIT License, see LICENSE.txt for more information.","title":"Home"},{"location":"#dear-imgui","text":"(This library is available under a free and permissive license, but needs financial support to sustain its continued improvements. In addition to maintenance and stability there are many desirable features yet to be added. If your company is using dear imgui, please consider reaching out.) Businesses: support continued development via invoiced technical support, maintenance, sponsoring contracts: E-mail: contact @ dearimgui dot org Individuals: support continued maintenance and development with PayPal . Dear ImGui is a bloat-free graphical user interface library for C++ . It outputs optimized vertex buffers that you can render anytime in your 3D-pipeline enabled application. It is fast, portable, renderer agnostic and self-contained (no external dependencies). Dear ImGui is designed to enable fast iterations and to empower programmers to create content creation tools and visualization / debug tools (as opposed to UI for the average end-user). It favors simplicity and productivity toward this goal, and lacks certain features normally found in more high-level libraries. Dear ImGui is particularly suited to integration in games engine (for tooling), real-time 3D applications, fullscreen applications, embedded applications, or any applications on consoles platforms where operating system features are non-standard. Usage - How it works - Demo - Integration Upcoming changes - Gallery - Support, FAQ - How to help - Sponsors - Credits - License Wiki - Language & frameworks bindings - Software using Dear ImGui - User quotes","title":"dear imgui"},{"location":"#usage","text":"The core of Dear ImGui is self-contained within a few platform-agnostic files which you can easily compile in your application/engine. They are all the files in the root folder of the repository (imgui.cpp, imgui.h, imgui_demo.cpp, imgui_draw.cpp etc.). No specific build process is required . You can add the .cpp files to your existing project. You will need a backend to integrate Dear ImGui in your app. The backend passes mouse/keyboard/gamepad inputs and variety of settings to Dear ImGui, and is in charge of rendering the resulting vertices. Backends for a variety of graphics api and rendering platforms are provided in the examples/ folder, along with example applications. See the Integration section of this document for details. You may also create your own backend. Anywhere where you can render textured triangles, you can render Dear ImGui. After Dear ImGui is setup in your application, you can use it from _anywhere_ in your program loop: Code: ImGui :: Text ( \"Hello, world %d\" , 123 ); if ( ImGui :: Button ( \"Save\" )) MySaveFunction (); ImGui :: InputText ( \"string\" , buf , IM_ARRAYSIZE ( buf )); ImGui :: SliderFloat ( \"float\" , & f , 0.0 f , 1.0 f ); Result: (settings: Dark style (left), Light style (right) / Font: Roboto-Medium, 16px / Rounding: 5) Code: // Create a window called \"My First Tool\", with a menu bar. ImGui :: Begin ( \"My First Tool\" , & my_tool_active , ImGuiWindowFlags_MenuBar ); if ( ImGui :: BeginMenuBar ()) { if ( ImGui :: BeginMenu ( \"File\" )) { if ( ImGui :: MenuItem ( \"Open..\" , \"Ctrl+O\" )) { /* Do stuff */ } if ( ImGui :: MenuItem ( \"Save\" , \"Ctrl+S\" )) { /* Do stuff */ } if ( ImGui :: MenuItem ( \"Close\" , \"Ctrl+W\" )) { my_tool_active = false ; } ImGui :: EndMenu (); } ImGui :: EndMenuBar (); } // Edit a color (stored as ~4 floats) ImGui :: ColorEdit4 ( \"Color\" , my_color ); // Plot some values const float my_values [] = { 0.2f , 0.1f , 1.0f , 0.5f , 0.9f , 2.2f }; ImGui :: PlotLines ( \"Frame Times\" , my_values , IM_ARRAYSIZE ( my_values )); // Display contents in a scrolling region ImGui :: TextColored ( ImVec4 ( 1 , 1 , 0 , 1 ), \"Important Stuff\" ); ImGui :: BeginChild ( \"Scrolling\" ); for ( int n = 0 ; n < 50 ; n ++ ) ImGui :: Text ( \"%04d: Some text\" , n ); ImGui :: EndChild (); ImGui :: End (); Result: Dear ImGui allows you to create elaborate tools as well as very short-lived ones. On the extreme side of short-livedness: using the Edit&Continue (hot code reload) feature of modern compilers you can add a few widgets to tweaks variables while your application is running, and remove the code a minute later! Dear ImGui is not just for tweaking values. You can use it to trace a running algorithm by just emitting text commands. You can use it along with your own reflection data to browse your dataset live. You can use it to expose the internals of a subsystem in your engine, to create a logger, an inspection tool, a profiler, a debugger, an entire game making editor/framework, etc.","title":"Usage"},{"location":"#how-it-works","text":"Check out the Wiki's About the IMGUI paradigm section if you want to understand the core principles behind the IMGUI paradigm. An IMGUI tries to minimize superfluous state duplication, state synchronization and state retention from the user's point of view. It is less error prone (less code and less bugs) than traditional retained-mode interfaces, and lends itself to create dynamic user interfaces. Dear ImGui outputs vertex buffers and command lists that you can easily render in your application. The number of draw calls and state changes required to render them is fairly small. Because Dear ImGui doesn't know or touch graphics state directly, you can call its functions anywhere in your code (e.g. in the middle of a running algorithm, or in the middle of your own rendering process). Refer to the sample applications in the examples/ folder for instructions on how to integrate dear imgui with your existing codebase. A common misunderstanding is to mistake immediate mode gui for immediate mode rendering, which usually implies hammering your driver/GPU with a bunch of inefficient draw calls and state changes as the gui functions are called. This is NOT what Dear ImGui does. Dear ImGui outputs vertex buffers and a small list of draw calls batches. It never touches your GPU directly. The draw call batches are decently optimal and you can render them later, in your app or even remotely.","title":"How it works"},{"location":"#demo","text":"Calling the ImGui::ShowDemoWindow() function will create a demo window showcasing variety of features and examples. The code is always available for reference in imgui_demo.cpp . You should be able to build the examples from sources (tested on Windows/Mac/Linux). If you don't, let me know! If you want to have a quick look at some Dear ImGui features, you can download Windows binaries of the demo app here: - imgui-demo-binaries-20190715.zip (Windows binaries, 1.76, built 2020/04/12, master branch) or older demo binaries . The demo applications are not DPI aware so expect some blurriness on a 4K screen. For DPI awareness in your application, you can load/reload your font at different scale, and scale your style with style.ScaleAllSizes() .","title":"Demo"},{"location":"#integration","text":"On most platforms and when using C++, you should be able to use a combination of the imgui_impl_xxxx files without modification (e.g. imgui_impl_win32.cpp + imgui_impl_dx11.cpp ). If your engine supports multiple platforms, consider using more of the imgui_impl_xxxx files instead of rewriting them: this will be less work for you and you can get Dear ImGui running immediately. You can later decide to rewrite a custom binding using your custom engine functions if you wish so. Integrating Dear ImGui within your custom engine is a matter of 1) wiring mouse/keyboard/gamepad inputs 2) uploading one texture to your GPU/render engine 3) providing a render function that can bind textures and render textured triangles. The examples/ folder is populated with applications doing just that. If you are an experienced programmer at ease with those concepts, it should take you less than two hours to integrate Dear ImGui in your custom engine. Make sure to spend time reading the FAQ , comments, and some of the examples/ application! Officially maintained bindings (in repository): - Renderers: DirectX9, DirectX10, DirectX11, DirectX12, OpenGL (legacy), OpenGL3/ES/ES2 (modern), Vulkan, Metal. - Platforms: GLFW, SDL2, Win32, Glut, OSX. - Frameworks: Emscripten, Allegro5, Marmalade. Third-party bindings (see Bindings page): - Languages: C, C#/.Net, ChaiScript, D, Go, Haskell, Haxe/hxcpp, Java, JavaScript, Julia, Kotlin, Lua, Odin, Pascal, PureBasic, Python, Ruby, Rust, Swift... - Frameworks: AGS/Adventure Game Studio, Amethyst, bsf, Cinder, Cocos2d-x, Diligent Engine, Flexium, GML/Game Maker Studio2, GTK3+OpenGL3, Irrlicht Engine, L\u00d6VE+LUA, Magnum, NanoRT, Nim Game Lib, Ogre, openFrameworks, OSG/OpenSceneGraph, Orx, Photoshop, px_render, Qt/QtDirect3D, SFML, Sokol, Unity, Unreal Engine 4, vtk, Win32 GDI, WxWidgets. - Note that C bindings ( cimgui ) are auto-generated, you can use its json/lua output to generate bindings for other languages. Also see Wiki for more links and ideas.","title":"Integration"},{"location":"#upcoming-changes","text":"Some of the goals for 2020 are: - Finish work on docking, tabs. (see #2109 , in public docking branch looking for feedback) - Finish work on multiple viewports / multiple OS windows. (see #1542 , in public docking branch looking for feedback) - Finish work on gamepad/keyboard controls. (see #787 ) - Finish work on new Tables API (to replace Columns). (see #2957 ) - Add an automation and testing system, both to test the library and end-user apps. (see #435 ) - Make the examples look better, improve styles, improve font support, make the examples hi-DPI and multi-DPI aware.","title":"Upcoming Changes"},{"location":"#gallery","text":"For more user-submitted screenshots of projects using Dear ImGui, check out the Gallery Threads ! Custom engine Custom engine Tracy Profiler","title":"Gallery"},{"location":"#support-frequently-asked-questions-faq","text":"Most common questions will be answered by the Frequently Asked Questions (FAQ) page. See: Wiki for many links, references, articles. See: Articles about the IMGUI paradigm to read/learn about the Immediate Mode GUI paradigm. If you are new to Dear ImGui and have issues with: compiling, linking, adding fonts, wiring inputs, running or displaying Dear ImGui: you can use Discord server . Otherwise, for any other questions, bug reports, requests, feedback, you may post on https://github.com/ocornut/imgui/issues . Please read and fill the New Issue template carefully. Paid private support is available for business customers (E-mail: contact @ dearimgui dot org ). Which version should I get? I occasionally tag Releases but it is generally safe and recommended to sync to master/latest. The library is fairly stable and regressions tend to be fixed fast when reported. You may also peak at the Multi-Viewport and Docking features in the docking branch. Many projects are using this branch and it is kept in sync with master regularly. Who uses Dear ImGui? See the Quotes , Sponsors , Software using dear imgui Wiki pages for an idea of who is using Dear ImGui. Please add your game/software if you can! Also see the Gallery Threads !","title":"Support, Frequently Asked Questions (FAQ)"},{"location":"#how-to-help","text":"How can I help? You may participate in the Discord server , GitHub forum/issues . You may help with development and submit pull requests! Please understand that by submitting a PR you are also submitting a request for the maintainer to review your code and then take over its maintenance forever. PR should be crafted both in the interest in the end-users and also to ease the maintainer into understanding and accepting it. See Help wanted on the Wiki for some more ideas. Have your company financially support this project. How can I help financing further development of Dear ImGui? Your contributions are keeping this project alive. The library is available under a free and permissive license, but continued maintenance and development are a full-time endeavor and I would like to grow the team. In addition to maintenance and stability there are many desirable features yet to be added. If your company is using dear imgui, please consider reaching out for invoiced technical support and maintenance contracts. Thank you! Businesses: support continued development via invoiced technical support, maintenance, sponsoring contracts: E-mail: contact @ dearimgui dot org Individuals: support continued maintenance and development with PayPal .","title":"How to help"},{"location":"#sponsors","text":"Ongoing Dear ImGui development is financially supported by users and private sponsors, recently: Platinum-chocolate sponsors - Blizzard , Google , Nvidia , Ubisoft Double-chocolate and Salty caramel sponsors - Activision , Arkane Studios , Dotemu , Framefield , Hexagon , Kylotonn , Media Molecule , Mesh Consultants , Mobigame , Nadeo , Next Level Games , Supercell , Remedy Entertainment , Unit 2 Games From November 2014 to December 2019, ongoing development has also been financially supported by its users on Patreon and through individual donations. Please see detailed list of Dear ImGui supporters . THANK YOU to all past and present supporters for helping to keep this project alive and thriving! Dear ImGui is using software and services provided free of charge for open source projects: - PVS-Studio for static analysis. - GitHub actions for continuous integration systems. - OpenCppCoverage for code coverage analysis.","title":"Sponsors"},{"location":"#credits","text":"Developed by Omar Cornut and every direct or indirect contributors to the GitHub. The early version of this library was developed with the support of Media Molecule and first used internally on the game Tearaway (PS Vita). I first discovered the IMGUI paradigm at Q-Games where Atman Binstock had dropped his own simple implementation in the codebase, which I spent quite some time improving and thinking about. It turned out that Atman was exposed to the concept directly by working with Casey. When I moved to Media Molecule I rewrote a new library trying to overcome the flaws and limitations of the first one I've worked with. It became this library and since then I have spent an unreasonable amount of time iterating and improving it. Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). Embeds stb_textedit.h, stb_truetype.h, stb_rect_pack.h by Sean Barrett (public domain). Inspiration, feedback, and testing for early versions: Casey Muratori, Atman Binstock, Mikko Mononen, Emmanuel Briney, Stefan Kamoda, Anton Mikhailov, Matt Willis. And everybody posting feedback, questions and patches on the GitHub.","title":"Credits"},{"location":"#license","text":"Dear ImGui is licensed under the MIT License, see LICENSE.txt for more information.","title":"License"},{"location":"FAQ/","text":"FAQ (Frequenty Asked Questions) \u00b6 You may link to this document using short form: https://www.dearimgui.org/faq or its real address: https://github.com/ocornut/imgui/blob/master/docs/FAQ.md or view this file with any Markdown viewer. Index \u00b6 Q&A: Basics Where is the documentation? What is this library called? Which version should I get? Q&A: Integration How can I tell whether to dispatch mouse/keyboard to Dear ImGui or to my application? How can I enable keyboard or gamepad controls? How can I use this on a machine without mouse, keyboard or screen? (input share, remote display) I integrated Dear ImGui in my engine and the text or lines are blurry.. I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around.. Q&A: Usage Why are multiple widgets reacting when I interact with a single one? How can I have multiple widgets with the same label or with an empty label? How can I display an image? What is ImTextureID, how does it work? How can I use my own math types instead of ImVec2/ImVec4? How can I interact with standard C++ types (such as std::string and std::vector)? How can I display custom shapes? (using low-level ImDrawList API) Q&A: Fonts, Text How can I load a different font than the default? How can I easily use icons in my application? How can I load multiple fonts? How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic? Q&A: Concerns Who uses Dear ImGui? Can you create elaborate/serious tools with Dear ImGui? Can you reskin the look of Dear ImGui? Why using C++ (as opposed to C)? Q&A: Community How can I help? Q&A: Basics \u00b6 Q: Where is the documentation? \u00b6 This library is poorly documented at the moment and expects of the user to be acquainted with C/C++. - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the examples/ folder to explain how to integrate Dear ImGui with your own engine/application. You can run those applications and explore them. - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function. The demo covers most features of Dear ImGui, so you can read the code and see its output. - See documentation and comments at the top of imgui.cpp + general API comments in imgui.h . - The Wiki has many resources and links. - The Glossary page may be useful. - The Issues section can be searched for past questions and issues. - Your programming IDE is your friend, find the type or function declaration to find comments associated to it. - The ImGui::ShowMetricsWindow() function exposes lots of internal information and tools. Although it is primary designed as a debugging tool, having access to that information tends to help understands concepts. Return to Index \u00b6 Q. What is this library called? \u00b6 This library is called Dear ImGui . Please refer to it as Dear ImGui (not ImGui, not IMGUI). (The library misleadingly started its life in 2014 as \"ImGui\" due to the fact that I didn't give it a proper name when when I released 1.0, and had no particular expectation that it would take off. However, the term IMGUI (immediate-mode graphical user interface) was coined before and is being used in variety of other situations e.g. Unity uses it own implementation of the IMGUI paradigm. To reduce the ambiguity without affecting existing code bases, I have decided in December 2015 a fully qualified name \"Dear ImGui\" for this library. Return to Index \u00b6 Q: Which version should I get? \u00b6 I occasionally tag Releases but it is generally safe and recommended to sync to master/latest. The library is fairly stable and regressions tend to be fixed fast when reported. You may use the docking branch which includes: - Docking features - Multi-viewport features Many projects are using this branch and it is kept in sync with master regularly. Return to Index \u00b6 Q&A: Integration \u00b6 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or to my application? \u00b6 You can read the io.WantCaptureMouse , io.WantCaptureKeyboard and io.WantTextInput flags from the ImGuiIO structure. e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } When io.WantCaptureMouse is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application. When io.WantCaptureKeyboard is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application. When io.WantTextInput is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS). Note: You should always pass your mouse/keyboard inputs to Dear ImGui, even when the io.WantCaptureXXX flag are set false. This is because imgui needs to detect that you clicked in the void to unfocus its own windows. Note: The io.WantCaptureMouse is more correct that any manual attempt to \"check if the mouse is hovering a window\" (don't do that!). It handle mouse dragging correctly (both dragging that started over your application or over a Dear ImGui window) and handle e.g. popup and modal windows blocking inputs. Note: Those flags are updated by ImGui::NewFrame() . However it is generally more correct and easier that you poll flags from the previous frame, then submit your inputs, then call NewFrame() . If you attempt to do the opposite (which is generally harder) you are likely going to submit your inputs after NewFrame() , and therefore too late. Note: If you are using a touch device, you may find use for an early call to UpdateHoveredWindowAndCaptureFlags() to correctly dispatch your initial touch. We will work on better out-of-the-box touch support in the future. Note: Text input widget releases focus on the \"KeyDown\" event of the Return key, so the subsequent \"KeyUp\" event that your application receive will typically have io.WantCaptureKeyboard == false . Depending on your application logic it may or not be inconvenient to receive that KeyUp event. You might want to track which key-downs were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.) Return to Index \u00b6 Q: How can I enable keyboard or gamepad controls? \u00b6 The gamepad/keyboard navigation is fairly functional and keeps being improved. The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable. Gamepad support is particularly useful to use Dear ImGui on a game console (e.g. PS4, Switch, XB1) without a mouse connected! Keyboard: set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. Gamepad: set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable (with a supporting back-end). See Control Sheets for Gamepads (reference PNG/PSD for for PS4, XB1, Switch gamepads). See USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS section of imgui.cpp for more details. Return to Index \u00b6 Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display) \u00b6 You can share your computer mouse seamlessly with your console/tablet/phone using solutions such as Synergy This is the preferred solution for developer productivity. In particular, the micro-synergy-client repository has simple and portable source code (uSynergy.c/.h) for a small embeddable client that you can use on any platform to connect to your host computer, based on the Synergy 1.x protocol. Make sure you download the Synergy 1 server on your computer. Console SDK also sometimes provide equivalent tooling or wrapper for Synergy-like protocols. Game console users: consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback. You may also use a third party solution such as Remote ImGui or imgui-ws which sends the vertices to render over the local network, allowing you to use Dear ImGui even on a screen-less machine. See Wiki index for most details. For touch inputs, you can increase the hit box of widgets (via the style.TouchPadding setting) to accommodate for the lack of precision of touch inputs, but it is recommended you use a mouse or gamepad to allow optimizing for screen real-estate and precision. Return to Index \u00b6 Q: I integrated Dear ImGui in my engine and the text or lines are blurry.. \u00b6 In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f). Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension. Return to Index \u00b6 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around.. \u00b6 You are probably mishandling the clipping rectangles in your render function. Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height) Return to Index \u00b6 Q&A: Usage \u00b6 Q: Why are multiple widgets reacting when I interact with a single one? Q: How can I have multiple widgets with the same label or with an empty label? \u00b6 A primer on labels and the ID Stack... Dear ImGui internally need to uniquely identify UI elements. Elements that are typically not clickable (such as calls to the Text functions) don't need an ID. Interactive widgets (such as calls to Button buttons) need a unique ID. Unique ID are used internally to track active widgets and occasionally associate state to widgets. Unique ID are implicitly built from the hash of multiple elements that identify the \"path\" to the UI element. Unique ID are often derived from a string label and at minimum scoped within their host window: Begin ( \"MyWindow\" ); Button ( \"OK\" ); // Label = \"OK\", ID = hash of (\"MyWindow\", \"OK\") Button ( \"Cancel\" ); // Label = \"Cancel\", ID = hash of (\"MyWindow\", \"Cancel\") End (); Other elements such as tree nodes, etc. also pushes to the ID stack: Begin ( \"MyWindow\" ); if ( TreeNode ( \"MyTreeNode\" )) { Button ( \"OK\" ); // Label = \"OK\", ID = hash of (\"MyWindow\", \"MyTreeNode\", \"OK\") TreePop (); } End (); Two items labeled \"OK\" in different windows or different tree locations won't collide: Begin(\"MyFirstWindow\"); Button(\"OK\"); // Label = \"OK\", ID = hash of (\"MyFirstWindow\", \"OK\") End(); Begin(\"MyOtherWindow\"); Button(\"OK\"); // Label = \"OK\", ID = hash of (\"MyOtherWindow\", \"OK\") End(); We used \"...\" above to signify whatever was already pushed to the ID stack previously: If you have a same ID twice in the same location, you'll have a conflict: Button ( \"OK\" ); Button ( \"OK\" ); // ID collision! Interacting with either button will trigger the first one. Fear not! this is easy to solve and there are many ways to solve it! Solving ID conflict in a simple/local context: When passing a label you can optionally specify extra ID information within string itself. Use \"##\" to pass a complement to the ID that won't be visible to the end-user. This helps solving the simple collision cases when you know e.g. at compilation time which items are going to be created: Begin ( \"MyWindow\" ); Button ( \"Play\" ); // Label = \"Play\", ID = hash of (\"MyWindow\", \"Play\") Button ( \"Play##foo1\" ); // Label = \"Play\", ID = hash of (\"MyWindow\", \"Play##foo1\") // Different from above Button ( \"Play##foo2\" ); // Label = \"Play\", ID = hash of (\"MyWindow\", \"Play##foo2\") // Different from above End (); If you want to completely hide the label, but still need an ID: Checkbox ( \"##On\" , & b ); // Label = \"\", ID = hash of (..., \"##On\") // No visible label, just a checkbox! Occasionally/rarely you might want change a label while preserving a constant ID. This allows you to animate labels. For example you may want to include varying information in a window title bar, but windows are uniquely identified by their ID. Use \"###\" to pass a label that isn't part of ID: Button ( \"Hello###ID\" ); // Label = \"Hello\", ID = hash of (..., \"###ID\") Button ( \"World###ID\" ); // Label = \"World\", ID = hash of (..., \"###ID\") // Same as above, even if the label looks different sprintf ( buf , \"My game (%f FPS)###MyGame\" , fps ); Begin ( buf ); // Variable title, ID = hash of \"MyGame\" Solving ID conflict in a more general manner: Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts within the same window. This is the most convenient way of distinguishing ID when iterating and creating many UI elements programmatically. You can push a pointer, a string or an integer value into the ID stack. Remember that ID are formed from the concatenation of everything pushed into the ID stack. At each level of the stack we store the seed used for items at this level of the ID stack. Begin ( \"Window\" ); for ( int i = 0 ; i < 100 ; i ++ ) { PushID ( i ); // Push i to the id tack Button ( \"Click\" ); // Label = \"Click\", ID = hash of (\"Window\", i, \"Click\") PopID (); } for ( int i = 0 ; i < 100 ; i ++ ) { MyObject * obj = Objects [ i ]; PushID ( obj ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (\"Window\", obj pointer, \"Click\") PopID (); } for ( int i = 0 ; i < 100 ; i ++ ) { MyObject * obj = Objects [ i ]; PushID ( obj -> Name ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (\"Window\", obj->Name, \"Click\") PopID (); } End (); You can stack multiple prefixes into the ID stack: Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"Click\") PushID ( \"node\" ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"node\", \"Click\") PushID ( my_ptr ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"node\", my_ptr, \"Click\") PopID (); PopID (); Tree nodes implicitly creates a scope for you by calling PushID(). Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"Click\") if ( TreeNode ( \"node\" )) // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag) { Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"node\", \"Click\") TreePop (); } When working with trees, ID are used to preserve the open/close state of each tree node. Depending on your use cases you may want to use strings, indices or pointers as ID. e.g. when following a single pointer that may change over time, using a static string as ID will preserve your node open/closed state when the targeted object change. e.g. when displaying a list of objects, using indices or pointers as ID will preserve the node open/closed state differently. See what makes more sense in your situation! Return to Index \u00b6 Q: How can I display an image? What is ImTextureID, how does it work? \u00b6 Short explanation: - Refer to Image Loading and Displaying Examples on the Wiki . - You may use functions such as ImGui::Image() , ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures. - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value. - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason). Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward. Long explanation: - Dear ImGui's job is to create \"meshes\", defined in a renderer-agnostic format made of draw commands and vertices. At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.). - Each rendering function decides on a data type to represent \"textures\". The concept of what is a \"texture\" is entirely tied to your underlying engine/graphics API. We carry the information to identify a \"texture\" in the ImTextureID type. ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice. Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function. - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying an image from the end-user perspective. This is what the examples rendering functions are using: OpenGL: - ImTextureID = GLuint - See ImGui_ImplOpenGL3_RenderDrawData() function in imgui_impl_opengl3.cpp DirectX9: - ImTextureID = LPDIRECT3DTEXTURE9 - See ImGui_ImplDX9_RenderDrawData() function in imgui_impl_dx9.cpp DirectX11: - ImTextureID = ID3D11ShaderResourceView* - See ImGui_ImplDX11_RenderDrawData() function in imgui_impl_dx11.cpp DirectX12: - ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE - See ImGui_ImplDX12_RenderDrawData() function in imgui_impl_dx12.cpp For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID. Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure tying together both the texture and information about its format and how to read it. If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase is designed. If your engine has high-level data types for \"textures\" and \"material\" then you may want to use them. If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID representation suggested by the example bindings is probably the best choice. (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer) User code may do: // Cast our texture type to ImTextureID / void* MyTexture * texture = g_CoffeeTableTexture ; ImGui :: Image (( void * ) texture , ImVec2 ( texture -> Width , texture -> Height )); The renderer function called after ImGui::Render() will receive that same value that the user code passed: // Cast ImTextureID / void* stored in the draw command as our texture type MyTexture * texture = ( MyTexture * ) pcmd -> TextureId ; MyEngineBindTexture2D ( texture ); Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui. This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them. If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using. Refer to Image Loading and Displaying Examples on the Wiki to find simplified examples for loading textures with OpenGL, DirectX9 and DirectX11. C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTextureID / void*, and vice-versa. Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTextureID / void*. Examples: GLuint my_tex = XXX ; void * my_void_ptr ; my_void_ptr = ( void * )( intptr_t ) my_tex ; // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer) my_tex = ( GLuint )( intptr_t ) my_void_ptr ; // cast a void* into a GLuint ID3D11ShaderResourceView * my_dx11_srv = XXX ; void * my_void_ptr ; my_void_ptr = ( void * ) my_dx11_srv ; // cast a ID3D11ShaderResourceView* into an opaque void* my_dx11_srv = ( ID3D11ShaderResourceView * ) my_void_ptr ; // cast a void* into a ID3D11ShaderResourceView* Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated. Return to Index \u00b6 Q: How can I use my own math types instead of ImVec2/ImVec4? \u00b6 You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA / IM_VEC4_CLASS_EXTRA macros to add implicit type conversions. This way you'll be able to use your own types everywhere, e.g. passing MyVector2 or glm::vec2 to ImGui functions instead of ImVec2 . Return to Index \u00b6 Q: How can I interact with standard C++ types (such as std::string and std::vector)? \u00b6 Being highly portable (bindings for several languages, frameworks, programming style, obscure or older platforms/compilers), and aiming for compatibility & performance suitable for every modern real-time game engines, dear imgui does not use any of std C++ types. We use raw types (e.g. char* instead of std::string) because they adapt to more use cases. To use ImGui::InputText() with a std::string or any resizable string class, see misc/cpp/imgui_stdlib.h . To use combo boxes and list boxes with std::vector or any other data structure: the BeginCombo()/EndCombo() API lets you iterate and submit items yourself, so does the ListBoxHeader()/ListBoxFooter() API. Prefer using them over the old and awkward Combo()/ListBox() api. Generally for most high-level types you should be able to access the underlying data type. You may write your own one-liner wrappers to facilitate user code (tip: add new functions in ImGui:: namespace from your code). Dear ImGui applications often need to make intensive use of strings. It is expected that many of the strings you will pass to the API are raw literals (free in C/C++) or allocated in a manner that won't incur a large cost on your application. Please bear in mind that using std::string on applications with large amount of UI may incur unsatisfactory performances. Modern implementations of std::string often include small-string optimization (which is often a local buffer) but those are not configurable and not the same across implementations. If you are finding your UI traversal cost to be too large, make sure your string usage is not leading to excessive amount of heap allocations. Consider using literals, statically sized buffers and your own helper functions. A common pattern is that you will need to build lots of strings on the fly, and their maximum length can be easily be scoped ahead. One possible implementation of a helper to facilitate printf-style building of strings: https://github.com/ocornut/Str This is a small helper where you can instance strings with configurable local buffers length. Many game engines will provide similar or better string helpers. Return to Index \u00b6 Q: How can I display custom shapes? (using low-level ImDrawList API) \u00b6 You can use the low-level ImDrawList api to render shapes within a window. ImGui::Begin(\"My shapes\"); ImDrawList* draw_list = ImGui::GetWindowDrawList(); // Get the current ImGui cursor position ImVec2 p = ImGui::GetCursorScreenPos(); // Draw a red circle draw_list->AddCircleFilled(ImVec2(p.x + 50, p.y + 50), 30.0f, IM_COL32(255, 0, 0, 255), 16); // Draw a 3 pixel thick yellow line draw_list->AddLine(ImVec2(p.x, p.y), ImVec2(p.x + 100.0f, p.y + 100.0f), IM_COL32(255, 255, 0, 255), 3.0f); // Advance the ImGui cursor to claim space in the window (otherwise the window will appears small and needs to be resized) ImGui::Dummy(ImVec2(200, 200)); ImGui::End(); Refer to \"Demo > Examples > Custom Rendering\" in the demo window and read the code of ShowExampleAppCustomRendering() in imgui_demo.cpp from more examples. To generate colors: you can use the macro IM_COL32(255,255,255,255) to generate them at compile time, or use ImGui::GetColorU32(IM_COL32(255,255,255,255)) or ImGui::GetColorU32(ImVec4(1.0f,1.0f,1.0f,1.0f)) to generate a color that is multiplied by the current value of style.Alpha . Math operators: if you have setup IM_VEC2_CLASS_EXTRA in imconfig.h to bind your own math types, you can use your own math types and their natural operators instead of ImVec2. ImVec2 by default doesn't export any math operators in the public API. You may use #define IMGUI_DEFINE_MATH_OPERATORS #include \"imgui_internal.h\" to use the internally defined math operators, but instead prefer using your own math library and set it up in imconfig.h . You can use ImGui::GetBackgroundDrawList() or ImGui::GetForegroundDrawList() to access draw lists which will be displayed behind and over every other dear imgui windows (one bg/fg drawlist per viewport). This is very convenient if you need to quickly display something on the screen that is not associated to a dear imgui window. You can also create your own dummy window and draw inside it. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse). Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like. You can create your own ImDrawList instance. You'll need to initialize them with ImGui::GetDrawListSharedData() , or create your own instancing ImDrawListSharedData, and then call your renderer function with your own ImDrawList or ImDrawData data. Return to Index \u00b6 Q&A: Fonts, Text \u00b6 Q: How can I load a different font than the default? \u00b6 Use the font atlas to load the TTF/OTF file you want: ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels ); io . Fonts -> GetTexDataAsRGBA32 () or GetTexDataAsAlpha8 () Default is ProggyClean.ttf, monospace, rendered at size 13, embedded in dear imgui's source code. (Tip: monospace fonts are convenient because they allow to facilitate horizontal alignment directly at the string level.) (Read the docs/FONTS.txt file for more details about font loading.) New programmers: remember that in C/C++ and most programming languages if you want to use a backslash within a string literal, you need to write it double backslash \"\\\": io . Fonts -> AddFontFromFileTTF ( \"MyFolder\\MyFont.ttf\" , size ); // WRONG (you are escaping the M here!) io . Fonts -> AddFontFromFileTTF ( \"MyFolder \\\\ MyFont.ttf\" , size ; // CORRECT io . Fonts -> AddFontFromFileTTF ( \"MyFolder/MyFont.ttf\" , size ); // ALSO CORRECT Return to Index \u00b6 Q: How can I easily use icons in my application? \u00b6 The most convenient and practical way is to merge an icon font such as FontAwesome inside you main font. Then you can refer to icons within your strings. You may want to see ImFontConfig::GlyphMinAdvanceX to make your icon look monospace to facilitate alignment. (Read the docs/FONTS.txt file for more details about icons font loading.) With some extra effort, you may use colorful icon by registering custom rectangle space inside the font atlas, and copying your own graphics data into it. See docs/FONTS.txt about using the AddCustomRectFontGlyph API. Return to Index \u00b6 Q: How can I load multiple fonts? \u00b6 Use the font atlas to pack them into a single texture: (Read the docs/FONTS.txt file and the code in ImFontAtlas for more details.) ImGuiIO & io = ImGui :: GetIO (); ImFont * font0 = io . Fonts -> AddFontDefault (); ImFont * font1 = io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels ); ImFont * font2 = io . Fonts -> AddFontFromFileTTF ( \"myfontfile2.ttf\" , size_in_pixels ); io . Fonts -> GetTexDataAsRGBA32 () or GetTexDataAsAlpha8 () // the first loaded font gets used by default // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime // Options ImFontConfig config ; config . OversampleH = 2 ; config . OversampleV = 1 ; config . GlyphOffset . y -= 1.0f ; // Move everything by 1 pixels up config . GlyphExtraSpacing . x = 1.0f ; // Increase spacing between characters io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_pixels , & config ); // Combine multiple fonts into one (e.g. for icon fonts) static ImWchar ranges [] = { 0xf000 , 0xf3ff , 0 }; ImFontConfig config ; config . MergeMode = true ; io . Fonts -> AddFontDefault (); io . Fonts -> AddFontFromFileTTF ( \"fontawesome-webfont.ttf\" , 16.0f , & config , ranges ); // Merge icon font io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_pixels , NULL , & config , io . Fonts -> GetGlyphRangesJapanese ()); // Merge japanese glyphs Return to Index \u00b6 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic? \u00b6 When loading a font, pass custom Unicode ranges to specify the glyphs to load. // Add default Japanese ranges io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels , NULL , io . Fonts -> GetGlyphRangesJapanese ()); // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need) ImVector < ImWchar > ranges ; ImFontGlyphRangesBuilder builder ; builder . AddText ( \"Hello world\" ); // Add a string (here \"Hello world\" contains 7 unique characters) builder . AddChar ( 0x7262 ); // Add a specific character builder . AddRanges ( io . Fonts -> GetGlyphRangesJapanese ()); // Add one of the default ranges builder . BuildRanges ( & ranges ); // Build the final result (ordered ranges with all the unique characters submitted) io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , 16.0f , NULL , ranges . Data ); All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8 by using the u8\"hello\" syntax. Specifying literal in your source code using a local code page (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work! Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8. Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter() . The applications in examples/ are doing that. Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode). You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state. Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly. Return to Index \u00b6 Q&A: Concerns \u00b6 Q: Who uses Dear ImGui? \u00b6 You may take a look at: Quotes Software using Dear ImGui Gallery Return to Index \u00b6 Q: Can you create elaborate/serious tools with Dear ImGui? \u00b6 Yes. People have written game editors, data browsers, debuggers, profilers and all sort of non-trivial tools with the library. In my experience the simplicity of the API is very empowering. Your UI runs close to your live data. Make the tools always-on and everybody in the team will be inclined to create new tools (as opposed to more \"offline\" UI toolkits where only a fraction of your team effectively creates tools). The list of sponsors below is also an indicator that serious game teams have been using the library. Dear ImGui is very programmer centric and the immediate-mode GUI paradigm might require you to readjust some habits before you can realize its full potential. Dear ImGui is about making things that are simple, efficient and powerful. Dear ImGui is built to be efficient and scalable toward the needs for AAA-quality applications running all day. The IMGUI paradigm offers different opportunities for optimization that the more typical RMGUI paradigm. Return to Index \u00b6 Q: Can you reskin the look of Dear ImGui? \u00b6 Somehow. You can alter the look of the interface to some degree: changing colors, sizes, padding, rounding, fonts. However, as Dear ImGui is designed and optimized to create debug tools, the amount of skinning you can apply is limited. There is only so much you can stray away from the default look and feel of the interface. Dear ImGui is NOT designed to create user interface for games, although with ingenious use of the low-level API you can do it. A reasonably skinned application may look like (screenshot from #2529 ) Return to Index \u00b6 Q: Why using C++ (as opposed to C)? \u00b6 Dear ImGui takes advantage of a few C++ languages features for convenience but nothing anywhere Boost insanity/quagmire. Dear ImGui does NOT require C++11 so it can be used with most old C++ compilers. Dear ImGui doesn't use any C++ header file. Language-wise, function overloading and default parameters are used to make the API easier to use and code more terse. Doing so I believe the API is sitting on a sweet spot and giving up on those features would make the API more cumbersome. Other features such as namespace, constructors and templates (in the case of the ImVector<> class) are also relied on as a convenience. There is an auto-generated c-api for Dear ImGui (cimgui) by Sonoro1234 and Stephan Dilly. It is designed for creating binding to other languages. If possible, I would suggest using your target language functionalities to try replicating the function overloading and default parameters used in C++ else the API may be harder to use. Also see Bindings for various third-party bindings. Return to Index \u00b6 Q&A: Community \u00b6 Q: How can I help? \u00b6 Businesses: please reach out to contact AT dearimgui.org if you work in a place using Dear ImGui! We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts. This is among the most useful thing you can do for Dear ImGui. With increased funding we can hire more people working on this project. Individuals: you can support continued maintenance and development via PayPal donations. See README . If you are experienced with Dear ImGui and C++, look at the GitHub Issues , look at the Wiki , read docs/TODO.txt and see how you want to help and can help! Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc. You may post screenshot or links in the gallery threads . Visuals are ideal as they inspire other programmers. Disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions. If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues or sometimes incomplete PR. Return to Index \u00b6","title":"FAQ"},{"location":"FAQ/#faq-frequenty-asked-questions","text":"You may link to this document using short form: https://www.dearimgui.org/faq or its real address: https://github.com/ocornut/imgui/blob/master/docs/FAQ.md or view this file with any Markdown viewer.","title":"FAQ (Frequenty Asked Questions)"},{"location":"FAQ/#index","text":"Q&A: Basics Where is the documentation? What is this library called? Which version should I get? Q&A: Integration How can I tell whether to dispatch mouse/keyboard to Dear ImGui or to my application? How can I enable keyboard or gamepad controls? How can I use this on a machine without mouse, keyboard or screen? (input share, remote display) I integrated Dear ImGui in my engine and the text or lines are blurry.. I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around.. Q&A: Usage Why are multiple widgets reacting when I interact with a single one? How can I have multiple widgets with the same label or with an empty label? How can I display an image? What is ImTextureID, how does it work? How can I use my own math types instead of ImVec2/ImVec4? How can I interact with standard C++ types (such as std::string and std::vector)? How can I display custom shapes? (using low-level ImDrawList API) Q&A: Fonts, Text How can I load a different font than the default? How can I easily use icons in my application? How can I load multiple fonts? How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic? Q&A: Concerns Who uses Dear ImGui? Can you create elaborate/serious tools with Dear ImGui? Can you reskin the look of Dear ImGui? Why using C++ (as opposed to C)? Q&A: Community How can I help?","title":"Index"},{"location":"FAQ/#qa-basics","text":"","title":"Q&amp;A: Basics"},{"location":"FAQ/#q-where-is-the-documentation","text":"This library is poorly documented at the moment and expects of the user to be acquainted with C/C++. - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the examples/ folder to explain how to integrate Dear ImGui with your own engine/application. You can run those applications and explore them. - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function. The demo covers most features of Dear ImGui, so you can read the code and see its output. - See documentation and comments at the top of imgui.cpp + general API comments in imgui.h . - The Wiki has many resources and links. - The Glossary page may be useful. - The Issues section can be searched for past questions and issues. - Your programming IDE is your friend, find the type or function declaration to find comments associated to it. - The ImGui::ShowMetricsWindow() function exposes lots of internal information and tools. Although it is primary designed as a debugging tool, having access to that information tends to help understands concepts.","title":"Q: Where is the documentation?"},{"location":"FAQ/#return-to-index","text":"","title":"Return to Index"},{"location":"FAQ/#q-what-is-this-library-called","text":"This library is called Dear ImGui . Please refer to it as Dear ImGui (not ImGui, not IMGUI). (The library misleadingly started its life in 2014 as \"ImGui\" due to the fact that I didn't give it a proper name when when I released 1.0, and had no particular expectation that it would take off. However, the term IMGUI (immediate-mode graphical user interface) was coined before and is being used in variety of other situations e.g. Unity uses it own implementation of the IMGUI paradigm. To reduce the ambiguity without affecting existing code bases, I have decided in December 2015 a fully qualified name \"Dear ImGui\" for this library.","title":"Q. What is this library called?"},{"location":"FAQ/#return-to-index_1","text":"","title":"Return to Index"},{"location":"FAQ/#q-which-version-should-i-get","text":"I occasionally tag Releases but it is generally safe and recommended to sync to master/latest. The library is fairly stable and regressions tend to be fixed fast when reported. You may use the docking branch which includes: - Docking features - Multi-viewport features Many projects are using this branch and it is kept in sync with master regularly.","title":"Q: Which version should I get?"},{"location":"FAQ/#return-to-index_2","text":"","title":"Return to Index"},{"location":"FAQ/#qa-integration","text":"","title":"Q&amp;A: Integration"},{"location":"FAQ/#q-how-can-i-tell-whether-to-dispatch-mousekeyboard-to-dear-imgui-or-to-my-application","text":"You can read the io.WantCaptureMouse , io.WantCaptureKeyboard and io.WantTextInput flags from the ImGuiIO structure. e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } When io.WantCaptureMouse is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application. When io.WantCaptureKeyboard is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application. When io.WantTextInput is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS). Note: You should always pass your mouse/keyboard inputs to Dear ImGui, even when the io.WantCaptureXXX flag are set false. This is because imgui needs to detect that you clicked in the void to unfocus its own windows. Note: The io.WantCaptureMouse is more correct that any manual attempt to \"check if the mouse is hovering a window\" (don't do that!). It handle mouse dragging correctly (both dragging that started over your application or over a Dear ImGui window) and handle e.g. popup and modal windows blocking inputs. Note: Those flags are updated by ImGui::NewFrame() . However it is generally more correct and easier that you poll flags from the previous frame, then submit your inputs, then call NewFrame() . If you attempt to do the opposite (which is generally harder) you are likely going to submit your inputs after NewFrame() , and therefore too late. Note: If you are using a touch device, you may find use for an early call to UpdateHoveredWindowAndCaptureFlags() to correctly dispatch your initial touch. We will work on better out-of-the-box touch support in the future. Note: Text input widget releases focus on the \"KeyDown\" event of the Return key, so the subsequent \"KeyUp\" event that your application receive will typically have io.WantCaptureKeyboard == false . Depending on your application logic it may or not be inconvenient to receive that KeyUp event. You might want to track which key-downs were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)","title":"Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or to my application?"},{"location":"FAQ/#return-to-index_3","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-enable-keyboard-or-gamepad-controls","text":"The gamepad/keyboard navigation is fairly functional and keeps being improved. The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable. Gamepad support is particularly useful to use Dear ImGui on a game console (e.g. PS4, Switch, XB1) without a mouse connected! Keyboard: set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. Gamepad: set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable (with a supporting back-end). See Control Sheets for Gamepads (reference PNG/PSD for for PS4, XB1, Switch gamepads). See USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS section of imgui.cpp for more details.","title":"Q: How can I enable keyboard or gamepad controls?"},{"location":"FAQ/#return-to-index_4","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-use-this-on-a-machine-without-mouse-keyboard-or-screen-input-share-remote-display","text":"You can share your computer mouse seamlessly with your console/tablet/phone using solutions such as Synergy This is the preferred solution for developer productivity. In particular, the micro-synergy-client repository has simple and portable source code (uSynergy.c/.h) for a small embeddable client that you can use on any platform to connect to your host computer, based on the Synergy 1.x protocol. Make sure you download the Synergy 1 server on your computer. Console SDK also sometimes provide equivalent tooling or wrapper for Synergy-like protocols. Game console users: consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback. You may also use a third party solution such as Remote ImGui or imgui-ws which sends the vertices to render over the local network, allowing you to use Dear ImGui even on a screen-less machine. See Wiki index for most details. For touch inputs, you can increase the hit box of widgets (via the style.TouchPadding setting) to accommodate for the lack of precision of touch inputs, but it is recommended you use a mouse or gamepad to allow optimizing for screen real-estate and precision.","title":"Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)"},{"location":"FAQ/#return-to-index_5","text":"","title":"Return to Index"},{"location":"FAQ/#q-i-integrated-dear-imgui-in-my-engine-and-the-text-or-lines-are-blurry","text":"In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f). Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.","title":"Q: I integrated Dear ImGui in my engine and the text or lines are blurry.."},{"location":"FAQ/#return-to-index_6","text":"","title":"Return to Index"},{"location":"FAQ/#q-i-integrated-dear-imgui-in-my-engine-and-some-elements-are-clipping-or-disappearing-when-i-move-windows-around","text":"You are probably mishandling the clipping rectangles in your render function. Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height)","title":"Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around.."},{"location":"FAQ/#return-to-index_7","text":"","title":"Return to Index"},{"location":"FAQ/#qa-usage","text":"","title":"Q&amp;A: Usage"},{"location":"FAQ/#q-why-are-multiple-widgets-reacting-when-i-interact-with-a-single-one-q-how-can-i-have-multiple-widgets-with-the-same-label-or-with-an-empty-label","text":"A primer on labels and the ID Stack... Dear ImGui internally need to uniquely identify UI elements. Elements that are typically not clickable (such as calls to the Text functions) don't need an ID. Interactive widgets (such as calls to Button buttons) need a unique ID. Unique ID are used internally to track active widgets and occasionally associate state to widgets. Unique ID are implicitly built from the hash of multiple elements that identify the \"path\" to the UI element. Unique ID are often derived from a string label and at minimum scoped within their host window: Begin ( \"MyWindow\" ); Button ( \"OK\" ); // Label = \"OK\", ID = hash of (\"MyWindow\", \"OK\") Button ( \"Cancel\" ); // Label = \"Cancel\", ID = hash of (\"MyWindow\", \"Cancel\") End (); Other elements such as tree nodes, etc. also pushes to the ID stack: Begin ( \"MyWindow\" ); if ( TreeNode ( \"MyTreeNode\" )) { Button ( \"OK\" ); // Label = \"OK\", ID = hash of (\"MyWindow\", \"MyTreeNode\", \"OK\") TreePop (); } End (); Two items labeled \"OK\" in different windows or different tree locations won't collide: Begin(\"MyFirstWindow\"); Button(\"OK\"); // Label = \"OK\", ID = hash of (\"MyFirstWindow\", \"OK\") End(); Begin(\"MyOtherWindow\"); Button(\"OK\"); // Label = \"OK\", ID = hash of (\"MyOtherWindow\", \"OK\") End(); We used \"...\" above to signify whatever was already pushed to the ID stack previously: If you have a same ID twice in the same location, you'll have a conflict: Button ( \"OK\" ); Button ( \"OK\" ); // ID collision! Interacting with either button will trigger the first one. Fear not! this is easy to solve and there are many ways to solve it! Solving ID conflict in a simple/local context: When passing a label you can optionally specify extra ID information within string itself. Use \"##\" to pass a complement to the ID that won't be visible to the end-user. This helps solving the simple collision cases when you know e.g. at compilation time which items are going to be created: Begin ( \"MyWindow\" ); Button ( \"Play\" ); // Label = \"Play\", ID = hash of (\"MyWindow\", \"Play\") Button ( \"Play##foo1\" ); // Label = \"Play\", ID = hash of (\"MyWindow\", \"Play##foo1\") // Different from above Button ( \"Play##foo2\" ); // Label = \"Play\", ID = hash of (\"MyWindow\", \"Play##foo2\") // Different from above End (); If you want to completely hide the label, but still need an ID: Checkbox ( \"##On\" , & b ); // Label = \"\", ID = hash of (..., \"##On\") // No visible label, just a checkbox! Occasionally/rarely you might want change a label while preserving a constant ID. This allows you to animate labels. For example you may want to include varying information in a window title bar, but windows are uniquely identified by their ID. Use \"###\" to pass a label that isn't part of ID: Button ( \"Hello###ID\" ); // Label = \"Hello\", ID = hash of (..., \"###ID\") Button ( \"World###ID\" ); // Label = \"World\", ID = hash of (..., \"###ID\") // Same as above, even if the label looks different sprintf ( buf , \"My game (%f FPS)###MyGame\" , fps ); Begin ( buf ); // Variable title, ID = hash of \"MyGame\" Solving ID conflict in a more general manner: Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts within the same window. This is the most convenient way of distinguishing ID when iterating and creating many UI elements programmatically. You can push a pointer, a string or an integer value into the ID stack. Remember that ID are formed from the concatenation of everything pushed into the ID stack. At each level of the stack we store the seed used for items at this level of the ID stack. Begin ( \"Window\" ); for ( int i = 0 ; i < 100 ; i ++ ) { PushID ( i ); // Push i to the id tack Button ( \"Click\" ); // Label = \"Click\", ID = hash of (\"Window\", i, \"Click\") PopID (); } for ( int i = 0 ; i < 100 ; i ++ ) { MyObject * obj = Objects [ i ]; PushID ( obj ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (\"Window\", obj pointer, \"Click\") PopID (); } for ( int i = 0 ; i < 100 ; i ++ ) { MyObject * obj = Objects [ i ]; PushID ( obj -> Name ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (\"Window\", obj->Name, \"Click\") PopID (); } End (); You can stack multiple prefixes into the ID stack: Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"Click\") PushID ( \"node\" ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"node\", \"Click\") PushID ( my_ptr ); Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"node\", my_ptr, \"Click\") PopID (); PopID (); Tree nodes implicitly creates a scope for you by calling PushID(). Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"Click\") if ( TreeNode ( \"node\" )) // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag) { Button ( \"Click\" ); // Label = \"Click\", ID = hash of (..., \"node\", \"Click\") TreePop (); } When working with trees, ID are used to preserve the open/close state of each tree node. Depending on your use cases you may want to use strings, indices or pointers as ID. e.g. when following a single pointer that may change over time, using a static string as ID will preserve your node open/closed state when the targeted object change. e.g. when displaying a list of objects, using indices or pointers as ID will preserve the node open/closed state differently. See what makes more sense in your situation!","title":"Q: Why are multiple widgets reacting when I interact with a single one? Q: How can I have multiple widgets with the same label or with an empty label?"},{"location":"FAQ/#return-to-index_8","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-display-an-image-what-is-imtextureid-how-does-it-work","text":"Short explanation: - Refer to Image Loading and Displaying Examples on the Wiki . - You may use functions such as ImGui::Image() , ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures. - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value. - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason). Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward. Long explanation: - Dear ImGui's job is to create \"meshes\", defined in a renderer-agnostic format made of draw commands and vertices. At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.). - Each rendering function decides on a data type to represent \"textures\". The concept of what is a \"texture\" is entirely tied to your underlying engine/graphics API. We carry the information to identify a \"texture\" in the ImTextureID type. ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice. Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function. - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying an image from the end-user perspective. This is what the examples rendering functions are using: OpenGL: - ImTextureID = GLuint - See ImGui_ImplOpenGL3_RenderDrawData() function in imgui_impl_opengl3.cpp DirectX9: - ImTextureID = LPDIRECT3DTEXTURE9 - See ImGui_ImplDX9_RenderDrawData() function in imgui_impl_dx9.cpp DirectX11: - ImTextureID = ID3D11ShaderResourceView* - See ImGui_ImplDX11_RenderDrawData() function in imgui_impl_dx11.cpp DirectX12: - ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE - See ImGui_ImplDX12_RenderDrawData() function in imgui_impl_dx12.cpp For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID. Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure tying together both the texture and information about its format and how to read it. If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase is designed. If your engine has high-level data types for \"textures\" and \"material\" then you may want to use them. If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID representation suggested by the example bindings is probably the best choice. (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer) User code may do: // Cast our texture type to ImTextureID / void* MyTexture * texture = g_CoffeeTableTexture ; ImGui :: Image (( void * ) texture , ImVec2 ( texture -> Width , texture -> Height )); The renderer function called after ImGui::Render() will receive that same value that the user code passed: // Cast ImTextureID / void* stored in the draw command as our texture type MyTexture * texture = ( MyTexture * ) pcmd -> TextureId ; MyEngineBindTexture2D ( texture ); Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui. This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them. If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using. Refer to Image Loading and Displaying Examples on the Wiki to find simplified examples for loading textures with OpenGL, DirectX9 and DirectX11. C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTextureID / void*, and vice-versa. Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTextureID / void*. Examples: GLuint my_tex = XXX ; void * my_void_ptr ; my_void_ptr = ( void * )( intptr_t ) my_tex ; // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer) my_tex = ( GLuint )( intptr_t ) my_void_ptr ; // cast a void* into a GLuint ID3D11ShaderResourceView * my_dx11_srv = XXX ; void * my_void_ptr ; my_void_ptr = ( void * ) my_dx11_srv ; // cast a ID3D11ShaderResourceView* into an opaque void* my_dx11_srv = ( ID3D11ShaderResourceView * ) my_void_ptr ; // cast a void* into a ID3D11ShaderResourceView* Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.","title":"Q: How can I display an image? What is ImTextureID, how does it work?"},{"location":"FAQ/#return-to-index_9","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-use-my-own-math-types-instead-of-imvec2imvec4","text":"You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA / IM_VEC4_CLASS_EXTRA macros to add implicit type conversions. This way you'll be able to use your own types everywhere, e.g. passing MyVector2 or glm::vec2 to ImGui functions instead of ImVec2 .","title":"Q: How can I use my own math types instead of ImVec2/ImVec4?"},{"location":"FAQ/#return-to-index_10","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-interact-with-standard-c-types-such-as-stdstring-and-stdvector","text":"Being highly portable (bindings for several languages, frameworks, programming style, obscure or older platforms/compilers), and aiming for compatibility & performance suitable for every modern real-time game engines, dear imgui does not use any of std C++ types. We use raw types (e.g. char* instead of std::string) because they adapt to more use cases. To use ImGui::InputText() with a std::string or any resizable string class, see misc/cpp/imgui_stdlib.h . To use combo boxes and list boxes with std::vector or any other data structure: the BeginCombo()/EndCombo() API lets you iterate and submit items yourself, so does the ListBoxHeader()/ListBoxFooter() API. Prefer using them over the old and awkward Combo()/ListBox() api. Generally for most high-level types you should be able to access the underlying data type. You may write your own one-liner wrappers to facilitate user code (tip: add new functions in ImGui:: namespace from your code). Dear ImGui applications often need to make intensive use of strings. It is expected that many of the strings you will pass to the API are raw literals (free in C/C++) or allocated in a manner that won't incur a large cost on your application. Please bear in mind that using std::string on applications with large amount of UI may incur unsatisfactory performances. Modern implementations of std::string often include small-string optimization (which is often a local buffer) but those are not configurable and not the same across implementations. If you are finding your UI traversal cost to be too large, make sure your string usage is not leading to excessive amount of heap allocations. Consider using literals, statically sized buffers and your own helper functions. A common pattern is that you will need to build lots of strings on the fly, and their maximum length can be easily be scoped ahead. One possible implementation of a helper to facilitate printf-style building of strings: https://github.com/ocornut/Str This is a small helper where you can instance strings with configurable local buffers length. Many game engines will provide similar or better string helpers.","title":"Q: How can I interact with standard C++ types (such as std::string and std::vector)?"},{"location":"FAQ/#return-to-index_11","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-display-custom-shapes-using-low-level-imdrawlist-api","text":"You can use the low-level ImDrawList api to render shapes within a window. ImGui::Begin(\"My shapes\"); ImDrawList* draw_list = ImGui::GetWindowDrawList(); // Get the current ImGui cursor position ImVec2 p = ImGui::GetCursorScreenPos(); // Draw a red circle draw_list->AddCircleFilled(ImVec2(p.x + 50, p.y + 50), 30.0f, IM_COL32(255, 0, 0, 255), 16); // Draw a 3 pixel thick yellow line draw_list->AddLine(ImVec2(p.x, p.y), ImVec2(p.x + 100.0f, p.y + 100.0f), IM_COL32(255, 255, 0, 255), 3.0f); // Advance the ImGui cursor to claim space in the window (otherwise the window will appears small and needs to be resized) ImGui::Dummy(ImVec2(200, 200)); ImGui::End(); Refer to \"Demo > Examples > Custom Rendering\" in the demo window and read the code of ShowExampleAppCustomRendering() in imgui_demo.cpp from more examples. To generate colors: you can use the macro IM_COL32(255,255,255,255) to generate them at compile time, or use ImGui::GetColorU32(IM_COL32(255,255,255,255)) or ImGui::GetColorU32(ImVec4(1.0f,1.0f,1.0f,1.0f)) to generate a color that is multiplied by the current value of style.Alpha . Math operators: if you have setup IM_VEC2_CLASS_EXTRA in imconfig.h to bind your own math types, you can use your own math types and their natural operators instead of ImVec2. ImVec2 by default doesn't export any math operators in the public API. You may use #define IMGUI_DEFINE_MATH_OPERATORS #include \"imgui_internal.h\" to use the internally defined math operators, but instead prefer using your own math library and set it up in imconfig.h . You can use ImGui::GetBackgroundDrawList() or ImGui::GetForegroundDrawList() to access draw lists which will be displayed behind and over every other dear imgui windows (one bg/fg drawlist per viewport). This is very convenient if you need to quickly display something on the screen that is not associated to a dear imgui window. You can also create your own dummy window and draw inside it. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags (The ImGuiWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse). Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like. You can create your own ImDrawList instance. You'll need to initialize them with ImGui::GetDrawListSharedData() , or create your own instancing ImDrawListSharedData, and then call your renderer function with your own ImDrawList or ImDrawData data.","title":"Q: How can I display custom shapes? (using low-level ImDrawList API)"},{"location":"FAQ/#return-to-index_12","text":"","title":"Return to Index"},{"location":"FAQ/#qa-fonts-text","text":"","title":"Q&amp;A: Fonts, Text"},{"location":"FAQ/#q-how-can-i-load-a-different-font-than-the-default","text":"Use the font atlas to load the TTF/OTF file you want: ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels ); io . Fonts -> GetTexDataAsRGBA32 () or GetTexDataAsAlpha8 () Default is ProggyClean.ttf, monospace, rendered at size 13, embedded in dear imgui's source code. (Tip: monospace fonts are convenient because they allow to facilitate horizontal alignment directly at the string level.) (Read the docs/FONTS.txt file for more details about font loading.) New programmers: remember that in C/C++ and most programming languages if you want to use a backslash within a string literal, you need to write it double backslash \"\\\": io . Fonts -> AddFontFromFileTTF ( \"MyFolder\\MyFont.ttf\" , size ); // WRONG (you are escaping the M here!) io . Fonts -> AddFontFromFileTTF ( \"MyFolder \\\\ MyFont.ttf\" , size ; // CORRECT io . Fonts -> AddFontFromFileTTF ( \"MyFolder/MyFont.ttf\" , size ); // ALSO CORRECT","title":"Q: How can I load a different font than the default?"},{"location":"FAQ/#return-to-index_13","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-easily-use-icons-in-my-application","text":"The most convenient and practical way is to merge an icon font such as FontAwesome inside you main font. Then you can refer to icons within your strings. You may want to see ImFontConfig::GlyphMinAdvanceX to make your icon look monospace to facilitate alignment. (Read the docs/FONTS.txt file for more details about icons font loading.) With some extra effort, you may use colorful icon by registering custom rectangle space inside the font atlas, and copying your own graphics data into it. See docs/FONTS.txt about using the AddCustomRectFontGlyph API.","title":"Q: How can I easily use icons in my application?"},{"location":"FAQ/#return-to-index_14","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-load-multiple-fonts","text":"Use the font atlas to pack them into a single texture: (Read the docs/FONTS.txt file and the code in ImFontAtlas for more details.) ImGuiIO & io = ImGui :: GetIO (); ImFont * font0 = io . Fonts -> AddFontDefault (); ImFont * font1 = io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels ); ImFont * font2 = io . Fonts -> AddFontFromFileTTF ( \"myfontfile2.ttf\" , size_in_pixels ); io . Fonts -> GetTexDataAsRGBA32 () or GetTexDataAsAlpha8 () // the first loaded font gets used by default // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime // Options ImFontConfig config ; config . OversampleH = 2 ; config . OversampleV = 1 ; config . GlyphOffset . y -= 1.0f ; // Move everything by 1 pixels up config . GlyphExtraSpacing . x = 1.0f ; // Increase spacing between characters io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_pixels , & config ); // Combine multiple fonts into one (e.g. for icon fonts) static ImWchar ranges [] = { 0xf000 , 0xf3ff , 0 }; ImFontConfig config ; config . MergeMode = true ; io . Fonts -> AddFontDefault (); io . Fonts -> AddFontFromFileTTF ( \"fontawesome-webfont.ttf\" , 16.0f , & config , ranges ); // Merge icon font io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_pixels , NULL , & config , io . Fonts -> GetGlyphRangesJapanese ()); // Merge japanese glyphs","title":"Q: How can I load multiple fonts?"},{"location":"FAQ/#return-to-index_15","text":"","title":"Return to Index"},{"location":"FAQ/#q-how-can-i-display-and-input-non-latin-characters-such-as-chinese-japanese-korean-cyrillic","text":"When loading a font, pass custom Unicode ranges to specify the glyphs to load. // Add default Japanese ranges io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels , NULL , io . Fonts -> GetGlyphRangesJapanese ()); // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need) ImVector < ImWchar > ranges ; ImFontGlyphRangesBuilder builder ; builder . AddText ( \"Hello world\" ); // Add a string (here \"Hello world\" contains 7 unique characters) builder . AddChar ( 0x7262 ); // Add a specific character builder . AddRanges ( io . Fonts -> GetGlyphRangesJapanese ()); // Add one of the default ranges builder . BuildRanges ( & ranges ); // Build the final result (ordered ranges with all the unique characters submitted) io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , 16.0f , NULL , ranges . Data ); All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8 by using the u8\"hello\" syntax. Specifying literal in your source code using a local code page (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work! Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8. Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter() . The applications in examples/ are doing that. Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode). You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state. Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.","title":"Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?"},{"location":"FAQ/#return-to-index_16","text":"","title":"Return to Index"},{"location":"FAQ/#qa-concerns","text":"","title":"Q&amp;A: Concerns"},{"location":"FAQ/#q-who-uses-dear-imgui","text":"You may take a look at: Quotes Software using Dear ImGui Gallery","title":"Q: Who uses Dear ImGui?"},{"location":"FAQ/#return-to-index_17","text":"","title":"Return to Index"},{"location":"FAQ/#q-can-you-create-elaborateserious-tools-with-dear-imgui","text":"Yes. People have written game editors, data browsers, debuggers, profilers and all sort of non-trivial tools with the library. In my experience the simplicity of the API is very empowering. Your UI runs close to your live data. Make the tools always-on and everybody in the team will be inclined to create new tools (as opposed to more \"offline\" UI toolkits where only a fraction of your team effectively creates tools). The list of sponsors below is also an indicator that serious game teams have been using the library. Dear ImGui is very programmer centric and the immediate-mode GUI paradigm might require you to readjust some habits before you can realize its full potential. Dear ImGui is about making things that are simple, efficient and powerful. Dear ImGui is built to be efficient and scalable toward the needs for AAA-quality applications running all day. The IMGUI paradigm offers different opportunities for optimization that the more typical RMGUI paradigm.","title":"Q: Can you create elaborate/serious tools with Dear ImGui?"},{"location":"FAQ/#return-to-index_18","text":"","title":"Return to Index"},{"location":"FAQ/#q-can-you-reskin-the-look-of-dear-imgui","text":"Somehow. You can alter the look of the interface to some degree: changing colors, sizes, padding, rounding, fonts. However, as Dear ImGui is designed and optimized to create debug tools, the amount of skinning you can apply is limited. There is only so much you can stray away from the default look and feel of the interface. Dear ImGui is NOT designed to create user interface for games, although with ingenious use of the low-level API you can do it. A reasonably skinned application may look like (screenshot from #2529 )","title":"Q: Can you reskin the look of Dear ImGui?"},{"location":"FAQ/#return-to-index_19","text":"","title":"Return to Index"},{"location":"FAQ/#q-why-using-c-as-opposed-to-c","text":"Dear ImGui takes advantage of a few C++ languages features for convenience but nothing anywhere Boost insanity/quagmire. Dear ImGui does NOT require C++11 so it can be used with most old C++ compilers. Dear ImGui doesn't use any C++ header file. Language-wise, function overloading and default parameters are used to make the API easier to use and code more terse. Doing so I believe the API is sitting on a sweet spot and giving up on those features would make the API more cumbersome. Other features such as namespace, constructors and templates (in the case of the ImVector<> class) are also relied on as a convenience. There is an auto-generated c-api for Dear ImGui (cimgui) by Sonoro1234 and Stephan Dilly. It is designed for creating binding to other languages. If possible, I would suggest using your target language functionalities to try replicating the function overloading and default parameters used in C++ else the API may be harder to use. Also see Bindings for various third-party bindings.","title":"Q: Why using C++ (as opposed to C)?"},{"location":"FAQ/#return-to-index_20","text":"","title":"Return to Index"},{"location":"FAQ/#qa-community","text":"","title":"Q&amp;A: Community"},{"location":"FAQ/#q-how-can-i-help","text":"Businesses: please reach out to contact AT dearimgui.org if you work in a place using Dear ImGui! We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts. This is among the most useful thing you can do for Dear ImGui. With increased funding we can hire more people working on this project. Individuals: you can support continued maintenance and development via PayPal donations. See README . If you are experienced with Dear ImGui and C++, look at the GitHub Issues , look at the Wiki , read docs/TODO.txt and see how you want to help and can help! Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc. You may post screenshot or links in the gallery threads . Visuals are ideal as they inspire other programmers. Disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions. If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues or sometimes incomplete PR.","title":"Q: How can I help?"},{"location":"FAQ/#return-to-index_21","text":"","title":"Return to Index"},{"location":"FONTS/","text":"dear imgui Fonts Documentation \u00b6 Also read https://www.dearimgui.org/faq for more fonts related infos. The code in imgui.cpp embeds a copy of ProggyClean.ttf (by Tristan Grimmer), a 13 pixels high, pixel-perfect font used by default. We embed this font in source code so you can use Dear ImGui without any file system access. You may also load external .TTF/.OTF files. The files in this folder are suggested fonts, provided as a convenience. Please read FAQ Please use the Discord server: http://discord.dearimgui.org and not the Github issue tracker for basic font loading questions. Index \u00b6 Readme First / FAQ Fonts Loading Instructions Using Icons Using FreeType rasterizer Building Custom Glyph Ranges Using custom colorful icons Embedding Fonts in Source Code Credits/Licences for fonts included in repository Fonts Links Readme first \u00b6 You can use the Style editor ImGui::ShowStyleEditor() in the Fonts section to browse your fonts and understand what's going on if you have an issue. Fonts are rasterized in a single texture at the time of calling either of io.Fonts->GetTexDataAsAlpha8() / GetTexDataAsRGBA32() / Build() . Make sure your font ranges data are persistent and available at the time the font atlas is being built. Use C++11 u8\"my text\" syntax to encode literal strings as UTF-8. e.g.: ` u8 \"hello\" ` ` u8 \"\u3053\u3093\u306b\u3061\u306f\" ` // this will be encoded as UTF-8 If you want to include a backslash \\ character in your string literal, you need to double them e.g. \"folder\\\\filename\" . Read FAQ for details. Loading Fonts \u00b6 Load default font: ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontDefault (); Load .TTF/.OTF file with: ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels ); Load multiple fonts: ImGuiIO & io = ImGui :: GetIO (); ImFont * font1 = io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels ); ImFont * font2 = io . Fonts -> AddFontFromFileTTF ( \"anotherfont.otf\" , size_pixels ); // Select font at runtime ImGui :: Text ( \"Hello\" ); // use the default font (which is the first loaded font) ImGui :: PushFont ( font2 ); ImGui :: Text ( \"Hello with another font\" ); ImGui :: PopFont (); For advanced options create a ImFontConfig structure and pass it to the AddFont function (it will be copied internally): ImFontConfig config ; config . OversampleH = 2 ; config . OversampleV = 1 ; config . GlyphExtraSpacing . x = 1.0f ; ImFont * font = io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , & config ); Combine two fonts into one: // Load a first font ImFont * font = io . Fonts -> AddFontDefault (); // Add character ranges and merge into the previous font // The ranges array is not copied by the AddFont* functions and is used lazily // so ensure it is available at the time of building or calling GetTexDataAsRGBA32(). static const ImWchar icons_ranges [] = { 0xf000 , 0xf3ff , 0 }; // Will not be copied by AddFont* so keep in scope. ImFontConfig config ; config . MergeMode = true ; io . Fonts -> AddFontFromFileTTF ( \"DroidSans.ttf\" , 18.0f , & config , io . Fonts -> GetGlyphRangesJapanese ()); io . Fonts -> AddFontFromFileTTF ( \"fontawesome-webfont.ttf\" , 18.0f , & config , icons_ranges ); io . Fonts -> Build (); Font atlas is too large? \u00b6 If you have very large number of glyphs or multiple fonts, the texture may become too big for your graphics API. The typical result of failing to upload a texture is if every glyphs appears as white rectangles. In particular, using a large range such as GetGlyphRangesChineseSimplifiedCommon() is not recommended unless you set OversampleH / OversampleV to 1 and use a small font size. Mind the fact that some graphics drivers have texture size limitation. If you are building a PC application, mind the fact that users may run on hardware with lower specs than yours. Some solutions: \u00b6 Reduce glyphs ranges by calculating them from source localization data. You can use ImFontGlyphRangesBuilder for this purpose, this will be the biggest win! You may reduce oversampling, e.g. config.OversampleH = config.OversampleV = 1, this will largely reduce your texture size. Set io.Fonts.TexDesiredWidth to specify a texture width to minimize texture height (see comment in ImFontAtlas::Build function). Set io.Fonts.Flags |= ImFontAtlasFlags_NoPowerOfTwoHeight; to disable rounding the texture height to the next power of two. Read about oversampling here: https://github.com/nothings/stb/blob/master/tests/oversample Add a fourth parameter to bake specific font ranges only: // Basic Latin, Extended Latin io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , NULL , io . Fonts -> GetGlyphRangesDefault ()); // Default + Selection of 2500 Ideographs used by Simplified Chinese io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , NULL , io . Fonts -> GetGlyphRangesChineseSimplifiedCommon ()); // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , NULL , io . Fonts -> GetGlyphRangesJapanese ()); See \"BUILDING CUSTOM GLYPH RANGES\" section to create your own ranges . Offset font vertically by altering the io . Font -> DisplayOffset value : ImFont * font = io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels ); font -> DisplayOffset . y = 1 ; // Render 1 pixel down Using Icons \u00b6 Using an icon font (such as FontAwesome or OpenFontIcons is an easy and practical way to use icons in your Dear ImGui application. A common pattern is to merge the icon font within your main font, so you can embed icons directly from your strings without having to change fonts back and forth. To refer to the icon UTF-8 codepoints from your C++ code, you may use those headers files created by Juliette Foucaut: https://github.com/juliettef/IconFontCppHeaders Those files contains a bunch of named #define which you can use to refer to specific icons of the font, e.g.: #define ICON_FA_MUSIC \"\\xef\\x80\\x81\" #define ICON_FA_SEARCH \"\\xef\\x80\\x82\" Example Setup: // Merge icons into default tool font #include \"IconsFontAwesome.h\" ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontDefault (); ImFontConfig config ; config . MergeMode = true ; config . GlyphMinAdvanceX = 13.0f ; // Use if you want to make the icon monospaced static const ImWchar icon_ranges [] = { ICON_MIN_FA , ICON_MAX_FA , 0 }; io . Fonts -> AddFontFromFileTTF ( \"fonts/fontawesome-webfont.ttf\" , 13.0f , & config , icon_ranges ); Example Usage: // Usage, e.g. ImGui :: Text ( \"%s among %d items\" , ICON_FA_SEARCH , count ); ImGui :: Button ( ICON_FA_SEARCH \" Search\" ); Important to understand: C string literals can be concatenated at compilation time, e.g. \"hello\" \" world\" . ICON_FA_SEARCH is defined as a string literal so this is the same as \"A\"`` \"B\" becoming \"AB\" . See Links below for other icons fonts and related tools. Freetype Rasterizer and Small Font Sizes \u00b6 Dear ImGui uses imstb_truetype.h to rasterize fonts (with optional oversampling). This technique and its implementation are not ideal for fonts rendered at small sizes , which may appear a little blurry or hard to read. There is an implementation of the ImFontAtlas builder using FreeType that you can use in the misc/freetype/ folder. FreeType supports auto-hinting which tends to improve the readability of small fonts. Note that this code currently creates textures that are unoptimally too large (could be fixed with some work). Also note that correct sRGB space blending will have an important effect on your font rendering quality. Building Custom Glypth Ranges \u00b6 You can use the ImFontGlyphRangesBuilder helper to create glyph ranges based on text input. For example: for a game where your script is known, if you can feed your entire script to it and only build the characters the game needs. ImVector < ImWchar > ranges ; ImFontGlyphRangesBuilder builder ; builder . AddText ( \"Hello world\" ); // Add a string (here \"Hello world\" contains 7 unique characters) builder . AddChar ( 0x7262 ); // Add a specific character builder . AddRanges ( io . Fonts -> GetGlyphRangesJapanese ()); // Add one of the default ranges builder . BuildRanges ( & ranges ); // Build the final result (ordered ranges with all the unique characters submitted) io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels , NULL , ranges . Data ); io . Fonts -> Build (); // Build the atlas while 'ranges' is still in scope and not deleted. Using Custom Colorful Icons \u00b6 (This is a BETA api, use if you are familiar with dear imgui and with your rendering back-end) You can use the ImFontAtlas::AddCustomRect() and ImFontAtlas::AddCustomRectFontGlyph() api to register rectangles that will be packed into the font atlas texture. Register them before building the atlas, then call Build() . You can then use ImFontAtlas::GetCustomRectByIndex(int) to query the position/size of your rectangle within the texture, and blit/copy any graphics data of your choice into those rectangles. Pseudo-code: // Add font, then register two custom 13x13 rectangles mapped to glyph 'a' and 'b' of this font ImFont * font = io . Fonts -> AddFontDefault (); int rect_ids [ 2 ]; rect_ids [ 0 ] = io . Fonts -> AddCustomRectFontGlyph ( font , 'a' , 13 , 13 , 13 + 1 ); rect_ids [ 1 ] = io . Fonts -> AddCustomRectFontGlyph ( font , 'b' , 13 , 13 , 13 + 1 ); // Build atlas io . Fonts -> Build (); // Retrieve texture in RGBA format unsigned char * tex_pixels = NULL ; int tex_width , tex_height ; io . Fonts -> GetTexDataAsRGBA32 ( & tex_pixels , & tex_width , & tex_height ); for ( int rect_n = 0 ; rect_n < IM_ARRAYSIZE ( rect_ids ); rect_n ++ ) { int rect_id = rects_ids [ rect_n ]; if ( const ImFontAtlas :: CustomRect * rect = io . Fonts -> GetCustomRectByIndex ( rect_id )) { // Fill the custom rectangle with red pixels (in reality you would draw/copy your bitmap data here!) for ( int y = 0 ; y < rect -> Height ; y ++ ) { ImU32 * p = ( ImU32 * ) tex_pixels + ( rect -> Y + y ) * tex_width + ( rect -> X ); for ( int x = rect -> Width ; x > 0 ; x -- ) * p ++ = IM_COL32 ( 255 , 0 , 0 , 255 ); } } } Embedding Fonts in Source Code \u00b6 Compile and use binary_to_compressed_c.cpp to create a compressed C style array that you can embed in source code. See the documentation in binary_to_compressed_c.cpp for instruction on how to use the tool. You may find a precompiled version binary_to_compressed_c.exe for Windows instead of demo binaries package (see README). The tool can optionally output Base85 encoding to reduce the size of source code but the read-only arrays in the actual binary will be about 20% bigger. Then load the font with: ImFont * font = io . Fonts -> AddFontFromMemoryCompressedTTF ( compressed_data , compressed_data_size , size_pixels , ...); or : ImFont * font = io . Fonts -> AddFontFromMemoryCompressedBase85TTF ( compressed_data_base85 , size_pixels , ...); Credits / Licenses for Fonts included in Repository \u00b6 Some fonts are available in the misc/fonts/ folder: Roboto-Medium.ttf \u00b6 Apache License 2.0 by Christian Robertson https://fonts.google.com/specimen/Roboto \\ Cousine-Regular.ttf \u00b6 by Steve Matteson Digitized data copyright \u00a9 2010 Google Corporation. Licensed under the SIL Open Font License, Version 1.1 https://fonts.google.com/specimen/Cousine DroidSans.ttf \u00b6 Copyright \u00a9 Steve Matteson Apache License, version 2.0 https://www.fontsquirrel.com/fonts/droid-sans ProggyClean.ttf \u00b6 Copyright \u00a9 2004, 2005 Tristan Grimmer MIT License recommended loading setting: Size = 13.0, DisplayOffset.Y = +1 http://www.proggyfonts.net/ ProggyTiny.ttf \u00b6 Copyright \u00a9 2004, 2005 Tristan Grimmer MIT License recommended loading setting: Size = 10.0, DisplayOffset.Y = +1 http://www.proggyfonts.net/ Karla-Regular.ttf \u00b6 Copyright \u00a9 2012, Jonathan Pinhorn SIL OPEN FONT LICENSE Version 1.1 Font Links \u00b6 Icon Fonts \u00b6 C/C++ header for icon fonts (#define with code points to use in source code string literals) https://github.com/juliettef/IconFontCppHeaders FontAwesome https://fortawesome.github.io/Font-Awesome OpenFontIcons https://github.com/traverseda/OpenFontIcons Google Icon Fonts https://design.google.com/icons/ Kenney Icon Font (Game Controller Icons) https://github.com/nicodinh/kenney-icon-font IcoMoon - Custom Icon font builder https://icomoon.io/app Regular Fonts \u00b6 Google Noto Fonts (worldwide languages) https://www.google.com/get/noto/ Open Sans Fonts https://fonts.google.com/specimen/Open+Sans (Japanese) M+ fonts by Coji Morishita are free http://mplus-fonts.sourceforge.jp/mplus-outline-fonts/index-en.html MONOSPACE FONTS (PIXEL PERFECT) \u00b6 Proggy Fonts, by Tristan Grimmer http://www.proggyfonts.net or http://upperbounds.net Sweet16, Sweet16 Mono, by Martin Sedlak (Latin + Supplemental + Extended A) https://github.com/kmar/Sweet16Font Also include .inl file to use directly in dear imgui. MONOSPACE FONTS (REGULAR) \u00b6 Google Noto Mono Fonts https://www.google.com/get/noto/ Typefaces for source code beautification https://github.com/chrissimpkins/codeface Programmation fonts http://s9w.github.io/font_compare/ Inconsolata http://www.levien.com/type/myfonts/inconsolata.html Adobe Source Code Pro: Monospaced font family for user interface and coding environments https://github.com/adobe-fonts/source-code-pro Monospace/Fixed Width Programmer's Fonts http://www.lowing.org/fonts/ Or use Arial Unicode or other Unicode fonts provided with Windows for full characters coverage (not sure of their licensing).","title":"Fonts"},{"location":"FONTS/#fonts-documentation","text":"Also read https://www.dearimgui.org/faq for more fonts related infos. The code in imgui.cpp embeds a copy of ProggyClean.ttf (by Tristan Grimmer), a 13 pixels high, pixel-perfect font used by default. We embed this font in source code so you can use Dear ImGui without any file system access. You may also load external .TTF/.OTF files. The files in this folder are suggested fonts, provided as a convenience. Please read FAQ Please use the Discord server: http://discord.dearimgui.org and not the Github issue tracker for basic font loading questions.","title":"Fonts Documentation"},{"location":"FONTS/#index","text":"Readme First / FAQ Fonts Loading Instructions Using Icons Using FreeType rasterizer Building Custom Glyph Ranges Using custom colorful icons Embedding Fonts in Source Code Credits/Licences for fonts included in repository Fonts Links","title":"Index"},{"location":"FONTS/#readme-first","text":"You can use the Style editor ImGui::ShowStyleEditor() in the Fonts section to browse your fonts and understand what's going on if you have an issue. Fonts are rasterized in a single texture at the time of calling either of io.Fonts->GetTexDataAsAlpha8() / GetTexDataAsRGBA32() / Build() . Make sure your font ranges data are persistent and available at the time the font atlas is being built. Use C++11 u8\"my text\" syntax to encode literal strings as UTF-8. e.g.: ` u8 \"hello\" ` ` u8 \"\u3053\u3093\u306b\u3061\u306f\" ` // this will be encoded as UTF-8 If you want to include a backslash \\ character in your string literal, you need to double them e.g. \"folder\\\\filename\" . Read FAQ for details.","title":"Readme first"},{"location":"FONTS/#loading-fonts","text":"Load default font: ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontDefault (); Load .TTF/.OTF file with: ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels ); Load multiple fonts: ImGuiIO & io = ImGui :: GetIO (); ImFont * font1 = io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels ); ImFont * font2 = io . Fonts -> AddFontFromFileTTF ( \"anotherfont.otf\" , size_pixels ); // Select font at runtime ImGui :: Text ( \"Hello\" ); // use the default font (which is the first loaded font) ImGui :: PushFont ( font2 ); ImGui :: Text ( \"Hello with another font\" ); ImGui :: PopFont (); For advanced options create a ImFontConfig structure and pass it to the AddFont function (it will be copied internally): ImFontConfig config ; config . OversampleH = 2 ; config . OversampleV = 1 ; config . GlyphExtraSpacing . x = 1.0f ; ImFont * font = io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , & config ); Combine two fonts into one: // Load a first font ImFont * font = io . Fonts -> AddFontDefault (); // Add character ranges and merge into the previous font // The ranges array is not copied by the AddFont* functions and is used lazily // so ensure it is available at the time of building or calling GetTexDataAsRGBA32(). static const ImWchar icons_ranges [] = { 0xf000 , 0xf3ff , 0 }; // Will not be copied by AddFont* so keep in scope. ImFontConfig config ; config . MergeMode = true ; io . Fonts -> AddFontFromFileTTF ( \"DroidSans.ttf\" , 18.0f , & config , io . Fonts -> GetGlyphRangesJapanese ()); io . Fonts -> AddFontFromFileTTF ( \"fontawesome-webfont.ttf\" , 18.0f , & config , icons_ranges ); io . Fonts -> Build ();","title":"Loading Fonts"},{"location":"FONTS/#font-atlas-is-too-large","text":"If you have very large number of glyphs or multiple fonts, the texture may become too big for your graphics API. The typical result of failing to upload a texture is if every glyphs appears as white rectangles. In particular, using a large range such as GetGlyphRangesChineseSimplifiedCommon() is not recommended unless you set OversampleH / OversampleV to 1 and use a small font size. Mind the fact that some graphics drivers have texture size limitation. If you are building a PC application, mind the fact that users may run on hardware with lower specs than yours.","title":"Font atlas is too large?"},{"location":"FONTS/#some-solutions","text":"Reduce glyphs ranges by calculating them from source localization data. You can use ImFontGlyphRangesBuilder for this purpose, this will be the biggest win! You may reduce oversampling, e.g. config.OversampleH = config.OversampleV = 1, this will largely reduce your texture size. Set io.Fonts.TexDesiredWidth to specify a texture width to minimize texture height (see comment in ImFontAtlas::Build function). Set io.Fonts.Flags |= ImFontAtlasFlags_NoPowerOfTwoHeight; to disable rounding the texture height to the next power of two. Read about oversampling here: https://github.com/nothings/stb/blob/master/tests/oversample Add a fourth parameter to bake specific font ranges only: // Basic Latin, Extended Latin io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , NULL , io . Fonts -> GetGlyphRangesDefault ()); // Default + Selection of 2500 Ideographs used by Simplified Chinese io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , NULL , io . Fonts -> GetGlyphRangesChineseSimplifiedCommon ()); // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels , NULL , io . Fonts -> GetGlyphRangesJapanese ()); See \"BUILDING CUSTOM GLYPH RANGES\" section to create your own ranges . Offset font vertically by altering the io . Font -> DisplayOffset value : ImFont * font = io . Fonts -> AddFontFromFileTTF ( \"font.ttf\" , size_pixels ); font -> DisplayOffset . y = 1 ; // Render 1 pixel down","title":"Some solutions:"},{"location":"FONTS/#using-icons","text":"Using an icon font (such as FontAwesome or OpenFontIcons is an easy and practical way to use icons in your Dear ImGui application. A common pattern is to merge the icon font within your main font, so you can embed icons directly from your strings without having to change fonts back and forth. To refer to the icon UTF-8 codepoints from your C++ code, you may use those headers files created by Juliette Foucaut: https://github.com/juliettef/IconFontCppHeaders Those files contains a bunch of named #define which you can use to refer to specific icons of the font, e.g.: #define ICON_FA_MUSIC \"\\xef\\x80\\x81\" #define ICON_FA_SEARCH \"\\xef\\x80\\x82\" Example Setup: // Merge icons into default tool font #include \"IconsFontAwesome.h\" ImGuiIO & io = ImGui :: GetIO (); io . Fonts -> AddFontDefault (); ImFontConfig config ; config . MergeMode = true ; config . GlyphMinAdvanceX = 13.0f ; // Use if you want to make the icon monospaced static const ImWchar icon_ranges [] = { ICON_MIN_FA , ICON_MAX_FA , 0 }; io . Fonts -> AddFontFromFileTTF ( \"fonts/fontawesome-webfont.ttf\" , 13.0f , & config , icon_ranges ); Example Usage: // Usage, e.g. ImGui :: Text ( \"%s among %d items\" , ICON_FA_SEARCH , count ); ImGui :: Button ( ICON_FA_SEARCH \" Search\" ); Important to understand: C string literals can be concatenated at compilation time, e.g. \"hello\" \" world\" . ICON_FA_SEARCH is defined as a string literal so this is the same as \"A\"`` \"B\" becoming \"AB\" . See Links below for other icons fonts and related tools.","title":"Using Icons"},{"location":"FONTS/#freetype-rasterizer-and-small-font-sizes","text":"Dear ImGui uses imstb_truetype.h to rasterize fonts (with optional oversampling). This technique and its implementation are not ideal for fonts rendered at small sizes , which may appear a little blurry or hard to read. There is an implementation of the ImFontAtlas builder using FreeType that you can use in the misc/freetype/ folder. FreeType supports auto-hinting which tends to improve the readability of small fonts. Note that this code currently creates textures that are unoptimally too large (could be fixed with some work). Also note that correct sRGB space blending will have an important effect on your font rendering quality.","title":"Freetype Rasterizer and Small Font Sizes"},{"location":"FONTS/#building-custom-glypth-ranges","text":"You can use the ImFontGlyphRangesBuilder helper to create glyph ranges based on text input. For example: for a game where your script is known, if you can feed your entire script to it and only build the characters the game needs. ImVector < ImWchar > ranges ; ImFontGlyphRangesBuilder builder ; builder . AddText ( \"Hello world\" ); // Add a string (here \"Hello world\" contains 7 unique characters) builder . AddChar ( 0x7262 ); // Add a specific character builder . AddRanges ( io . Fonts -> GetGlyphRangesJapanese ()); // Add one of the default ranges builder . BuildRanges ( & ranges ); // Build the final result (ordered ranges with all the unique characters submitted) io . Fonts -> AddFontFromFileTTF ( \"myfontfile.ttf\" , size_in_pixels , NULL , ranges . Data ); io . Fonts -> Build (); // Build the atlas while 'ranges' is still in scope and not deleted.","title":"Building Custom Glypth Ranges"},{"location":"FONTS/#using-custom-colorful-icons","text":"(This is a BETA api, use if you are familiar with dear imgui and with your rendering back-end) You can use the ImFontAtlas::AddCustomRect() and ImFontAtlas::AddCustomRectFontGlyph() api to register rectangles that will be packed into the font atlas texture. Register them before building the atlas, then call Build() . You can then use ImFontAtlas::GetCustomRectByIndex(int) to query the position/size of your rectangle within the texture, and blit/copy any graphics data of your choice into those rectangles. Pseudo-code: // Add font, then register two custom 13x13 rectangles mapped to glyph 'a' and 'b' of this font ImFont * font = io . Fonts -> AddFontDefault (); int rect_ids [ 2 ]; rect_ids [ 0 ] = io . Fonts -> AddCustomRectFontGlyph ( font , 'a' , 13 , 13 , 13 + 1 ); rect_ids [ 1 ] = io . Fonts -> AddCustomRectFontGlyph ( font , 'b' , 13 , 13 , 13 + 1 ); // Build atlas io . Fonts -> Build (); // Retrieve texture in RGBA format unsigned char * tex_pixels = NULL ; int tex_width , tex_height ; io . Fonts -> GetTexDataAsRGBA32 ( & tex_pixels , & tex_width , & tex_height ); for ( int rect_n = 0 ; rect_n < IM_ARRAYSIZE ( rect_ids ); rect_n ++ ) { int rect_id = rects_ids [ rect_n ]; if ( const ImFontAtlas :: CustomRect * rect = io . Fonts -> GetCustomRectByIndex ( rect_id )) { // Fill the custom rectangle with red pixels (in reality you would draw/copy your bitmap data here!) for ( int y = 0 ; y < rect -> Height ; y ++ ) { ImU32 * p = ( ImU32 * ) tex_pixels + ( rect -> Y + y ) * tex_width + ( rect -> X ); for ( int x = rect -> Width ; x > 0 ; x -- ) * p ++ = IM_COL32 ( 255 , 0 , 0 , 255 ); } } }","title":"Using Custom Colorful Icons"},{"location":"FONTS/#embedding-fonts-in-source-code","text":"Compile and use binary_to_compressed_c.cpp to create a compressed C style array that you can embed in source code. See the documentation in binary_to_compressed_c.cpp for instruction on how to use the tool. You may find a precompiled version binary_to_compressed_c.exe for Windows instead of demo binaries package (see README). The tool can optionally output Base85 encoding to reduce the size of source code but the read-only arrays in the actual binary will be about 20% bigger. Then load the font with: ImFont * font = io . Fonts -> AddFontFromMemoryCompressedTTF ( compressed_data , compressed_data_size , size_pixels , ...); or : ImFont * font = io . Fonts -> AddFontFromMemoryCompressedBase85TTF ( compressed_data_base85 , size_pixels , ...);","title":"Embedding Fonts in Source Code"},{"location":"FONTS/#credits-licenses-for-fonts-included-in-repository","text":"Some fonts are available in the misc/fonts/ folder:","title":"Credits / Licenses for Fonts included in Repository"},{"location":"FONTS/#roboto-mediumttf","text":"Apache License 2.0 by Christian Robertson https://fonts.google.com/specimen/Roboto \\","title":"Roboto-Medium.ttf"},{"location":"FONTS/#cousine-regularttf","text":"by Steve Matteson Digitized data copyright \u00a9 2010 Google Corporation. Licensed under the SIL Open Font License, Version 1.1 https://fonts.google.com/specimen/Cousine","title":"Cousine-Regular.ttf"},{"location":"FONTS/#droidsansttf","text":"Copyright \u00a9 Steve Matteson Apache License, version 2.0 https://www.fontsquirrel.com/fonts/droid-sans","title":"DroidSans.ttf"},{"location":"FONTS/#proggycleanttf","text":"Copyright \u00a9 2004, 2005 Tristan Grimmer MIT License recommended loading setting: Size = 13.0, DisplayOffset.Y = +1 http://www.proggyfonts.net/","title":"ProggyClean.ttf"},{"location":"FONTS/#proggytinyttf","text":"Copyright \u00a9 2004, 2005 Tristan Grimmer MIT License recommended loading setting: Size = 10.0, DisplayOffset.Y = +1 http://www.proggyfonts.net/","title":"ProggyTiny.ttf"},{"location":"FONTS/#karla-regularttf","text":"Copyright \u00a9 2012, Jonathan Pinhorn SIL OPEN FONT LICENSE Version 1.1","title":"Karla-Regular.ttf"},{"location":"FONTS/#font-links","text":"","title":"Font Links"},{"location":"FONTS/#icon-fonts","text":"C/C++ header for icon fonts (#define with code points to use in source code string literals) https://github.com/juliettef/IconFontCppHeaders FontAwesome https://fortawesome.github.io/Font-Awesome OpenFontIcons https://github.com/traverseda/OpenFontIcons Google Icon Fonts https://design.google.com/icons/ Kenney Icon Font (Game Controller Icons) https://github.com/nicodinh/kenney-icon-font IcoMoon - Custom Icon font builder https://icomoon.io/app","title":"Icon Fonts"},{"location":"FONTS/#regular-fonts","text":"Google Noto Fonts (worldwide languages) https://www.google.com/get/noto/ Open Sans Fonts https://fonts.google.com/specimen/Open+Sans (Japanese) M+ fonts by Coji Morishita are free http://mplus-fonts.sourceforge.jp/mplus-outline-fonts/index-en.html","title":"Regular Fonts"},{"location":"FONTS/#monospace-fonts-pixel-perfect","text":"Proggy Fonts, by Tristan Grimmer http://www.proggyfonts.net or http://upperbounds.net Sweet16, Sweet16 Mono, by Martin Sedlak (Latin + Supplemental + Extended A) https://github.com/kmar/Sweet16Font Also include .inl file to use directly in dear imgui.","title":"MONOSPACE FONTS (PIXEL PERFECT)"},{"location":"FONTS/#monospace-fonts-regular","text":"Google Noto Mono Fonts https://www.google.com/get/noto/ Typefaces for source code beautification https://github.com/chrissimpkins/codeface Programmation fonts http://s9w.github.io/font_compare/ Inconsolata http://www.levien.com/type/myfonts/inconsolata.html Adobe Source Code Pro: Monospaced font family for user interface and coding environments https://github.com/adobe-fonts/source-code-pro Monospace/Fixed Width Programmer's Fonts http://www.lowing.org/fonts/ Or use Arial Unicode or other Unicode fonts provided with Windows for full characters coverage (not sure of their licensing).","title":"MONOSPACE FONTS (REGULAR)"},{"location":"TODO/","text":"dear imgui ISSUES & TODO LIST Issue numbers (#) refer to github issues listed at https://github.com/ocornut/imgui/issues/XXXX The list below consist mostly of ideas noted down before they are requested/discussed by users (at which point they usually exist on the github issue tracker). It's mostly a bunch of personal notes, probably incomplete. Feel free to query if you have any questions. doc/test: add a proper documentation+regression testing system ( #435 ) doc/test: checklist app to verify binding/integration of imgui (test inputs, rendering, callback, etc.). doc/tips: tips of the day: website? applet in imgui_club? doc/wiki: work on the wiki https://github.com/ocornut/imgui/wiki window: preserve/restore relative focus ordering (persistent or not) ( #2304 ) -> also see docking reference to same #. window: calling SetNextWindowSize() every frame with <= 0 doesn't do anything, may be useful to allow (particularly when used for a single axis). ( #690 ) window: add a way for very transient windows (non-saved, temporary overlay over hundreds of objects) to \"clean\" up from the global window list. perhaps a lightweight explicit cleanup pass. window: auto-fit feedback loop when user relies on any dynamic layout (window width multiplier, column) appears weird to end-user. clarify. window: begin with *p_open == false could return false. window: get size/pos helpers given names (see discussion in #249 ) window: a collapsed window can be stuck behind the main menu bar? window: when window is very small, prioritize resize button over close button. window: detect extra End() call that pop the \"Debug\" window out and assert at End() call site instead of at end of frame. window: increase minimum size of a window with menus or fix the menu rendering so that it doesn't look odd. window: double-clicking on title bar to minimize isn't consistent, perhaps move to single-click on left-most collapse icon? window: expose contents size. ( #1045 ) window: using SetWindowPos() inside Begin() and moving the window with the mouse reacts a very ugly glitch. We should just defer the SetWindowPos() call. window: GetWindowSize() returns (0,0) when not calculated? ( #1045 ) window: investigate better auto-positioning for new windows. window: top most window flag? ( #2574 ) window/size: manually triggered auto-fit (double-click on grip) shouldn't resize window down to viewport size? window/opt: freeze window flag: if not focused/hovered, return false, render with previous ImDrawList. and/or reduce refresh rate. -> this may require enforcing that it is illegal to submit contents if Begin returns false. window/child: background options for child windows, border option (disable rounding). window/child: allow resizing of child windows (possibly given min/max for each axis?.) window/child: the first draw command of a child window could be moved into the current draw command of the parent window (unless child+tooltip?). window/child: border could be emitted in parent as well. window/child: allow SetNextWindowContentSize() to work on child windows. window/clipping: some form of clipping when DisplaySize (or corresponding viewport) is zero. window/tab: add a way to signify that a window or docked window requires attention (e.g. blinking title bar). ! scrolling: exposing horizontal scrolling with Shift+Wheel even when scrollbar is disabled expose lots of issues ( #2424 , #1463 ) scrolling: while holding down a scrollbar, try to keep the same contents visible (at least while not moving mouse) scrolling: allow immediately effective change of scroll after Begin() if we haven't appended items yet. scrolling: forward mouse wheel scrolling to parent window when at the edge of scrolling limits? (useful for listbox,tables?) scrolling/clipping: separator on the initial position of a window is not visible (cursorpos.y <= clippos.y). (2017-08-20: can't repro) scrolling/style: shadows on scrollable areas to denote that there is more contents (see e.g. DaVinci Resolve ui) drawdata: make it easy to clone (or swap?) a full ImDrawData so user can easily save that data if they use threaded rendering. (e.g. #2646 ) ! drawlist: add calctextsize func to facilitate consistent code from user pov (currently need to use ImGui or ImFont alternatives!) drawlist: end-user probably can't call Clear() directly because we expect a texture to be pushed in the stack. drawlist: maintaining bounding box per command would allow to merge draw command when clipping isn't relied on (typical non-scrolling window or non-overflowing column would merge with previous command). drawlist: primitives/helpers to manipulate vertices post submission, so e.g. a quad/rect can be resized to fit later submitted content, without using the ChannelSplit api drawlist: make it easier to toggle AA per primitive, so we can use e.g. non-AA fill + AA borders more naturally drawlist: non-AA strokes have gaps between points ( #593 , #288 ), glitch especially on RenderCheckmark() and ColorPicker4(). drawlist: would be good to be able to deep copy of ImDrawData (we have a deep copy of ImDrawList now). drawlist: rendering: provide a way for imgui to output to a single/global vertex buffer, re-order indices only at the end of the frame (ref: https://gist.github.com/floooh/10388a0afbe08fce9e617d8aefa7d302 ) drawlist: callback: add an extra void* in ImDrawCallback to allow passing render-local data to the callback (would break API). drawlist: AddRect vs AddLine position confusing ( #2441 ) drawlist: channel splitter should be external helper and not stored in ImDrawList. drawlist/opt: store rounded corners in texture to use 1 quad per corner (filled and wireframe) to lower the cost of rounding. ( #1962 ) drawlist/opt: AddRect() axis aligned pixel aligned (no-aa) could use 8 triangles instead of 16 and no normal calculation. drawlist/opt: thick AA line could be doable in same number of triangles as 1.0 AA line by storing gradient+full color in atlas. main: find a way to preserve relative orders of multiple reappearing windows (so an app toggling between \"modes\" e.g. fullscreen vs all tools) won't lose relative ordering. main: IsItemHovered() make it more consistent for various type of widgets, widgets with multiple components, etc. also effectively IsHovered() region sometimes differs from hot region, e.g tree nodes main: IsItemHovered() info stored in a stack? so that 'if TreeNode() { Text; TreePop; } if IsHovered' return the hover state of the TreeNode? widgets: display mode: widget-label, label-widget (aligned on column or using fixed size), label-newline-tab-widget etc. ( #395 ) widgets: clean up widgets internal toward exposing everything and stabilizing imgui_internals.h. widgets: add visuals for Disabled/ReadOnly mode and expose publicly ( #211 ) widgets: add always-allow-overlap mode. This should perhaps be the default? one problem is that highlight after mouse-wheel scrolling gets deferred, makes scrolling more flickery. widgets: start exposing PushItemFlag() and ImGuiItemFlags widgets: alignment options in style (e.g. center Selectable, Right-Align within Button, etc.) #1260 widgets: activate by identifier (trigger button, focus given id) widgets: a way to represent \"mixed\" values, so e.g. all values replaced with *, including check-boxes, colors, etc. with support for multi-components widgets (e.g. SliderFloat3, make only \"Y\" mixed) ( #2644 ) widgets: checkbox: checkbox with custom glyph inside frame. widgets: coloredit: keep reporting as active when picker is on? widgets: group/scalarn functions: expose more per-component information. e.g. store NextItemData.ComponentIdx set by scalarn function, groups can expose them back somehow. selectable: using (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f) followed by SameLine() is currently not supported. selectable: generic BeginSelectable()/EndSelectable() mechanism. selectable: a way to visualize partial/mixed selection (e.g. parent tree node has children with mixed selection) input text: clean up the mess caused by converting UTF-8 <> wchar. the code is rather inefficient right now and super fragile. input text: reorganize event handling, allow CharFilter to modify buffers, allow multiple events? ( #541 ) input text: expose CursorPos in char filter event ( #816 ) input text: try usage idiom of using InputText with data only exposed through get/set accessors, without extraneous copy/alloc. ( #3009 ) input text: access public fields via a non-callback API e.g. InputTextGetState(\"xxx\") that may return NULL if not active. input text: flag to disable live update of the user buffer (also applies to float/int text input) ( #701 ) input text: hover tooltip could show unclamped text input text: option to Tab after an Enter validation. input text: add ImGuiInputTextFlags_EnterToApply? (off #218 ) input text: easier ways to update buffer (from source char*) while owned. preserve some sort of cursor position for multi-line text. input text: add flag (e.g. ImGuiInputTextFlags_EscapeClearsBuffer) to clear instead of revert. what to do with focus? (also see #2890 ) input text: add discard flag (e.g. ImGuiInputTextFlags_DiscardActiveBuffer) or make it easier to clear active focus for text replacement during edition ( #725 ) input text: display bug when clicking a drag/slider after an input text in a different window has all-selected text (order dependent). actually a very old bug but no one appears to have noticed it. input text: allow centering/positioning text so that ctrl+clicking Drag or Slider keeps the textual value at the same pixel position. input text: decorrelate layout from inputs - e.g. what's the easiest way to implement a nice IP/Mac address input editor? input text: global callback system so user can plug in an expression evaluator easily. ( #1691 ) input text: force scroll to end or scroll to a given line/contents (so user can implement a log or a search feature) input text: a way to preview completion (e.g. disabled text completing from the cursor) input text: a side bar that could e.g. preview where errors are. probably left to the user to draw but we'd need to give them the info there. input text: a way for the user to provide syntax coloring. input text: Shift+TAB with ImGuiInputTextFlags_AllowTabInput could eat preceding blanks, up to tab_count. input text: facilitate patterns like if (InputText(..., obj.get_string_ref()) { obj.set_string(...); } relying on internally held buffer. input text multi-line: don't directly call AddText() which does an unnecessary vertex reserve for character count prior to clipping. and/or more line-based clipping to AddText(). and/or reorganize TextUnformatted/RenderText for more efficiency for large text (e.g TextUnformatted could clip and log separately, etc). input text multi-line: support for cut/paste without selection (cut/paste the current line) input text multi-line: line numbers? status bar? (follow up on #200 ) input text multi-line: behave better when user changes input buffer while editing is active (even though it is illegal behavior). namely, the change of buffer can create a scrollbar glitch ( #725 ) input text multi-line: better horizontal scrolling support ( #383 , #1224 ) input text multi-line: single call to AddText() should be coarse clipped on InputTextEx() end. input number: optional range min/max for Input*() functions input number: holding [-]/[+] buttons could increase the step speed non-linearly (or user-controlled) input number: use mouse wheel to step up/down input number: applying arithmetics ops (+,-,*,/) messes up with text edit undo stack. layout: helper or a way to express ImGui::SameLine(ImGui::GetCursorStartPos().x + ImGui::CalcItemWidth() + ImGui::GetStyle().ItemInnerSpacing.x); in a simpler manner. layout: generalization of the above: a concept equivalent to word processor ruler tab stop ~ mini columns (position in X, no clipping implied) (vaguely relate to #267 , #395 , also what is used internally for menu items) layout: horizontal layout helper ( #97 ) layout: horizontal flow until no space left ( #404 ) layout: more generic alignment state (left/right/centered) for single items? layout: clean up the InputFloatN/SliderFloatN/ColorEdit4 layout code. item width should include frame padding. layout: vertical alignment of mixed height items (e.g. buttons) within a same line ( #1284 ) layout: null layout mode were items are not rendered but user can query GetItemRectMin()/Max/Size. layout: (R&D) local multi-pass layout mode. layout: (R&D) bind authored layout data (created by an off-line tool), items fetch their pos/size at submission, self-optimize data structures to stable linear access. group: BeginGroup() needs a border option. (~ #1496 ) group: IsHovered() after EndGroup() covers whole aabb rather than the intersection of individual items. Is that desirable? group: merge deactivation/activation within same group (fwd WasEdited flag). ( #2550 ) columns: sizing policy (e.g. for each column: fixed size, %, fill, distribute default size among fills) ( #513 , #125 ) columns: add a conditional parameter to SetColumnOffset() ( #513 , #125 ) columns: headers. re-orderable. ( #513 , #125 ) columns: optional sorting modifiers (up/down), sort list so sorting can be done multi-criteria. notify user when sort order changed. columns: option to alternate background colors on odd/even scanlines. columns: allow columns to recurse. columns: allow a same columns set to be interrupted by e.g. CollapsingHeader and resume with columns in sync when moving them. columns: sizing is lossy when columns width is very small (default width may turn negative etc.) columns: separator function or parameter that works within the column (currently Separator() bypass all columns) ( #125 ) columns: flag to add horizontal separator above/below? columns/layout: setup minimum line height (equivalent of automatically calling AlignFirstTextHeightToWidgets) !- color: the color conversion helpers/types are a mess and needs sorting out. - color: (api breaking) ImGui::ColorConvertXXX functions should be loose ImColorConvertXX to match imgui_internals.h plot: full featured plot/graph api w/ scrolling, zooming etc. all bell & whistle. why not! plot: PlotLines() should use the polygon-stroke facilities, less vertices (currently issues with averaging normals) plot: make it easier for user to draw extra stuff into the graph (e.g: draw basis, highlight certain points, 2d plots, multiple plots) plot: \"smooth\" automatic scale over time, user give an input 0.0(full user scale) 1.0(full derived from value) plot: option/feature: draw the zero line plot: option/feature: draw grid, vertical markers plot: option/feature: draw unit plot: add a helper e.g. Plot(char* label, float value, float time_span=2.0f) that stores values and Plot them for you - probably another function name. and/or automatically allow to plot ANY displayed value (more reliance on stable ID) clipper: ability to force display 1 item in the list would be convenient (for patterns where we need to set active id etc.) clipper: ability to disable the clipping through a simple flag/bool. clipper: ability to run without knowing full count in advance. clipper: horizontal clipping support. ( #2580 ) separator: expose flags ( #759 ) separator: width, thickness, centering ( #1643 ) splitter: formalize the splitter idiom into an official api (we want to handle n-way split) ( #319 ) dock: merge docking branch ( #2109 ) dock: dock out from a collapsing header? would work nicely but need emitting window to keep submitting the code. tabs: make EndTabBar fail if users doesn't respect BeginTabBar return value, for consistency/future-proofing. tabs: persistent order/focus in BeginTabBar() api ( #261 , #351 ) tabs: TabItem could honor SetNextItemWidth()? tabs: explicit api (even if internal) to cleanly manipulate tab order. tabs: Mouse wheel over tab bar could scroll? ( #2702 ) image/image button: misalignment on padded/bordered button? image/image button: parameters are confusing, image() has tint_col,border_col whereas imagebutton() has bg_col/tint_col. Even thou they are different parameters ordering could be more consistent. can we fix that? image button: not taking an explicit id can be problematic. ( #2464 , #1390 ) button: provide a button that looks framed. (?) slider/drag: ctrl+click when format doesn't include a % character.. disable? display underlying value in default format? (see TempInputTextScalar) slider: allow using the [-]/[+] buttons used by InputFloat()/InputInt() slider: initial absolute click is imprecise. change to relative movement slider (same as scrollbar). ( #1946 ) slider: add dragging-based widgets to edit values with mouse (on 2 axises), saving screen real-estate. slider: tint background based on value (e.g. v_min -> v_max, or use 0.0f either side of the sign) slider: relative dragging? + precision dragging slider: step option ( #1183 ) slider style: fill % of the bar instead of positioning a drag. knob: rotating knob widget ( #942 ) drag float: power/logarithmic slider and drags are weird. ( #1316 ) drag float: up/down axis drag float: power != 0.0f with current value being outside the range keeps the value stuck. drag float: added leeway on edge (e.g. a few invisible steps past the clamp limits) combo: use clipper: make it easier to disable clipper with a single flag. combo: flag for BeginCombo to not return true when unchanged ( #1182 ) combo: a way/helper to customize the combo preview ( #1658 ) combo/listbox: keyboard control. need InputText-like non-active focus + key handling. considering keyboard for custom listbox (pr #203 ) listbox: refactor and clean the begin/end api listbox: multiple selection. listbox: unselect option ( #1208 ) listbox: make it easier/more natural to implement range-select (need some sort of info/ref about the last clicked/focused item that user can translate to an index?) (wip stash) listbox: user may want to initial scroll to focus on the one selected value? listbox: expose hovered item for a basic ListBox listbox: keyboard navigation. listbox: disable capturing mouse wheel if the listbox has no scrolling. ( #1681 ) listbox: scrolling should track modified selection. listbox: future api should allow to enable horizontal scrolling ( #2510 ) !- popups/menus: clarify usage of popups id, how MenuItem/Selectable closing parent popups affects the ID, etc. this is quite fishy needs improvement! ( #331 , #402 ) - popups/modal: make modal title bar blink when trying to click outside the modal - popups: reopening context menu at new position should be the behavior by default? (equivalent to internal OpenPopupEx() with reopen_existing=true) (~ #1497 ) - popups: if the popup functions took explicit ImGuiID it would allow the user to manage the scope of those ID. ( #331 ) - popups: clicking outside (to close popup) and holding shouldn't drag window below. - popups: add variant using global identifier similar to Begin/End ( #402 ) - popups: border options. richer api like BeginChild() perhaps? ( #197 ) tooltip: drag and drop with tooltip near monitor edges lose/changes its last direction instead of locking one. The drag and drop tooltip should always follow without changing direction. tooltip: tooltip that doesn't fit in entire screen seems to lose their \"last preferred direction\" and may teleport when moving mouse. tooltip: allow to set the width of a tooltip to allow TextWrapped() etc. while keeping the height automatic. tooltip: tooltips with delay timers? or general timer policy? (instantaneous vs timed): IsItemHovered() with timer + implicit aabb-id for items with no ID. ( #1485 ) tooltip: drag tooltip hovering over source widget with IsItemHovered/SetTooltip flickers. menus: menu bars inside modal windows are acting weird. status-bar: add a per-window status bar helper similar to what menu-bar does. shortcuts: local-style shortcut api, e.g. parse \"&Save\" shortcuts,menus: global-style shortcut api e.g. \"Save (CTRL+S)\" -> explicit flag for recursing into closed menu shortcuts: programmatically access shortcuts \"Focus(\"&Save\")) menus: menu-bar: main menu-bar could affect clamping of windows position (~ akin to modifying DisplayMin) menus: hovering from menu to menu on a menu-bar has 1 frame without any menu, which is a little annoying. ideally either 0 either longer. menus: could merge draw call in most cases (how about storing an optional aabb in ImDrawCmd to move the burden of merging in a single spot). menus: would be nice if the Selectable() supported horizontal alignment (must be given the equivalent of WorkRect.Max.x matching the position of the shortcut column) tree node: add treenode/treepush int variants? not there because (void*) cast from int warns on some platforms/settings? tree node: try to apply scrolling at time of TreePop() if node was just opened and end of node is past scrolling limits? tree node / selectable render mismatch which is visible if you use them both next to each other (e.g. cf. property viewer) tree node: tweak color scheme to distinguish headers from selected tree node ( #581 ) tree node: leaf/non-leaf highlight mismatch. tree node/opt: could avoid formatting when clipped (flag assuming we don't care about width/height, assume single line height?) settings: write more decent code to allow saving/loading new fields: columns, selected tree nodes? settings: api for per-tool simple persistent data (bool,int,float,columns sizes,etc.) in .ini file ( #437 ) settings/persistence: helpers to make TreeNodeBehavior persist (even during dev!) - may need to store some semantic and/or data type in ImGuiStoragePair style: better default styles. ( #707 ) style: add a highlighted text color (for headers, etc.) style: border types: out-screen, in-screen, etc. ( #447 ) style: add window shadow (fading away from the window. Paint-style calculation of vertices alpha after drawlist would be easier) style: a concept of \"compact style\" that the end-user can easily rely on (e.g. PushStyleCompact()?) that maps to other settings? avoid implementing duplicate helpers such as SmallCheckbox(), etc. style: try to make PushStyleVar() more robust to incorrect parameters (to be more friendly to edit & continues situation). style: global scale setting. style: FramePadding could be different for up vs down ( #584 ) style: WindowPadding needs to be EVEN as the 0.5 multiplier used on this value probably have a subtle effect on clip rectangle style: have a more global HSV setter (e.g. alter hue on all elements). consider replacing active/hovered by offset in HSV space? ( #438 , #707 , #1223 ) style: gradients fill ( #1223 ) ~ 2 bg colors for each fill? tricky with rounded shapes and using textures for corners. style editor: color child window height expressed in multiple of line height. log: have more control over the log scope (e.g. stop logging when leaving current tree node scope) log: be able to log anything (e.g. right-click on a window/tree-node, shows context menu? log into tty/file/clipboard) log: let user copy any window content to clipboard easily (CTRL+C on windows? while moving it? context menu?). code is commented because it fails with multiple Begin/End pairs. log: obsolete LogButtons() all together. log: LogButtons() options for specifying depth and/or hiding depth slider log: enabling log ends up pushing and growing vertices buffersbecause we don't distinguish layout vs render clipping filters: set a current filter that tree node can automatically query to hide themselves filters: handle wild-cards (with implicit leading/trailing *), reg-exprs filters: fuzzy matches (may use code at blog.forrestthewoods.com/4cffeed33fdb) drag and drop: fix/support/options for overlapping drag sources. drag and drop: releasing a drop shows the \"...\" tooltip for one frame - since e13e598 ( #1725 ) drag and drop: drag source on a group object (would need e.g. an invisible button covering group in EndGroup) https://twitter.com/paniq/status/1121446364909535233 drag and drop: have some way to know when a drag begin from BeginDragDropSource() pov. (see 2018/01/11 post in #143 ) drag and drop: allow preview tooltip to be submitted from a different place than the drag source. ( #1725 ) drag and drop: allow using with other mouse buttons (where activeid won't be set). ( #1637 ) drag and drop: make it easier and provide a demo to have tooltip both are source and target site, with a more detailed one on target site (tooltip ordering problem) drag and drop: demo with reordering nodes (in a list, or a tree node). ( #143 ) drag and drop: test integrating with os drag and drop (make it easy to do a naive WM_DROPFILE integration) drag and drop: allow for multiple payload types. ( #143 ) drag and drop: make payload optional? payload promise? (see 2018/01/11 post in #143 ) drag and drop: ( #143 ) \"both an in-process pointer and a promise to generate a serialized version, for whether the drag ends inside or outside the same process\" drag and drop: feedback when hovering a region blocked by modal (mouse cursor \"NO\"?) node/graph editors ( #306 ) (also see https://github.com/ocornut/imgui/wiki#node-editors ) pie menus patterns ( #434 ) markup: simple markup language for color change? ( #902 ) text: selectable text (for copy) as a generic feature (ItemFlags?) text: proper alignment options in imgui_internal.h text: it's currently impossible to have a window title with \"##\". perhaps an official workaround would be nice. style inhibitor? non-visible ascii code to insert between #? text: provided a framed text helper, e.g. https://pastebin.com/1Laxy8bT text: refactor TextUnformatted (or underlying function) to more explicitly request if we need width measurement or not text link/url button: underlined. should api expose an ID or use text contents as ID? which colors enum to use? text/wrapped: should be a more first-class citizen, e.g. wrapped text within a Selectable with known width. text/wrapped: custom separator for text wrapping. ( #3002 ) text/wrapped: figure out better way to use TextWrapped() in an always auto-resize context (tooltip, etc.) ( #249 ) font: arbitrary line spacing. ( #2945 ) font: MergeMode: flags to select overwriting or not (this is now very easy with refactored ImFontAtlasBuildWithStbTruetype) font: free the Alpha buffer if user only requested RGBA. !- font: better CalcTextSizeA() API, at least for simple use cases. current one is horrible (perhaps have simple vs extended versions). font: for the purpose of RenderTextEllipsis(), it might be useful that CalcTextSizeA() can ignore the trailing padding? font: a CalcTextHeight() helper could run faster than CalcTextSize().y font: enforce monospace through ImFontConfig (for icons?) + create dual ImFont output from same input, reusing rasterized data but with different glyphs/AdvanceX font: finish CustomRectRegister() to allow mapping Unicode codepoint to custom texture data font: remove ID from CustomRect registration, it seems unnecessary! font: make it easier to submit own bitmap font (same texture, another texture?). ( #2127 , #2575 ) font: PushFontSize API ( #1018 ) font: MemoryTTF taking ownership confusing/not obvious, maybe default should be opposite? font: storing MinAdvanceX per font would allow us to skip calculating line width (under a threshold of character count) in loops looking for block width font/demo: add tools to show glyphs used by a text blob, display U16 value, list missing glyphs. font/demo: demonstrate use of ImFontGlyphRangesBuilder. font/atlas: add a missing Glyphs.reserve() font/atlas: incremental updates font/atlas: dynamic font atlas to avoid baking huge ranges into bitmap and make scaling easier. font/draw: vertical and/or rotated text renderer ( #705 ) - vertical is easier clipping wise font/draw: need to be able to specify wrap start position. font/draw: better reserve policy for large horizontal block of text (shouldn't reserve for all clipped lines) font/draw: underline, squiggle line rendering helpers. font: optimization: for monospace font (like the default one) we can trim IndexXAdvance as long as trailing value is == FallbackXAdvance (need to make sure TAB is still correct), would save on cache line. font: add support for kerning, probably optional. A) perhaps default to (32..128)^2 matrix ~ 9K entries = 36KB, then hash for non-ascii?. B) or sparse lookup into per-char list? font: add a simpler CalcTextSizeA() api? current one ok but not welcome if user needs to call it directly (without going through ImGui::CalcTextSize) font: fix AddRemapChar() to work before atlas has been built. font: support for unicode codepoints higher than 0xFFFF? (pr #2815 ) font: (api breaking) remove \"TTF\" from symbol names. also because it now supports OTF. font/opt: Considering storing standalone AdvanceX table as 16-bit fixed point integer? font/opt: Glyph currently 40 bytes (2+9*4). Consider storing UV as 16 bits integer? (->32 bytes). X0/Y0/X1/Y1 as 16 fixed-point integers? Or X0/Y0 as float and X1/Y1 as fixed8_8? nav: some features such as PageUp/Down/Home/End should probably work without ImGuiConfigFlags_NavEnableKeyboard? (where do we draw the line?) ! nav: never clear NavId on some setup (e.g. gamepad centric) nav: code to focus child-window on restoring NavId appears to have issue: e.g. when focus change is implicit because of window closure. nav: configuration flag to disable global shortcuts (currently only CTRL-Tab) ? nav: Home/End behavior when navigable item is not fully visible at the edge of scrolling? should be backtrack to keep item into view? nav: NavScrollToBringItemIntoView() with item bigger than view should focus top-right? Repro: using Nav in \"About Window\" nav: wrap around logic to allow e.g. grid based layout (pressing NavRight on the right-most element would go to the next row, etc.). see internal's NavMoveRequestTryWrapping(). nav: patterns to make it possible for arrows key to update selection nav: restore/find nearest NavId when current one disappear (e.g. pressed a button that disappear, or perhaps auto restoring when current button change name) nav: SetItemDefaultFocus() level of priority, so widget like Selectable when inside a popup could claim a low-priority default focus on the first selected iem nav: NavFlattened: ESC on a flattened child should select something. nav: NavFlattened: broken: in typical usage scenario, the items of a fully clipped child are currently not considered to enter into a NavFlattened child. nav: NavFlattened: init request doesn't select items that are part of a NavFlattened child nav: NavFlattened: cannot access menu-bar of a flattened child window with Alt/menu key (not a very common use case..). nav/treenode: Left within a tree node block as a fallback (ImGuiTreeNodeFlags_NavLeftJumpsBackHere by default?) nav/menus: pressing left-right on a vertically clipped menu bar tends to jump to the collapse/close buttons. nav/menus: allow pressing Menu to leave a sub-menu. nav/menus: a way to access the main menu bar with Alt? (currently needs CTRL+TAB) or last focused window menu bar? nav/menus: when using the main menu bar, even though we restore focus after, the underlying window loses its title bar highlight during menu manipulation. could we prevent it? nav/menus: main menu bar currently cannot restore a NULL focus. Could save NavWindow at the time of being focused, similarly to what popup do? nav/menus: Alt,Up could open the first menu (e.g. \"File\") currently it tends to nav into the window/collapse menu. Do do that we would need custom transition? nav/windowing: configure fade-in/fade-out delay on Ctrl+Tab? nav/windowing: when CTRL-Tab/windowing is active, the HoveredWindow detection doesn't take account of the window display re-ordering. nav: simulate right-click or context activation? (SHIFT+F10) nav: tabs should go through most/all widgets (in submission order?). nav: esc/enter default behavior for popups, e.g. be able to mark an \"ok\" or \"cancel\" button that would get triggered by those keys. nav: when activating a button that changes label (without a static ID) or disappear, can we somehow automatically recover into a nearest highlight item? nav: there's currently no way to completely clear focus with the keyboard. depending on patterns used by the application to dispatch inputs, it may be desirable. focus: preserve ActiveId/focus stack state, e.g. when opening a menu and close it, previously selected InputText() focus gets restored ( #622 ) focus: SetKeyboardFocusHere() on with >= 0 offset could be done on same frame (else latch and modulate on beginning of next frame) focus: unable to use SetKeyboardFocusHere() on clipped widgets. ( #787 ) inputs: we need an explicit flag about whether the imgui window is focused, to be able to distinguish focused key releases vs alt-tabbing all release behaviors. inputs: rework IO system to be able to pass actual ordered/timestamped events. use an event queue? (~ #335 , #71 ) inputs: support track pad style scrolling & slider edit. inputs/io: backspace and arrows in the context of a text input could use system repeat rate. inputs/io: clarify/standardize/expose repeat rate and repeat delays ( #1808 ) inputs/scrolling: support for smooth scrolling ( #2462 , #2569 ) misc: idle: expose \"woken up\" boolean (set by inputs) and/or animation time (for cursor blink) for back-end to be able stop refreshing easily. misc: idle: if cursor blink if the only visible animation, core imgui could rewrite vertex alpha to avoid CPU pass on ImGui:: calls. misc: idle: if cursor blink if the only visible animation, could even expose a dirty rectangle that optionally can be leverage by some app to render in a smaller viewport, getting rid of much pixel shading cost. misc: no way to run a root-most GetID() with ImGui:: api since there's always a Debug window in the stack. (mentioned in #2960 ) misc: make the ImGuiCond values linear (non-power-of-two). internal storage for ImGuiWindow can use integers to combine into flags (Why?) misc: provide a way to compile out the entire implementation while providing a dummy API (e.g. #define IMGUI_DUMMY_IMPL) misc: PushItemFlag(): add a flag to disable keyboard capture when used with mouse? ( #1682 ) misc: use more size_t in public api? misc: possible compile-time support for string view/range instead of char* would e.g. facilitate usage with Rust ( #683 ) misc: possible compile-time support for wchar_t instead of char*? remote: make a system like RemoteImGui first-class citizen/project ( #75 ) demo: find a way to demonstrate textures in the examples application, as it such a common issue for new users. demo: demonstrate using PushStyleVar() in more details. demo: add vertical separator demo demo: add virtual scrolling example? demo: demonstrate Plot offset demo: window size constraint: square demo is broken when resizing from edges ( #1975 ), would need to rework the callback system to solve this examples: window minimize, maximize ( #583 ) examples: provide a zero frame-rate/idle example. examples: dx11/dx12: try to use new swapchain blit models ( #2970 ) backends: apple: example_apple should be using modern GL3. backends: glfw: could go idle when minimized? if (glfwGetWindowAttrib(window, GLFW_ICONIFIED)) { glfwWaitEvents(); continue; } // issue: DeltaTime will be super high on resume, perhaps provide a way to let impl know ( #440 ) backends: opengl: rename imgui_impl_opengl2 to impl_opengl_legacy and imgui_impl_opengl3 to imgui_impl_opengl? ( #1900 ) backends: opengl: could use a single vertex buffer and glBufferSubData for uploads? backends: opengl: explicitly disable GL_STENCIL_TEST in bindings. backends: opengl: consider gl_lite loader https://github.com/ApoorvaJ/Papaya/blob/3808e39b0f45d4ca4972621c847586e4060c042a/src/libs/gl_lite.h backends: vulkan: viewport: support for synchronized swapping of multiple swap chains. backends: bgfx: https://gist.github.com/RichardGale/6e2b74bc42b3005e08397236e4be0fd0 backends: mscriptem: with refactored examples, we could provide a direct imgui_impl_emscripten platform layer (see eg. https://github.com/floooh/sokol-samples/blob/master/html5/imgui-emsc.cc#L42 ) optimization: replace vsnprintf with stb_printf? or enable the defines/infrastructure to allow it ( #1038 ) optimization: add clipping for multi-component widgets (SliderFloatX, ColorEditX, etc.). one problem is that nav branch can't easily clip parent group when there is a move request. optimization: add a flag to disable most of rendering, for the case where the user expect to skip it ( #335 ) optimization: fully covered window (covered by another with non-translucent bg + WindowRounding worth of padding) may want to clip rendering. optimization: use another hash function than crc32, e.g. FNV1a optimization/render: merge command-lists with same clip-rect into one even if they aren't sequential? (as long as in-between clip rectangle don't overlap)? optimization: turn some the various stack vectors into statically-sized arrays","title":"TODO"},{"location":"api-imgui/-----------------------------------------------------------------------------/","text":"----------------------------------------------------------------------------- \u00b6 // ImGuiStyle // You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame(). // During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values, // and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors. ----------------------------------------------------------------------------- \u00b6 // Misc data structures Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used. \u00b6 The callback function should return 0 by default. Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details) - ImGuiInputTextFlags_CallbackCompletion: Callback on pressing TAB - ImGuiInputTextFlags_CallbackHistory: Callback on pressing Up/Down arrows - ImGuiInputTextFlags_CallbackAlways: Callback on each iteration - ImGuiInputTextFlags_CallbackCharFilter: Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard. - ImGuiInputTextFlags_CallbackResize: Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin(). \u00b6 NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough. Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload() \u00b6","title":"-----------------------------------------------------------------------------"},{"location":"api-imgui/-----------------------------------------------------------------------------/#-","text":"// ImGuiStyle // You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame(). // During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values, // and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.","title":"-----------------------------------------------------------------------------"},{"location":"api-imgui/-----------------------------------------------------------------------------/#-_1","text":"// Misc data structures","title":"-----------------------------------------------------------------------------"},{"location":"api-imgui/-----------------------------------------------------------------------------/#shared-state-of-inputtext-passed-as-an-argument-to-your-callback-when-a-imguiinputtextflags_callback-flag-is-used","text":"The callback function should return 0 by default. Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details) - ImGuiInputTextFlags_CallbackCompletion: Callback on pressing TAB - ImGuiInputTextFlags_CallbackHistory: Callback on pressing Up/Down arrows - ImGuiInputTextFlags_CallbackAlways: Callback on each iteration - ImGuiInputTextFlags_CallbackCharFilter: Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard. - ImGuiInputTextFlags_CallbackResize: Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.","title":"Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used."},{"location":"api-imgui/-----------------------------------------------------------------------------/#resizing-callback-data-to-apply-custom-constraint-as-enabled-by-setnextwindowsizeconstraints-callback-is-called-during-the-next-begin","text":"NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.","title":"Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin()."},{"location":"api-imgui/-----------------------------------------------------------------------------/#data-payload-for-drag-and-drop-operations-acceptdragdroppayload-getdragdroppayload","text":"","title":"Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/","text":"Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) \u00b6 // Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList. ImDrawCallback: Draw callbacks for advanced uses [configurable type: override in imconfig.h] \u00b6 NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering, you can poke into the draw list for that! Draw callback may be useful for example to: A) Change your GPU render state, B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc. The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }' If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering back-end accordingly. Special Draw callback value to request renderer back-end to reset the graphics/render state. \u00b6 The renderer back-end needs to handle this special value, otherwise it will crash trying to call a function at this address. This is useful for example if you submitted callbacks which you know have altered the render state and you want it to be restored. It is not done by default because they are many perfectly useful way of altering render state for imgui contents (e.g. changing shader/blending settings before an Image call). Typically, 1 command = 1 GPU draw call (unless command is a callback) \u00b6 Pre 1.71 back-ends will typically ignore the VtxOffset/IdxOffset fields. When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled, those fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices. Vertex index, default to 16-bit \u00b6 To allow large meshes with 16-bit indices: set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset in the renderer back-end (recommended). To use 32-bit indices: override with '#define ImDrawIdx unsigned int' in imconfig.h. Vertex layout \u00b6 You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h \u00b6 The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine. The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared a the time you'd want to set your type up. NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM. For use by ImDrawListSplitter. \u00b6 Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order. \u00b6 This is used by the Columns api, so items of each column can be batched together in a same draw call. ImDrawCornerFlags_None \u2013 undefined ImDrawCornerFlags_TopLeft \u2013 0x1 ImDrawCornerFlags_TopRight \u2013 0x2 ImDrawCornerFlags_BotLeft \u2013 0x4 ImDrawCornerFlags_BotRight \u2013 0x8 ImDrawCornerFlags_Top \u2013 0x3 ImDrawCornerFlags_Bot \u2013 0xC ImDrawCornerFlags_Left \u2013 0x5 ImDrawCornerFlags_Right \u2013 0xA ImDrawListFlags_None \u2013 undefined ImDrawListFlags_AntiAliasedLines \u2013 Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles) ImDrawListFlags_AntiAliasedFill \u2013 Filled shapes have anti-aliased edges (*2 the number of vertices) Draw command list \u00b6 This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering. Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives. You can interleave normal ImGui:: calls and adding primitives to the current draw list. All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well) Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects. All draw data to render a Dear ImGui frame \u00b6 (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose, as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)","title":"Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#draw-list-api-imdrawcmd-imdrawidx-imdrawvert-imdrawchannel-imdrawlistsplitter-imdrawlistflags-imdrawlist-imdrawdata","text":"// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.","title":"Draw List API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#imdrawcallback-draw-callbacks-for-advanced-uses-configurable-type-override-in-imconfigh","text":"NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering, you can poke into the draw list for that! Draw callback may be useful for example to: A) Change your GPU render state, B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc. The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }' If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering back-end accordingly.","title":"ImDrawCallback: Draw callbacks for advanced uses [configurable type: override in imconfig.h]"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#special-draw-callback-value-to-request-renderer-back-end-to-reset-the-graphicsrender-state","text":"The renderer back-end needs to handle this special value, otherwise it will crash trying to call a function at this address. This is useful for example if you submitted callbacks which you know have altered the render state and you want it to be restored. It is not done by default because they are many perfectly useful way of altering render state for imgui contents (e.g. changing shader/blending settings before an Image call).","title":"Special Draw callback value to request renderer back-end to reset the graphics/render state."},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#typically-1-command-1-gpu-draw-call-unless-command-is-a-callback","text":"Pre 1.71 back-ends will typically ignore the VtxOffset/IdxOffset fields. When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled, those fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.","title":"Typically, 1 command = 1 GPU draw call (unless command is a callback)"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#vertex-index-default-to-16-bit","text":"To allow large meshes with 16-bit indices: set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset in the renderer back-end (recommended). To use 32-bit indices: override with '#define ImDrawIdx unsigned int' in imconfig.h.","title":"Vertex index, default to 16-bit"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#vertex-layout","text":"","title":"Vertex layout"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#you-can-override-the-vertex-format-layout-by-defining-imgui_override_drawvert_struct_layout-in-imconfigh","text":"The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine. The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared a the time you'd want to set your type up. NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.","title":"You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#for-use-by-imdrawlistsplitter","text":"","title":"For use by ImDrawListSplitter."},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#splitmerge-functions-are-used-to-split-the-draw-list-into-different-layers-which-can-be-drawn-into-out-of-order","text":"This is used by the Columns api, so items of each column can be batched together in a same draw call. ImDrawCornerFlags_None \u2013 undefined ImDrawCornerFlags_TopLeft \u2013 0x1 ImDrawCornerFlags_TopRight \u2013 0x2 ImDrawCornerFlags_BotLeft \u2013 0x4 ImDrawCornerFlags_BotRight \u2013 0x8 ImDrawCornerFlags_Top \u2013 0x3 ImDrawCornerFlags_Bot \u2013 0xC ImDrawCornerFlags_Left \u2013 0x5 ImDrawCornerFlags_Right \u2013 0xA ImDrawListFlags_None \u2013 undefined ImDrawListFlags_AntiAliasedLines \u2013 Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles) ImDrawListFlags_AntiAliasedFill \u2013 Filled shapes have anti-aliased edges (*2 the number of vertices)","title":"Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order."},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#draw-command-list","text":"This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering. Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives. You can interleave normal ImGui:: calls and adding primitives to the current draw list. All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), but you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well) Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.","title":"Draw command list"},{"location":"api-imgui/Draw-List-API--ImDrawCmd-/#all-draw-data-to-render-a-dear-imgui-frame","text":"(NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose, as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)","title":"All draw data to render a Dear ImGui frame"},{"location":"api-imgui/Flags---Enumerations/","text":"Flags & Enumerations \u00b6 Flags for ImGui::Begin() \u00b6 ImGuiWindowFlags_None \u2013 undefined ImGuiWindowFlags_NoTitleBar \u2013 Disable title-bar ImGuiWindowFlags_NoResize \u2013 Disable user resizing with the lower-right grip ImGuiWindowFlags_NoMove \u2013 Disable user moving the window ImGuiWindowFlags_NoScrollbar \u2013 Disable scrollbars (window can still scroll with mouse or programmatically) ImGuiWindowFlags_NoScrollWithMouse \u2013 Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set. ImGuiWindowFlags_NoCollapse \u2013 Disable user collapsing window by double-clicking on it ImGuiWindowFlags_AlwaysAutoResize \u2013 Resize every window to its content every frame ImGuiWindowFlags_NoBackground \u2013 Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f). ImGuiWindowFlags_NoSavedSettings \u2013 Never load/save settings in .ini file ImGuiWindowFlags_NoMouseInputs \u2013 Disable catching mouse, hovering test with pass through. ImGuiWindowFlags_MenuBar \u2013 Has a menu-bar ImGuiWindowFlags_HorizontalScrollbar \u2013 Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section. ImGuiWindowFlags_NoFocusOnAppearing \u2013 Disable taking focus when transitioning from hidden to visible state ImGuiWindowFlags_NoBringToFrontOnFocus \u2013 Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus) 14 \u2013 Always show vertical scrollbar (even if ContentSize.y < Size.y) 15 \u2013 Always show horizontal scrollbar (even if ContentSize.x < Size.x) ImGuiWindowFlags_AlwaysUseWindowPadding \u2013 Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient) ImGuiWindowFlags_NoNavInputs \u2013 No gamepad/keyboard navigation within the window ImGuiWindowFlags_NoNavFocus \u2013 No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB) ImGuiWindowFlags_UnsavedDocument \u2013 Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker. ImGuiWindowFlags_NoNav \u2013 undefined ImGuiWindowFlags_NoDecoration \u2013 undefined ImGuiWindowFlags_NoInputs \u2013 undefined ImGuiWindowFlags_NavFlattened \u2013 [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!) ImGuiWindowFlags_ChildWindow \u2013 Don't use! For internal use by BeginChild() ImGuiWindowFlags_Tooltip \u2013 Don't use! For internal use by BeginTooltip() ImGuiWindowFlags_Popup \u2013 Don't use! For internal use by BeginPopup() ImGuiWindowFlags_Modal \u2013 Don't use! For internal use by BeginPopupModal() ImGuiWindowFlags_ChildMenu \u2013 \u2192 Set style.FrameBorderSize=1.0f or style.WindowBorderSize=1.0f to enable borders around items or windows. ImGuiWindowFlags_ResizeFromAnySide \u2013 \u2192 Set io.ConfigWindowsResizeFromEdges=true and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) Flags for ImGui::InputText() \u00b6 ImGuiInputTextFlags_None \u2013 undefined ImGuiInputTextFlags_CharsDecimal \u2013 Allow 0123456789.+-*/ ImGuiInputTextFlags_CharsHexadecimal \u2013 Allow 0123456789ABCDEFabcdef ImGuiInputTextFlags_CharsUppercase \u2013 Turn a..z into A..Z ImGuiInputTextFlags_CharsNoBlank \u2013 Filter out spaces, tabs ImGuiInputTextFlags_AutoSelectAll \u2013 Select entire text when first taking mouse focus ImGuiInputTextFlags_EnterReturnsTrue \u2013 Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function. ImGuiInputTextFlags_CallbackCompletion \u2013 Callback on pressing TAB (for completion handling) ImGuiInputTextFlags_CallbackHistory \u2013 Callback on pressing Up/Down arrows (for history handling) ImGuiInputTextFlags_CallbackAlways \u2013 Callback on each iteration. User code may query cursor position, modify text buffer. ImGuiInputTextFlags_CallbackCharFilter \u2013 Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard. ImGuiInputTextFlags_AllowTabInput \u2013 Pressing TAB input a '\\t' character into the text field ImGuiInputTextFlags_CtrlEnterForNewLine \u2013 In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter). ImGuiInputTextFlags_NoHorizontalScroll \u2013 Disable following the cursor horizontally ImGuiInputTextFlags_AlwaysInsertMode \u2013 Insert mode ImGuiInputTextFlags_ReadOnly \u2013 Read-only mode ImGuiInputTextFlags_Password \u2013 Password mode, display all characters as '*' ImGuiInputTextFlags_NoUndoRedo \u2013 Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID(). ImGuiInputTextFlags_CharsScientific \u2013 Allow 0123456789.+-*/eE (Scientific notation input) ImGuiInputTextFlags_CallbackResize \u2013 Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this) ImGuiInputTextFlags_Multiline \u2013 For internal use by InputTextMultiline() Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*() \u00b6 ImGuiTreeNodeFlags_None \u2013 undefined ImGuiTreeNodeFlags_Selected \u2013 Draw as selected ImGuiTreeNodeFlags_Framed \u2013 Full colored frame (e.g. for CollapsingHeader) ImGuiTreeNodeFlags_AllowItemOverlap \u2013 Hit testing to allow subsequent widgets to overlap this one ImGuiTreeNodeFlags_NoTreePushOnOpen \u2013 Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack ImGuiTreeNodeFlags_NoAutoOpenOnLog \u2013 Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes) ImGuiTreeNodeFlags_DefaultOpen \u2013 Default node to be open ImGuiTreeNodeFlags_OpenOnDoubleClick \u2013 Need double-click to open node ImGuiTreeNodeFlags_OpenOnArrow \u2013 Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open. ImGuiTreeNodeFlags_Leaf \u2013 No collapsing, no arrow (use as a convenience for leaf nodes). ImGuiTreeNodeFlags_Bullet \u2013 Display a bullet instead of arrow ImGuiTreeNodeFlags_FramePadding \u2013 Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding(). ImGuiTreeNodeFlags_SpanAvailWidth \u2013 Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default. ImGuiTreeNodeFlags_SpanFullWidth \u2013 Extend hit box to the left-most and right-most edges (bypass the indented area). ImGuiTreeNodeFlags_NavLeftJumpsBackHere \u2013 (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop) ImGuiTreeNodeFlags_NoScrollOnOpen \u2013 FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible Flags for ImGui::Selectable() \u00b6 ImGuiSelectableFlags_None \u2013 undefined ImGuiSelectableFlags_DontClosePopups \u2013 Clicking this don't close parent popup window ImGuiSelectableFlags_SpanAllColumns \u2013 Selectable frame can span all columns (text will still fit in current column) ImGuiSelectableFlags_AllowDoubleClick \u2013 Generate press events on double clicks too ImGuiSelectableFlags_Disabled \u2013 Cannot be selected, display grayed out text Flags for ImGui::BeginCombo() \u00b6 ImGuiComboFlags_None \u2013 undefined ImGuiComboFlags_PopupAlignLeft \u2013 Align the popup toward the left by default ImGuiComboFlags_HeightSmall \u2013 Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo() ImGuiComboFlags_HeightRegular \u2013 Max ~8 items visible (default) ImGuiComboFlags_HeightLarge \u2013 Max ~20 items visible ImGuiComboFlags_HeightLargest \u2013 As many fitting items as possible ImGuiComboFlags_NoArrowButton \u2013 Display on the preview box without the square arrow button ImGuiComboFlags_NoPreview \u2013 Display only a square arrow button Flags for ImGui::BeginTabBar() \u00b6 ImGuiTabBarFlags_None \u2013 undefined ImGuiTabBarFlags_Reorderable \u2013 Allow manually dragging tabs to re-order them + New tabs are appended at the end of list ImGuiTabBarFlags_AutoSelectNewTabs \u2013 Automatically select new tabs when they appear ImGuiTabBarFlags_TabListPopupButton \u2013 Disable buttons to open the tab list popup ImGuiTabBarFlags_NoCloseWithMiddleMouseButton \u2013 Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false. ImGuiTabBarFlags_NoTabListScrollingButtons \u2013 Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll) ImGuiTabBarFlags_NoTooltip \u2013 Disable tooltips when hovering a tab ImGuiTabBarFlags_FittingPolicyResizeDown \u2013 Resize tabs when they don't fit ImGuiTabBarFlags_FittingPolicyScroll \u2013 Add scroll buttons when tabs don't fit ImGuiTabBarFlags_FittingPolicyMask_ \u2013 undefined Flags for ImGui::BeginTabItem() \u00b6 ImGuiTabItemFlags_None \u2013 undefined ImGuiTabItemFlags_UnsavedDocument \u2013 Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker. ImGuiTabItemFlags_SetSelected \u2013 Trigger flag to programmatically make the tab selected when calling BeginTabItem() ImGuiTabItemFlags_NoCloseWithMiddleMouseButton \u2013 Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false. Flags for ImGui::IsWindowFocused() \u00b6 ImGuiFocusedFlags_None \u2013 undefined ImGuiFocusedFlags_ChildWindows \u2013 IsWindowFocused(): Return true if any children of the window is focused ImGuiFocusedFlags_RootWindow \u2013 IsWindowFocused(): Test from root window (top most parent of the current hierarchy) ImGuiFocusedFlags_AnyWindow \u2013 IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ! Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered() \u00b6 Note: if you are trying to check whether your mouse should be dispatched to Dear ImGui or to your app, you should use 'io.WantCaptureMouse' instead! Please read the FAQ! Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls. ImGuiHoveredFlags_None \u2013 Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them. ImGuiHoveredFlags_ChildWindows \u2013 IsWindowHovered() only: Return true if any children of the window is hovered ImGuiHoveredFlags_RootWindow \u2013 IsWindowHovered() only: Test from root window (top most parent of the current hierarchy) ImGuiHoveredFlags_AnyWindow \u2013 IsWindowHovered() only: Return true if any window is hovered ImGuiHoveredFlags_AllowWhenBlockedByPopup \u2013 Return true even if a popup window is normally blocking access to this item/window ImGuiHoveredFlags_AllowWhenBlockedByModal \u2013 Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet. ImGuiHoveredFlags_AllowWhenBlockedByActiveItem \u2013 Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns. ImGuiHoveredFlags_AllowWhenOverlapped \u2013 Return true even if the position is obstructed or overlapped by another window ImGuiHoveredFlags_AllowWhenDisabled \u2013 Return true even if the item is disabled ImGuiHoveredFlags_RectOnly \u2013 undefined Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload() \u00b6 ImGuiDragDropFlags_None \u2013 undefined ImGuiDragDropFlags_SourceNoPreviewTooltip \u2013 By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior. ImGuiDragDropFlags_SourceNoDisableHover \u2013 By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item. ImGuiDragDropFlags_SourceNoHoldToOpenOthers \u2013 Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item. ImGuiDragDropFlags_SourceAllowNullID \u2013 Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit. ImGuiDragDropFlags_SourceExtern \u2013 External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously. ImGuiDragDropFlags_SourceAutoExpirePayload \u2013 Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged) ImGuiDragDropFlags_AcceptBeforeDelivery \u2013 AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered. ImGuiDragDropFlags_AcceptNoDrawDefaultRect \u2013 Do not draw the default highlight rectangle when hovering over target. ImGuiDragDropFlags_AcceptNoPreviewTooltip \u2013 Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site. Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui. \u00b6 A primary data type \u00b6 ImGuiDataType_S8 \u2013 signed char / char (with sensible compilers) ImGuiDataType_U8 \u2013 unsigned char ImGuiDataType_S16 \u2013 short ImGuiDataType_U16 \u2013 unsigned short ImGuiDataType_S32 \u2013 int ImGuiDataType_U32 \u2013 unsigned int ImGuiDataType_S64 \u2013 long long / __int64 ImGuiDataType_U64 \u2013 unsigned long long / unsigned __int64 ImGuiDataType_Float \u2013 float ImGuiDataType_Double \u2013 double A cardinal direction \u00b6 ImGuiDir_None \u2013 undefined ImGuiDir_Left \u2013 undefined ImGuiDir_Right \u2013 undefined ImGuiDir_Up \u2013 undefined ImGuiDir_Down \u2013 undefined User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array \u00b6 ImGuiKey_Tab \u2013 undefined ImGuiKey_LeftArrow \u2013 undefined ImGuiKey_RightArrow \u2013 undefined ImGuiKey_UpArrow \u2013 undefined ImGuiKey_DownArrow \u2013 undefined ImGuiKey_PageUp \u2013 undefined ImGuiKey_PageDown \u2013 undefined ImGuiKey_Home \u2013 undefined ImGuiKey_End \u2013 undefined ImGuiKey_Insert \u2013 undefined ImGuiKey_Delete \u2013 undefined ImGuiKey_Backspace \u2013 undefined ImGuiKey_Space \u2013 undefined ImGuiKey_Enter \u2013 undefined ImGuiKey_Escape \u2013 undefined ImGuiKey_KeyPadEnter \u2013 undefined ImGuiKey_A \u2013 for text edit CTRL+A: select all ImGuiKey_C \u2013 for text edit CTRL+C: copy ImGuiKey_V \u2013 for text edit CTRL+V: paste ImGuiKey_X \u2013 for text edit CTRL+X: cut ImGuiKey_Y \u2013 for text edit CTRL+Y: redo ImGuiKey_Z \u2013 for text edit CTRL+Z: undo To test io.KeyMods (which is a combination of individual fields io.KeyCtrl, io.KeyShift, io.KeyAlt set by user/back-end) \u00b6 ImGuiKeyModFlags_None \u2013 undefined ImGuiKeyModFlags_Ctrl \u2013 undefined ImGuiKeyModFlags_Shift \u2013 undefined ImGuiKeyModFlags_Alt \u2013 undefined Gamepad/Keyboard navigation \u00b6 XXXKeyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] and io.KeyMap[] arrays. Gamepad: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame() . Note that io.NavInputs[] is cleared by EndFrame() . Read instructions in imgui.cpp for more details. Download PNG/PSD at http:goo.gl/9LgVZW. ImGuiNavInput_Activate \u2013 activate / open / toggle / tweak value // e.g. Cross (PS4), A (Xbox), A (Switch), Space (Keyboard) ImGuiNavInput_Cancel \u2013 cancel / close / exit // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard) ImGuiNavInput_Input \u2013 text input / on-screen keyboard // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard) ImGuiNavInput_Menu \u2013 tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard) ImGuiNavInput_DpadLeft \u2013 move / tweak / resize window (w/ PadMenu) // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard) ImGuiNavInput_DpadRight \u2013 ImGuiNavInput_DpadUp, // ImGuiNavInput_DpadDown \u2013 ImGuiNavInput_LStickLeft, // scroll / move window (w/ PadMenu) // e.g. Left Analog Stick Left/Right/Up/Down ImGuiNavInput_LStickRight \u2013 ImGuiNavInput_LStickUp, // ImGuiNavInput_LStickDown \u2013 ImGuiNavInput_FocusPrev, // next window (w/ PadMenu) // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch) ImGuiNavInput_FocusNext \u2013 prev window (w/ PadMenu) // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch) ImGuiNavInput_TweakSlow \u2013 slower tweaks // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch) ImGuiNavInput_TweakFast \u2013 faster tweaks // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch) ImGuiNavInput_KeyMenu_ \u2013 toggle menu // = io.KeyAlt ImGuiNavInput_KeyLeft_ \u2013 move left // = Arrow keys ImGuiNavInput_KeyRight_ \u2013 move right ImGuiNavInput_KeyUp_ \u2013 move up ImGuiNavInput_KeyDown_ \u2013 move down ImGuiNavInput_COUNT \u2013 undefined Configuration flags stored in io.ConfigFlags. Set by user/application. \u00b6 ImGuiConfigFlags_None \u2013 undefined ImGuiConfigFlags_NavEnableKeyboard \u2013 Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[]. ImGuiConfigFlags_NavEnableGamepad \u2013 Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad. ImGuiConfigFlags_NavEnableSetMousePos \u2013 Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth. ImGuiConfigFlags_NavNoCaptureKeyboard \u2013 Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set. ImGuiConfigFlags_NoMouse \u2013 Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end. ImGuiConfigFlags_NoMouseCursorChange \u2013 Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead. ImGuiConfigFlags_IsSRGB \u2013 Application is SRGB-aware. Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end. \u00b6 ImGuiBackendFlags_None \u2013 undefined ImGuiBackendFlags_HasGamepad \u2013 Back-end Platform supports gamepad and currently has one connected. ImGuiBackendFlags_HasMouseCursors \u2013 Back-end Platform supports honoring GetMouseCursor() value to change the OS cursor shape. ImGuiBackendFlags_HasSetMousePos \u2013 Back-end Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set). Enumeration for PushStyleColor() / PopStyleColor() \u00b6 ImGuiCol_Text \u2013 undefined ImGuiCol_TextDisabled \u2013 undefined ImGuiCol_WindowBg \u2013 Background of normal windows ImGuiCol_ChildBg \u2013 Background of child windows ImGuiCol_PopupBg \u2013 Background of popups, menus, tooltips windows ImGuiCol_Border \u2013 undefined ImGuiCol_BorderShadow \u2013 undefined ImGuiCol_FrameBg \u2013 Background of checkbox, radio button, plot, slider, text input ImGuiCol_FrameBgHovered \u2013 undefined ImGuiCol_FrameBgActive \u2013 undefined ImGuiCol_TitleBg \u2013 undefined ImGuiCol_TitleBgActive \u2013 undefined ImGuiCol_TitleBgCollapsed \u2013 undefined ImGuiCol_MenuBarBg \u2013 undefined ImGuiCol_ScrollbarBg \u2013 undefined ImGuiCol_ScrollbarGrab \u2013 undefined ImGuiCol_ScrollbarGrabHovered \u2013 undefined ImGuiCol_ScrollbarGrabActive \u2013 undefined ImGuiCol_CheckMark \u2013 undefined ImGuiCol_SliderGrab \u2013 undefined ImGuiCol_SliderGrabActive \u2013 undefined ImGuiCol_Button \u2013 undefined ImGuiCol_ButtonHovered \u2013 undefined ImGuiCol_ButtonActive \u2013 undefined ImGuiCol_Header \u2013 Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem ImGuiCol_HeaderHovered \u2013 undefined ImGuiCol_HeaderActive \u2013 undefined ImGuiCol_Separator \u2013 undefined ImGuiCol_SeparatorHovered \u2013 undefined ImGuiCol_SeparatorActive \u2013 undefined ImGuiCol_ResizeGrip \u2013 undefined ImGuiCol_ResizeGripHovered \u2013 undefined ImGuiCol_ResizeGripActive \u2013 undefined ImGuiCol_Tab \u2013 undefined ImGuiCol_TabHovered \u2013 undefined ImGuiCol_TabActive \u2013 undefined ImGuiCol_TabUnfocused \u2013 undefined ImGuiCol_TabUnfocusedActive \u2013 undefined ImGuiCol_PlotLines \u2013 undefined ImGuiCol_PlotLinesHovered \u2013 undefined ImGuiCol_PlotHistogram \u2013 undefined ImGuiCol_PlotHistogramHovered \u2013 undefined ImGuiCol_TextSelectedBg \u2013 undefined ImGuiCol_DragDropTarget \u2013 undefined ImGuiCol_NavHighlight \u2013 Gamepad/keyboard: current highlighted item ImGuiCol_NavWindowingHighlight \u2013 Highlight window when using CTRL+TAB ImGuiCol_NavWindowingDimBg \u2013 Darken/colorize entire screen behind the CTRL+TAB window list, when active ImGuiCol_ModalWindowDimBg \u2013 Darken/colorize entire screen behind a modal window, when one is active Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure. \u00b6 The enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization or between frames, feel free to just poke into ImGuiStyle directly. Tip: Use your programming IDE navigation facilities on the names in the second column below to find the actual members and their description. In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot. With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments. When changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type. ImGuiStyleVar_Alpha \u2013 float Alpha ImGuiStyleVar_WindowPadding \u2013 ImVec2 WindowPadding ImGuiStyleVar_WindowRounding \u2013 float WindowRounding ImGuiStyleVar_WindowBorderSize \u2013 float WindowBorderSize ImGuiStyleVar_WindowMinSize \u2013 ImVec2 WindowMinSize ImGuiStyleVar_WindowTitleAlign \u2013 ImVec2 WindowTitleAlign ImGuiStyleVar_ChildRounding \u2013 float ChildRounding ImGuiStyleVar_ChildBorderSize \u2013 float ChildBorderSize ImGuiStyleVar_PopupRounding \u2013 float PopupRounding ImGuiStyleVar_PopupBorderSize \u2013 float PopupBorderSize ImGuiStyleVar_FramePadding \u2013 ImVec2 FramePadding ImGuiStyleVar_FrameRounding \u2013 float FrameRounding ImGuiStyleVar_FrameBorderSize \u2013 float FrameBorderSize ImGuiStyleVar_ItemSpacing \u2013 ImVec2 ItemSpacing ImGuiStyleVar_ItemInnerSpacing \u2013 ImVec2 ItemInnerSpacing ImGuiStyleVar_IndentSpacing \u2013 float IndentSpacing ImGuiStyleVar_ScrollbarSize \u2013 float ScrollbarSize ImGuiStyleVar_ScrollbarRounding \u2013 float ScrollbarRounding ImGuiStyleVar_GrabMinSize \u2013 float GrabMinSize ImGuiStyleVar_GrabRounding \u2013 float GrabRounding ImGuiStyleVar_TabRounding \u2013 float TabRounding ImGuiStyleVar_ButtonTextAlign \u2013 ImVec2 ButtonTextAlign ImGuiStyleVar_SelectableTextAlign \u2013 ImVec2 SelectableTextAlign Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton() \u00b6 ImGuiColorEditFlags_None \u2013 undefined ImGuiColorEditFlags_NoAlpha \u2013 // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer). ImGuiColorEditFlags_NoPicker \u2013 // ColorEdit: disable picker when clicking on colored square. ImGuiColorEditFlags_NoOptions \u2013 // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview. ImGuiColorEditFlags_NoSmallPreview \u2013 // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs) ImGuiColorEditFlags_NoInputs \u2013 // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square). ImGuiColorEditFlags_NoTooltip \u2013 // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview. ImGuiColorEditFlags_NoLabel \u2013 // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker). ImGuiColorEditFlags_NoSidePreview \u2013 // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead. ImGuiColorEditFlags_NoDragDrop \u2013 // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source. ImGuiColorEditFlags_NoBorder \u2013 // ColorButton: disable border (which is enforced by default) ImGuiColorEditFlags_AlphaBar \u2013 // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker. ImGuiColorEditFlags_AlphaPreview \u2013 // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque. 18 \u2013 // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque. ImGuiColorEditFlags_HDR \u2013 // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well). ImGuiColorEditFlags_DisplayRGB \u2013 [Display] // ColorEdit: override display type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex. ImGuiColorEditFlags_DisplayHSV \u2013 [Display] // \" ImGuiColorEditFlags_DisplayHex \u2013 [Display] // \" ImGuiColorEditFlags_Uint8 \u2013 [DataType] // ColorEdit, ColorPicker, ColorButton: display values formatted as 0..255. ImGuiColorEditFlags_Float \u2013 [DataType] // ColorEdit, ColorPicker, ColorButton: display values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers. ImGuiColorEditFlags_PickerHueBar \u2013 [Picker] // ColorPicker: bar for Hue, rectangle for Sat/Value. ImGuiColorEditFlags_PickerHueWheel \u2013 [Picker] // ColorPicker: wheel for Hue, triangle for Sat/Value. ImGuiColorEditFlags_InputRGB \u2013 [Input] // ColorEdit, ColorPicker: input and output data in RGB format. ImGuiColorEditFlags_InputHSV \u2013 [Input] // ColorEdit, ColorPicker: input and output data in HSV format. ImGuiColorEditFlags__OptionsDefault \u2013 undefined ImGuiColorEditFlags__DisplayMask \u2013 undefined ImGuiColorEditFlags__DataTypeMask \u2013 undefined ImGuiColorEditFlags__PickerMask \u2013 undefined Identify a mouse button. \u00b6 Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience. ImGuiMouseButton_Left \u2013 undefined ImGuiMouseButton_Right \u2013 undefined ImGuiMouseButton_Middle \u2013 undefined Enumeration for GetMouseCursor() \u00b6 User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here ImGuiMouseCursor_None \u2013 undefined ImGuiMouseCursor_Arrow \u2013 undefined ImGuiMouseCursor_TextInput \u2013 When hovering over InputText, etc. ImGuiMouseCursor_ResizeAll \u2013 (Unused by Dear ImGui functions) ImGuiMouseCursor_ResizeNS \u2013 When hovering over an horizontal border ImGuiMouseCursor_ResizeEW \u2013 When hovering over a vertical border or a column ImGuiMouseCursor_ResizeNESW \u2013 When hovering over the bottom-left corner of a window ImGuiMouseCursor_ResizeNWSE \u2013 When hovering over the bottom-right corner of a window ImGuiMouseCursor_Hand \u2013 (Unused by Dear ImGui functions. Use for e.g. hyperlinks) ImGuiMouseCursor_NotAllowed \u2013 When hovering something with disallowed interaction. Usually a crossed circle. Enumeration for ImGui::SetWindow***(), SetNextWindow***(), SetNextItem***() functions \u00b6 Represent a condition. Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always. ImGuiCond_Always \u2013 Set the variable ImGuiCond_Once \u2013 Set the variable once per runtime session (only the first call will succeed) ImGuiCond_FirstUseEver \u2013 Set the variable if the object/window has no persistently saved data (no entry in .ini file)","title":"API Flags"},{"location":"api-imgui/Flags---Enumerations/#flags-enumerations","text":"","title":"Flags &amp; Enumerations"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguibegin","text":"ImGuiWindowFlags_None \u2013 undefined ImGuiWindowFlags_NoTitleBar \u2013 Disable title-bar ImGuiWindowFlags_NoResize \u2013 Disable user resizing with the lower-right grip ImGuiWindowFlags_NoMove \u2013 Disable user moving the window ImGuiWindowFlags_NoScrollbar \u2013 Disable scrollbars (window can still scroll with mouse or programmatically) ImGuiWindowFlags_NoScrollWithMouse \u2013 Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set. ImGuiWindowFlags_NoCollapse \u2013 Disable user collapsing window by double-clicking on it ImGuiWindowFlags_AlwaysAutoResize \u2013 Resize every window to its content every frame ImGuiWindowFlags_NoBackground \u2013 Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f). ImGuiWindowFlags_NoSavedSettings \u2013 Never load/save settings in .ini file ImGuiWindowFlags_NoMouseInputs \u2013 Disable catching mouse, hovering test with pass through. ImGuiWindowFlags_MenuBar \u2013 Has a menu-bar ImGuiWindowFlags_HorizontalScrollbar \u2013 Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section. ImGuiWindowFlags_NoFocusOnAppearing \u2013 Disable taking focus when transitioning from hidden to visible state ImGuiWindowFlags_NoBringToFrontOnFocus \u2013 Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus) 14 \u2013 Always show vertical scrollbar (even if ContentSize.y < Size.y) 15 \u2013 Always show horizontal scrollbar (even if ContentSize.x < Size.x) ImGuiWindowFlags_AlwaysUseWindowPadding \u2013 Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient) ImGuiWindowFlags_NoNavInputs \u2013 No gamepad/keyboard navigation within the window ImGuiWindowFlags_NoNavFocus \u2013 No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB) ImGuiWindowFlags_UnsavedDocument \u2013 Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker. ImGuiWindowFlags_NoNav \u2013 undefined ImGuiWindowFlags_NoDecoration \u2013 undefined ImGuiWindowFlags_NoInputs \u2013 undefined ImGuiWindowFlags_NavFlattened \u2013 [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!) ImGuiWindowFlags_ChildWindow \u2013 Don't use! For internal use by BeginChild() ImGuiWindowFlags_Tooltip \u2013 Don't use! For internal use by BeginTooltip() ImGuiWindowFlags_Popup \u2013 Don't use! For internal use by BeginPopup() ImGuiWindowFlags_Modal \u2013 Don't use! For internal use by BeginPopupModal() ImGuiWindowFlags_ChildMenu \u2013 \u2192 Set style.FrameBorderSize=1.0f or style.WindowBorderSize=1.0f to enable borders around items or windows. ImGuiWindowFlags_ResizeFromAnySide \u2013 \u2192 Set io.ConfigWindowsResizeFromEdges=true and make sure mouse cursors are supported by back-end (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors)","title":"Flags for ImGui::Begin()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguiinputtext","text":"ImGuiInputTextFlags_None \u2013 undefined ImGuiInputTextFlags_CharsDecimal \u2013 Allow 0123456789.+-*/ ImGuiInputTextFlags_CharsHexadecimal \u2013 Allow 0123456789ABCDEFabcdef ImGuiInputTextFlags_CharsUppercase \u2013 Turn a..z into A..Z ImGuiInputTextFlags_CharsNoBlank \u2013 Filter out spaces, tabs ImGuiInputTextFlags_AutoSelectAll \u2013 Select entire text when first taking mouse focus ImGuiInputTextFlags_EnterReturnsTrue \u2013 Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function. ImGuiInputTextFlags_CallbackCompletion \u2013 Callback on pressing TAB (for completion handling) ImGuiInputTextFlags_CallbackHistory \u2013 Callback on pressing Up/Down arrows (for history handling) ImGuiInputTextFlags_CallbackAlways \u2013 Callback on each iteration. User code may query cursor position, modify text buffer. ImGuiInputTextFlags_CallbackCharFilter \u2013 Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard. ImGuiInputTextFlags_AllowTabInput \u2013 Pressing TAB input a '\\t' character into the text field ImGuiInputTextFlags_CtrlEnterForNewLine \u2013 In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter). ImGuiInputTextFlags_NoHorizontalScroll \u2013 Disable following the cursor horizontally ImGuiInputTextFlags_AlwaysInsertMode \u2013 Insert mode ImGuiInputTextFlags_ReadOnly \u2013 Read-only mode ImGuiInputTextFlags_Password \u2013 Password mode, display all characters as '*' ImGuiInputTextFlags_NoUndoRedo \u2013 Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID(). ImGuiInputTextFlags_CharsScientific \u2013 Allow 0123456789.+-*/eE (Scientific notation input) ImGuiInputTextFlags_CallbackResize \u2013 Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this) ImGuiInputTextFlags_Multiline \u2013 For internal use by InputTextMultiline()","title":"Flags for ImGui::InputText()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguitreenodeex-imguicollapsingheader","text":"ImGuiTreeNodeFlags_None \u2013 undefined ImGuiTreeNodeFlags_Selected \u2013 Draw as selected ImGuiTreeNodeFlags_Framed \u2013 Full colored frame (e.g. for CollapsingHeader) ImGuiTreeNodeFlags_AllowItemOverlap \u2013 Hit testing to allow subsequent widgets to overlap this one ImGuiTreeNodeFlags_NoTreePushOnOpen \u2013 Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack ImGuiTreeNodeFlags_NoAutoOpenOnLog \u2013 Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes) ImGuiTreeNodeFlags_DefaultOpen \u2013 Default node to be open ImGuiTreeNodeFlags_OpenOnDoubleClick \u2013 Need double-click to open node ImGuiTreeNodeFlags_OpenOnArrow \u2013 Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open. ImGuiTreeNodeFlags_Leaf \u2013 No collapsing, no arrow (use as a convenience for leaf nodes). ImGuiTreeNodeFlags_Bullet \u2013 Display a bullet instead of arrow ImGuiTreeNodeFlags_FramePadding \u2013 Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding(). ImGuiTreeNodeFlags_SpanAvailWidth \u2013 Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default. ImGuiTreeNodeFlags_SpanFullWidth \u2013 Extend hit box to the left-most and right-most edges (bypass the indented area). ImGuiTreeNodeFlags_NavLeftJumpsBackHere \u2013 (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop) ImGuiTreeNodeFlags_NoScrollOnOpen \u2013 FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible","title":"Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguiselectable","text":"ImGuiSelectableFlags_None \u2013 undefined ImGuiSelectableFlags_DontClosePopups \u2013 Clicking this don't close parent popup window ImGuiSelectableFlags_SpanAllColumns \u2013 Selectable frame can span all columns (text will still fit in current column) ImGuiSelectableFlags_AllowDoubleClick \u2013 Generate press events on double clicks too ImGuiSelectableFlags_Disabled \u2013 Cannot be selected, display grayed out text","title":"Flags for ImGui::Selectable()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguibegincombo","text":"ImGuiComboFlags_None \u2013 undefined ImGuiComboFlags_PopupAlignLeft \u2013 Align the popup toward the left by default ImGuiComboFlags_HeightSmall \u2013 Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo() ImGuiComboFlags_HeightRegular \u2013 Max ~8 items visible (default) ImGuiComboFlags_HeightLarge \u2013 Max ~20 items visible ImGuiComboFlags_HeightLargest \u2013 As many fitting items as possible ImGuiComboFlags_NoArrowButton \u2013 Display on the preview box without the square arrow button ImGuiComboFlags_NoPreview \u2013 Display only a square arrow button","title":"Flags for ImGui::BeginCombo()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguibegintabbar","text":"ImGuiTabBarFlags_None \u2013 undefined ImGuiTabBarFlags_Reorderable \u2013 Allow manually dragging tabs to re-order them + New tabs are appended at the end of list ImGuiTabBarFlags_AutoSelectNewTabs \u2013 Automatically select new tabs when they appear ImGuiTabBarFlags_TabListPopupButton \u2013 Disable buttons to open the tab list popup ImGuiTabBarFlags_NoCloseWithMiddleMouseButton \u2013 Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false. ImGuiTabBarFlags_NoTabListScrollingButtons \u2013 Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll) ImGuiTabBarFlags_NoTooltip \u2013 Disable tooltips when hovering a tab ImGuiTabBarFlags_FittingPolicyResizeDown \u2013 Resize tabs when they don't fit ImGuiTabBarFlags_FittingPolicyScroll \u2013 Add scroll buttons when tabs don't fit ImGuiTabBarFlags_FittingPolicyMask_ \u2013 undefined","title":"Flags for ImGui::BeginTabBar()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguibegintabitem","text":"ImGuiTabItemFlags_None \u2013 undefined ImGuiTabItemFlags_UnsavedDocument \u2013 Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker. ImGuiTabItemFlags_SetSelected \u2013 Trigger flag to programmatically make the tab selected when calling BeginTabItem() ImGuiTabItemFlags_NoCloseWithMiddleMouseButton \u2013 Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.","title":"Flags for ImGui::BeginTabItem()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguiiswindowfocused","text":"ImGuiFocusedFlags_None \u2013 undefined ImGuiFocusedFlags_ChildWindows \u2013 IsWindowFocused(): Return true if any children of the window is focused ImGuiFocusedFlags_RootWindow \u2013 IsWindowFocused(): Test from root window (top most parent of the current hierarchy) ImGuiFocusedFlags_AnyWindow \u2013 IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!","title":"Flags for ImGui::IsWindowFocused()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguiisitemhovered-imguiiswindowhovered","text":"Note: if you are trying to check whether your mouse should be dispatched to Dear ImGui or to your app, you should use 'io.WantCaptureMouse' instead! Please read the FAQ! Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls. ImGuiHoveredFlags_None \u2013 Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them. ImGuiHoveredFlags_ChildWindows \u2013 IsWindowHovered() only: Return true if any children of the window is hovered ImGuiHoveredFlags_RootWindow \u2013 IsWindowHovered() only: Test from root window (top most parent of the current hierarchy) ImGuiHoveredFlags_AnyWindow \u2013 IsWindowHovered() only: Return true if any window is hovered ImGuiHoveredFlags_AllowWhenBlockedByPopup \u2013 Return true even if a popup window is normally blocking access to this item/window ImGuiHoveredFlags_AllowWhenBlockedByModal \u2013 Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet. ImGuiHoveredFlags_AllowWhenBlockedByActiveItem \u2013 Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns. ImGuiHoveredFlags_AllowWhenOverlapped \u2013 Return true even if the position is obstructed or overlapped by another window ImGuiHoveredFlags_AllowWhenDisabled \u2013 Return true even if the item is disabled ImGuiHoveredFlags_RectOnly \u2013 undefined","title":"Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()"},{"location":"api-imgui/Flags---Enumerations/#flags-for-imguibegindragdropsource-imguiacceptdragdroppayload","text":"ImGuiDragDropFlags_None \u2013 undefined ImGuiDragDropFlags_SourceNoPreviewTooltip \u2013 By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior. ImGuiDragDropFlags_SourceNoDisableHover \u2013 By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item. ImGuiDragDropFlags_SourceNoHoldToOpenOthers \u2013 Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item. ImGuiDragDropFlags_SourceAllowNullID \u2013 Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit. ImGuiDragDropFlags_SourceExtern \u2013 External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously. ImGuiDragDropFlags_SourceAutoExpirePayload \u2013 Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged) ImGuiDragDropFlags_AcceptBeforeDelivery \u2013 AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered. ImGuiDragDropFlags_AcceptNoDrawDefaultRect \u2013 Do not draw the default highlight rectangle when hovering over target. ImGuiDragDropFlags_AcceptNoPreviewTooltip \u2013 Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.","title":"Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()"},{"location":"api-imgui/Flags---Enumerations/#standard-drag-and-drop-payload-types-you-can-define-you-own-payload-types-using-short-strings-types-starting-with-_-are-defined-by-dear-imgui","text":"","title":"Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui."},{"location":"api-imgui/Flags---Enumerations/#a-primary-data-type","text":"ImGuiDataType_S8 \u2013 signed char / char (with sensible compilers) ImGuiDataType_U8 \u2013 unsigned char ImGuiDataType_S16 \u2013 short ImGuiDataType_U16 \u2013 unsigned short ImGuiDataType_S32 \u2013 int ImGuiDataType_U32 \u2013 unsigned int ImGuiDataType_S64 \u2013 long long / __int64 ImGuiDataType_U64 \u2013 unsigned long long / unsigned __int64 ImGuiDataType_Float \u2013 float ImGuiDataType_Double \u2013 double","title":"A primary data type"},{"location":"api-imgui/Flags---Enumerations/#a-cardinal-direction","text":"ImGuiDir_None \u2013 undefined ImGuiDir_Left \u2013 undefined ImGuiDir_Right \u2013 undefined ImGuiDir_Up \u2013 undefined ImGuiDir_Down \u2013 undefined","title":"A cardinal direction"},{"location":"api-imgui/Flags---Enumerations/#user-fill-imguiiokeymap-array-with-indices-into-the-imguiiokeysdown512-array","text":"ImGuiKey_Tab \u2013 undefined ImGuiKey_LeftArrow \u2013 undefined ImGuiKey_RightArrow \u2013 undefined ImGuiKey_UpArrow \u2013 undefined ImGuiKey_DownArrow \u2013 undefined ImGuiKey_PageUp \u2013 undefined ImGuiKey_PageDown \u2013 undefined ImGuiKey_Home \u2013 undefined ImGuiKey_End \u2013 undefined ImGuiKey_Insert \u2013 undefined ImGuiKey_Delete \u2013 undefined ImGuiKey_Backspace \u2013 undefined ImGuiKey_Space \u2013 undefined ImGuiKey_Enter \u2013 undefined ImGuiKey_Escape \u2013 undefined ImGuiKey_KeyPadEnter \u2013 undefined ImGuiKey_A \u2013 for text edit CTRL+A: select all ImGuiKey_C \u2013 for text edit CTRL+C: copy ImGuiKey_V \u2013 for text edit CTRL+V: paste ImGuiKey_X \u2013 for text edit CTRL+X: cut ImGuiKey_Y \u2013 for text edit CTRL+Y: redo ImGuiKey_Z \u2013 for text edit CTRL+Z: undo","title":"User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array"},{"location":"api-imgui/Flags---Enumerations/#to-test-iokeymods-which-is-a-combination-of-individual-fields-iokeyctrl-iokeyshift-iokeyalt-set-by-userback-end","text":"ImGuiKeyModFlags_None \u2013 undefined ImGuiKeyModFlags_Ctrl \u2013 undefined ImGuiKeyModFlags_Shift \u2013 undefined ImGuiKeyModFlags_Alt \u2013 undefined","title":"To test io.KeyMods (which is a combination of individual fields io.KeyCtrl, io.KeyShift, io.KeyAlt set by user/back-end)"},{"location":"api-imgui/Flags---Enumerations/#gamepadkeyboard-navigation","text":"XXXKeyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] and io.KeyMap[] arrays. Gamepad: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame() . Note that io.NavInputs[] is cleared by EndFrame() . Read instructions in imgui.cpp for more details. Download PNG/PSD at http:goo.gl/9LgVZW. ImGuiNavInput_Activate \u2013 activate / open / toggle / tweak value // e.g. Cross (PS4), A (Xbox), A (Switch), Space (Keyboard) ImGuiNavInput_Cancel \u2013 cancel / close / exit // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard) ImGuiNavInput_Input \u2013 text input / on-screen keyboard // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard) ImGuiNavInput_Menu \u2013 tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard) ImGuiNavInput_DpadLeft \u2013 move / tweak / resize window (w/ PadMenu) // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard) ImGuiNavInput_DpadRight \u2013 ImGuiNavInput_DpadUp, // ImGuiNavInput_DpadDown \u2013 ImGuiNavInput_LStickLeft, // scroll / move window (w/ PadMenu) // e.g. Left Analog Stick Left/Right/Up/Down ImGuiNavInput_LStickRight \u2013 ImGuiNavInput_LStickUp, // ImGuiNavInput_LStickDown \u2013 ImGuiNavInput_FocusPrev, // next window (w/ PadMenu) // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch) ImGuiNavInput_FocusNext \u2013 prev window (w/ PadMenu) // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch) ImGuiNavInput_TweakSlow \u2013 slower tweaks // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch) ImGuiNavInput_TweakFast \u2013 faster tweaks // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch) ImGuiNavInput_KeyMenu_ \u2013 toggle menu // = io.KeyAlt ImGuiNavInput_KeyLeft_ \u2013 move left // = Arrow keys ImGuiNavInput_KeyRight_ \u2013 move right ImGuiNavInput_KeyUp_ \u2013 move up ImGuiNavInput_KeyDown_ \u2013 move down ImGuiNavInput_COUNT \u2013 undefined","title":"Gamepad/Keyboard navigation"},{"location":"api-imgui/Flags---Enumerations/#configuration-flags-stored-in-ioconfigflags-set-by-userapplication","text":"ImGuiConfigFlags_None \u2013 undefined ImGuiConfigFlags_NavEnableKeyboard \u2013 Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[]. ImGuiConfigFlags_NavEnableGamepad \u2013 Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad. ImGuiConfigFlags_NavEnableSetMousePos \u2013 Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth. ImGuiConfigFlags_NavNoCaptureKeyboard \u2013 Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set. ImGuiConfigFlags_NoMouse \u2013 Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end. ImGuiConfigFlags_NoMouseCursorChange \u2013 Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead. ImGuiConfigFlags_IsSRGB \u2013 Application is SRGB-aware.","title":"Configuration flags stored in io.ConfigFlags. Set by user/application."},{"location":"api-imgui/Flags---Enumerations/#back-end-capabilities-flags-stored-in-iobackendflags-set-by-imgui_impl_xxx-or-custom-back-end","text":"ImGuiBackendFlags_None \u2013 undefined ImGuiBackendFlags_HasGamepad \u2013 Back-end Platform supports gamepad and currently has one connected. ImGuiBackendFlags_HasMouseCursors \u2013 Back-end Platform supports honoring GetMouseCursor() value to change the OS cursor shape. ImGuiBackendFlags_HasSetMousePos \u2013 Back-end Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).","title":"Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end."},{"location":"api-imgui/Flags---Enumerations/#enumeration-for-pushstylecolor-popstylecolor","text":"ImGuiCol_Text \u2013 undefined ImGuiCol_TextDisabled \u2013 undefined ImGuiCol_WindowBg \u2013 Background of normal windows ImGuiCol_ChildBg \u2013 Background of child windows ImGuiCol_PopupBg \u2013 Background of popups, menus, tooltips windows ImGuiCol_Border \u2013 undefined ImGuiCol_BorderShadow \u2013 undefined ImGuiCol_FrameBg \u2013 Background of checkbox, radio button, plot, slider, text input ImGuiCol_FrameBgHovered \u2013 undefined ImGuiCol_FrameBgActive \u2013 undefined ImGuiCol_TitleBg \u2013 undefined ImGuiCol_TitleBgActive \u2013 undefined ImGuiCol_TitleBgCollapsed \u2013 undefined ImGuiCol_MenuBarBg \u2013 undefined ImGuiCol_ScrollbarBg \u2013 undefined ImGuiCol_ScrollbarGrab \u2013 undefined ImGuiCol_ScrollbarGrabHovered \u2013 undefined ImGuiCol_ScrollbarGrabActive \u2013 undefined ImGuiCol_CheckMark \u2013 undefined ImGuiCol_SliderGrab \u2013 undefined ImGuiCol_SliderGrabActive \u2013 undefined ImGuiCol_Button \u2013 undefined ImGuiCol_ButtonHovered \u2013 undefined ImGuiCol_ButtonActive \u2013 undefined ImGuiCol_Header \u2013 Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem ImGuiCol_HeaderHovered \u2013 undefined ImGuiCol_HeaderActive \u2013 undefined ImGuiCol_Separator \u2013 undefined ImGuiCol_SeparatorHovered \u2013 undefined ImGuiCol_SeparatorActive \u2013 undefined ImGuiCol_ResizeGrip \u2013 undefined ImGuiCol_ResizeGripHovered \u2013 undefined ImGuiCol_ResizeGripActive \u2013 undefined ImGuiCol_Tab \u2013 undefined ImGuiCol_TabHovered \u2013 undefined ImGuiCol_TabActive \u2013 undefined ImGuiCol_TabUnfocused \u2013 undefined ImGuiCol_TabUnfocusedActive \u2013 undefined ImGuiCol_PlotLines \u2013 undefined ImGuiCol_PlotLinesHovered \u2013 undefined ImGuiCol_PlotHistogram \u2013 undefined ImGuiCol_PlotHistogramHovered \u2013 undefined ImGuiCol_TextSelectedBg \u2013 undefined ImGuiCol_DragDropTarget \u2013 undefined ImGuiCol_NavHighlight \u2013 Gamepad/keyboard: current highlighted item ImGuiCol_NavWindowingHighlight \u2013 Highlight window when using CTRL+TAB ImGuiCol_NavWindowingDimBg \u2013 Darken/colorize entire screen behind the CTRL+TAB window list, when active ImGuiCol_ModalWindowDimBg \u2013 Darken/colorize entire screen behind a modal window, when one is active","title":"Enumeration for PushStyleColor() / PopStyleColor()"},{"location":"api-imgui/Flags---Enumerations/#enumeration-for-pushstylevar-popstylevar-to-temporarily-modify-the-imguistyle-structure","text":"The enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization or between frames, feel free to just poke into ImGuiStyle directly. Tip: Use your programming IDE navigation facilities on the names in the second column below to find the actual members and their description. In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot. With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments. When changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type. ImGuiStyleVar_Alpha \u2013 float Alpha ImGuiStyleVar_WindowPadding \u2013 ImVec2 WindowPadding ImGuiStyleVar_WindowRounding \u2013 float WindowRounding ImGuiStyleVar_WindowBorderSize \u2013 float WindowBorderSize ImGuiStyleVar_WindowMinSize \u2013 ImVec2 WindowMinSize ImGuiStyleVar_WindowTitleAlign \u2013 ImVec2 WindowTitleAlign ImGuiStyleVar_ChildRounding \u2013 float ChildRounding ImGuiStyleVar_ChildBorderSize \u2013 float ChildBorderSize ImGuiStyleVar_PopupRounding \u2013 float PopupRounding ImGuiStyleVar_PopupBorderSize \u2013 float PopupBorderSize ImGuiStyleVar_FramePadding \u2013 ImVec2 FramePadding ImGuiStyleVar_FrameRounding \u2013 float FrameRounding ImGuiStyleVar_FrameBorderSize \u2013 float FrameBorderSize ImGuiStyleVar_ItemSpacing \u2013 ImVec2 ItemSpacing ImGuiStyleVar_ItemInnerSpacing \u2013 ImVec2 ItemInnerSpacing ImGuiStyleVar_IndentSpacing \u2013 float IndentSpacing ImGuiStyleVar_ScrollbarSize \u2013 float ScrollbarSize ImGuiStyleVar_ScrollbarRounding \u2013 float ScrollbarRounding ImGuiStyleVar_GrabMinSize \u2013 float GrabMinSize ImGuiStyleVar_GrabRounding \u2013 float GrabRounding ImGuiStyleVar_TabRounding \u2013 float TabRounding ImGuiStyleVar_ButtonTextAlign \u2013 ImVec2 ButtonTextAlign ImGuiStyleVar_SelectableTextAlign \u2013 ImVec2 SelectableTextAlign","title":"Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure."},{"location":"api-imgui/Flags---Enumerations/#flags-for-coloredit3-coloredit4-colorpicker3-colorpicker4-colorbutton","text":"ImGuiColorEditFlags_None \u2013 undefined ImGuiColorEditFlags_NoAlpha \u2013 // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer). ImGuiColorEditFlags_NoPicker \u2013 // ColorEdit: disable picker when clicking on colored square. ImGuiColorEditFlags_NoOptions \u2013 // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview. ImGuiColorEditFlags_NoSmallPreview \u2013 // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs) ImGuiColorEditFlags_NoInputs \u2013 // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square). ImGuiColorEditFlags_NoTooltip \u2013 // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview. ImGuiColorEditFlags_NoLabel \u2013 // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker). ImGuiColorEditFlags_NoSidePreview \u2013 // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead. ImGuiColorEditFlags_NoDragDrop \u2013 // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source. ImGuiColorEditFlags_NoBorder \u2013 // ColorButton: disable border (which is enforced by default) ImGuiColorEditFlags_AlphaBar \u2013 // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker. ImGuiColorEditFlags_AlphaPreview \u2013 // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque. 18 \u2013 // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque. ImGuiColorEditFlags_HDR \u2013 // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well). ImGuiColorEditFlags_DisplayRGB \u2013 [Display] // ColorEdit: override display type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex. ImGuiColorEditFlags_DisplayHSV \u2013 [Display] // \" ImGuiColorEditFlags_DisplayHex \u2013 [Display] // \" ImGuiColorEditFlags_Uint8 \u2013 [DataType] // ColorEdit, ColorPicker, ColorButton: display values formatted as 0..255. ImGuiColorEditFlags_Float \u2013 [DataType] // ColorEdit, ColorPicker, ColorButton: display values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers. ImGuiColorEditFlags_PickerHueBar \u2013 [Picker] // ColorPicker: bar for Hue, rectangle for Sat/Value. ImGuiColorEditFlags_PickerHueWheel \u2013 [Picker] // ColorPicker: wheel for Hue, triangle for Sat/Value. ImGuiColorEditFlags_InputRGB \u2013 [Input] // ColorEdit, ColorPicker: input and output data in RGB format. ImGuiColorEditFlags_InputHSV \u2013 [Input] // ColorEdit, ColorPicker: input and output data in HSV format. ImGuiColorEditFlags__OptionsDefault \u2013 undefined ImGuiColorEditFlags__DisplayMask \u2013 undefined ImGuiColorEditFlags__DataTypeMask \u2013 undefined ImGuiColorEditFlags__PickerMask \u2013 undefined","title":"Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()"},{"location":"api-imgui/Flags---Enumerations/#identify-a-mouse-button","text":"Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience. ImGuiMouseButton_Left \u2013 undefined ImGuiMouseButton_Right \u2013 undefined ImGuiMouseButton_Middle \u2013 undefined","title":"Identify a mouse button."},{"location":"api-imgui/Flags---Enumerations/#enumeration-for-getmousecursor","text":"User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here ImGuiMouseCursor_None \u2013 undefined ImGuiMouseCursor_Arrow \u2013 undefined ImGuiMouseCursor_TextInput \u2013 When hovering over InputText, etc. ImGuiMouseCursor_ResizeAll \u2013 (Unused by Dear ImGui functions) ImGuiMouseCursor_ResizeNS \u2013 When hovering over an horizontal border ImGuiMouseCursor_ResizeEW \u2013 When hovering over a vertical border or a column ImGuiMouseCursor_ResizeNESW \u2013 When hovering over the bottom-left corner of a window ImGuiMouseCursor_ResizeNWSE \u2013 When hovering over the bottom-right corner of a window ImGuiMouseCursor_Hand \u2013 (Unused by Dear ImGui functions. Use for e.g. hyperlinks) ImGuiMouseCursor_NotAllowed \u2013 When hovering something with disallowed interaction. Usually a crossed circle.","title":"Enumeration for GetMouseCursor()"},{"location":"api-imgui/Flags---Enumerations/#enumeration-for-imguisetwindow-setnextwindow-setnextitem-functions","text":"Represent a condition. Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always. ImGuiCond_Always \u2013 Set the variable ImGuiCond_Once \u2013 Set the variable once per runtime session (only the first call will succeed) ImGuiCond_FirstUseEver \u2013 Set the variable if the object/window has no persistently saved data (no entry in .ini file)","title":"Enumeration for ImGui::SetWindow***(), SetNextWindow***(), SetNextItem***() functions"},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/","text":"Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont) \u00b6 Hold rendering data for one glyph. \u00b6 (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this) Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges(). \u00b6 This is essentially a tightly packed of vector of 64k booleans = 8KB storage. See ImFontAtlas::AddCustomRectXXX functions. \u00b6 ImFontAtlasFlags_None \u2013 undefined ImFontAtlasFlags_NoPowerOfTwoHeight \u2013 Don't round the height to next power of two Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding: \u00b6 One or more fonts. Custom graphics data needed to render the shapes needed by Dear ImGui. Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas). It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api. Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you. Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data. Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples) Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API. This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details. Common pitfalls: If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data. Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction. You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed, Even though many functions are suffixed with \"TTF\", OTF data is supported just as well. This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future! Font runtime data and rendering \u00b6 ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32(). Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h) \u00b6","title":"Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)"},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#font-api-imfontconfig-imfontglyph-imfontatlasflags-imfontatlas-imfontglyphrangesbuilder-imfont","text":"","title":"Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)"},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#hold-rendering-data-for-one-glyph","text":"(Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)","title":"Hold rendering data for one glyph."},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#helper-to-build-glyph-ranges-from-textstring-data-feed-your-application-stringscharacters-to-it-then-call-buildranges","text":"This is essentially a tightly packed of vector of 64k booleans = 8KB storage.","title":"Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges()."},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#see-imfontatlasaddcustomrectxxx-functions","text":"ImFontAtlasFlags_None \u2013 undefined ImFontAtlasFlags_NoPowerOfTwoHeight \u2013 Don't round the height to next power of two","title":"See ImFontAtlas::AddCustomRectXXX functions."},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#load-and-rasterize-multiple-ttfotf-fonts-into-a-same-texture-the-font-atlas-will-build-a-single-texture-holding","text":"One or more fonts. Custom graphics data needed to render the shapes needed by Dear ImGui. Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas). It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api. Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you. Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data. Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples) Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API. This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details. Common pitfalls: If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data. Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction. You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed, Even though many functions are suffixed with \"TTF\", OTF data is supported just as well. This is an old API and it is currently awkward for those and and various other reasons! We will address them in the future!","title":"Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:"},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#font-runtime-data-and-rendering","text":"ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().","title":"Font runtime data and rendering"},{"location":"api-imgui/Font-API--ImFontConfig--ImFontGlyph-/#include-imgui_userh-at-the-end-of-imguih-convenient-for-user-to-only-explicitly-include-vanilla-imguih","text":"","title":"Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)"},{"location":"api-imgui/Forward-declarations-and-basic/","text":"Forward declarations and basic types \u00b6 Forward declarations \u00b6 Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file) \u00b6 Tip: Use your programming IDE navigation facilities on the names in the central column below to find the actual flags/enum lists! In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot. With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments. Other types \u00b6 Decoded character types \u00b6 (we generally use UTF-8 encoded string in the API. This is storage specifically for a decoded character used for keyboard input and display) Basic scalar data types \u00b6 2D vector (often used to store positions or sizes) \u00b6 4D vector (often used to store floating-point colors) \u00b6","title":"API Forward"},{"location":"api-imgui/Forward-declarations-and-basic/#forward-declarations-and-basic-types","text":"","title":"Forward declarations and basic types"},{"location":"api-imgui/Forward-declarations-and-basic/#forward-declarations","text":"","title":"Forward declarations"},{"location":"api-imgui/Forward-declarations-and-basic/#enumsflags-declared-as-int-for-compatibility-with-old-c-to-allow-using-as-flags-and-to-not-pollute-the-top-of-this-file","text":"Tip: Use your programming IDE navigation facilities on the names in the central column below to find the actual flags/enum lists! In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot. With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.","title":"Enums/Flags (declared as int for compatibility with old C++, to allow using as flags and to not pollute the top of this file)"},{"location":"api-imgui/Forward-declarations-and-basic/#other-types","text":"","title":"Other types"},{"location":"api-imgui/Forward-declarations-and-basic/#decoded-character-types","text":"(we generally use UTF-8 encoded string in the API. This is storage specifically for a decoded character used for keyboard input and display)","title":"Decoded character types"},{"location":"api-imgui/Forward-declarations-and-basic/#basic-scalar-data-types","text":"","title":"Basic scalar data types"},{"location":"api-imgui/Forward-declarations-and-basic/#2d-vector-often-used-to-store-positions-or-sizes","text":"","title":"2D vector (often used to store positions or sizes)"},{"location":"api-imgui/Forward-declarations-and-basic/#4d-vector-often-used-to-store-floating-point-colors","text":"","title":"4D vector (often used to store floating-point colors)"},{"location":"api-imgui/Header-mess/","text":"Header mess \u00b6 Includes \u00b6 Version \u00b6 (Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY99 then bounce up to XYY00, XYY01 etc. when release tagging happens) Define attributes of all API symbols declarations (e.g. for DLL under Windows) \u00b6 IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h) Using dear imgui via a shared library is not recommended, because we don't guarantee backward nor forward ABI compatibility (also function call overhead, as dear imgui is a call-heavy API) Helper Macros \u00b6 Warnings \u00b6","title":"API Header"},{"location":"api-imgui/Header-mess/#header-mess","text":"","title":"Header mess"},{"location":"api-imgui/Header-mess/#includes","text":"","title":"Includes"},{"location":"api-imgui/Header-mess/#version","text":"(Integer encoded as XYYZZ for use in #if preprocessor conditionals. Work in progress versions typically starts at XYY99 then bounce up to XYY00, XYY01 etc. when release tagging happens)","title":"Version"},{"location":"api-imgui/Header-mess/#define-attributes-of-all-api-symbols-declarations-eg-for-dll-under-windows","text":"IMGUI_API is used for core imgui functions, IMGUI_IMPL_API is used for the default bindings files (imgui_impl_xxx.h) Using dear imgui via a shared library is not recommended, because we don't guarantee backward nor forward ABI compatibility (also function call overhead, as dear imgui is a call-heavy API)","title":"Define attributes of all API symbols declarations (e.g. for DLL under Windows)"},{"location":"api-imgui/Header-mess/#helper-macros","text":"","title":"Helper Macros"},{"location":"api-imgui/Header-mess/#warnings","text":"","title":"Warnings"},{"location":"api-imgui/Helper--ImVector--/","text":"Helper: ImVector<> \u00b6 // Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug). - We use std-like naming convention here, which is a little unusual for this codebase. \u00b6 Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs. Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that, Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.","title":"Helper: ImVector<>"},{"location":"api-imgui/Helper--ImVector--/#helper-imvector","text":"// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).","title":"Helper: ImVector&lt;&gt;"},{"location":"api-imgui/Helper--ImVector--/#-we-use-std-like-naming-convention-here-which-is-a-little-unusual-for-this-codebase","text":"Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs. Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that, Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.","title":"- We use std-like naming convention here, which is a little unusual for this codebase."},{"location":"api-imgui/Helpers--Memory-allocations-macros/","text":"Helpers: Memory allocations macros \u00b6 // IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() // We call C++ constructor on own allocated memory via the placement \"new(ptr) Type()\" syntax. // Defining a custom placement new() with a dummy parameter allows us to bypass including which on some platforms complains when user has disabled exceptions.","title":"Helpers: Memory allocations macros"},{"location":"api-imgui/Helpers--Memory-allocations-macros/#helpers-memory-allocations-macros","text":"// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() // We call C++ constructor on own allocated memory via the placement \"new(ptr) Type()\" syntax. // Defining a custom placement new() with a dummy parameter allows us to bypass including which on some platforms complains when user has disabled exceptions.","title":"Helpers: Memory allocations macros"},{"location":"api-imgui/Helpers/","text":"Helpers \u00b6 Helper: Unicode defines \u00b6 Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame. \u00b6 Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\"); Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\" \u00b6 Helper: Growable text buffer for logging/accumulating text \u00b6 (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder') Helper: Key->Value storage \u00b6 Typically you don't have to worry about this since a storage is held within each Window. We use it to e.g. store collapse state for a tree (Int 0/1) This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame) You can use it as custom user storage for temporary values. Declare your own storage if, for example: - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state). - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient) Types are NOT stored, so it is up to you to make sure your Key don't collide with different types. Helper: Manually clip large list of items. \u00b6 If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all. The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped. ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null. Usage: ImGuiListClipper clipper(1000); we have 1000 elements, evenly spaced. while (clipper.Step()) for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++) ImGui::Text(\"line number %d\", i); - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor). - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element. - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.) - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop. Helpers macros to generate 32-bit encoded colors \u00b6 Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float) \u00b6 Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API. **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE. **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.","title":"Helpers"},{"location":"api-imgui/Helpers/#helpers","text":"","title":"Helpers"},{"location":"api-imgui/Helpers/#helper-unicode-defines","text":"","title":"Helper: Unicode defines"},{"location":"api-imgui/Helpers/#helper-execute-a-block-of-code-at-maximum-once-a-frame-convenient-if-you-want-to-quickly-create-an-ui-within-deep-nested-code-that-runs-multiple-times-every-frame","text":"Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text(\"This will be called only once per frame\");","title":"Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame."},{"location":"api-imgui/Helpers/#helper-parse-and-apply-text-filters-in-format-aaaaabbbbccccc","text":"","title":"Helper: Parse and apply text filters. In format \"aaaaa[,bbbb][,ccccc]\""},{"location":"api-imgui/Helpers/#helper-growable-text-buffer-for-loggingaccumulating-text","text":"(this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')","title":"Helper: Growable text buffer for logging/accumulating text"},{"location":"api-imgui/Helpers/#helper-key-value-storage","text":"Typically you don't have to worry about this since a storage is held within each Window. We use it to e.g. store collapse state for a tree (Int 0/1) This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame) You can use it as custom user storage for temporary values. Declare your own storage if, for example: - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state). - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient) Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.","title":"Helper: Key-&gt;Value storage"},{"location":"api-imgui/Helpers/#helper-manually-clip-large-list-of-items","text":"If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all. The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped. ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null. Usage: ImGuiListClipper clipper(1000); we have 1000 elements, evenly spaced. while (clipper.Step()) for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++) ImGui::Text(\"line number %d\", i); - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor). - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element. - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.) - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.","title":"Helper: Manually clip large list of items."},{"location":"api-imgui/Helpers/#helpers-macros-to-generate-32-bit-encoded-colors","text":"","title":"Helpers macros to generate 32-bit encoded colors"},{"location":"api-imgui/Helpers/#helper-imcolor-implicitly-converts-colors-to-either-imu32-packed-4x1-byte-or-imvec4-4x1-float","text":"Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API. **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE. **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.","title":"Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/","text":"ImGui: Dear ImGui end-user API \u00b6 // (This is a namespace. You can add extra ImGui:: functions in your own separate file. Please don't modify imgui source files!) Context creation and access \u00b6 Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts. None of those functions is reliant on the current context. CreateContext(...) ImGuiContext * CreateContext ( ImFontAtlas * shared_font_atlas = NULL ) DestroyContext(...) NULL = destroy current context void DestroyContext ( ImGuiContext * ctx = NULL ) GetCurrentContext() ImGuiContext * GetCurrentContext () SetCurrentContext(...) void SetCurrentContext ( ImGuiContext * ctx ) Main \u00b6 GetIO() access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags) ImGuiIO & GetIO () GetStyle() access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame! ImGuiStyle & GetStyle () NewFrame() start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame(). void NewFrame () EndFrame() ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all! void EndFrame () Render() ends the Dear ImGui frame, finalize the draw data. You can get call GetDrawData() to obtain it and run your rendering function (up to v1.60, this used to call io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your render function yourself.) void Render () GetDrawData() valid after Render() and until the next call to NewFrame(). this is what you have to render. ImDrawData * GetDrawData () Demo, Debug, Information \u00b6 ShowDemoWindow(...) create Demo window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application! void ShowDemoWindow ( bool * p_open = NULL ) ShowAboutWindow(...) create About window. display Dear ImGui version, credits and build/system information. void ShowAboutWindow ( bool * p_open = NULL ) ShowMetricsWindow(...) create Debug/Metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc. void ShowMetricsWindow ( bool * p_open = NULL ) ShowStyleEditor(...) add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style) void ShowStyleEditor ( ImGuiStyle * ref = NULL ) ShowStyleSelector(...) add style selector block (not a window), essentially a combo listing the default styles. bool ShowStyleSelector ( const char * label ) ShowFontSelector(...) add font selector block (not a window), essentially a combo listing the loaded fonts. void ShowFontSelector ( const char * label ) ShowUserGuide() add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls). void ShowUserGuide () Styles \u00b6 StyleColorsDark(...) new, recommended style (default) void StyleColorsDark ( ImGuiStyle * dst = NULL ) StyleColorsClassic(...) classic imgui style void StyleColorsClassic ( ImGuiStyle * dst = NULL ) StyleColorsLight(...) best used with borders and a custom, thicker font void StyleColorsLight ( ImGuiStyle * dst = NULL ) Windows \u00b6 Begin() = push window to the stack and start appending to it. End() = pop window from the stack. You may append multiple times to the same window during the same frame. Passing bool* p_open != NULL shows a window-closing widget in the upper-right corner of the window, which clicking will set the boolean to false when clicked. Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window. Always call a matching End() for each Begin() call, regardless of its return value! [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu / EndMenu , BeginPopup / EndPopup , etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.] Note that the bottom of window stack always contains a window called \"Debug\". Begin(...) bool Begin ( const char * name , bool * p_open = NULL , ImGuiWindowFlags flags = 0 ) End() void End () Child Windows \u00b6 Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child. For each independent axis of size : == 0.0f -> use remaining host window size > 0.0f -> fixed size < 0.0f -> use remaining window size minus abs(size) Each axis can use a different mode, e.g. ImVec2(0,400) . BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window. Tip Always call a matching EndChild() for each BeginChild() call, regardless of its return value [as with Begin : this is due to legacy reason and inconsistent with most BeginXXX functions apart from the regular Begin() which behaves like BeginChild() .] BeginChild(...) bool BeginChild ( const char * str_id , const ImVec2 & size = ImVec2 ( 0 , 0 ), bool border = false , ImGuiWindowFlags flags = 0 ) BeginChild(...) bool BeginChild ( ImGuiID id , const ImVec2 & size = ImVec2 ( 0 , 0 ), bool border = false , ImGuiWindowFlags flags = 0 ) EndChild() void EndChild () Windows Utilities \u00b6 Current window = the window we are appending into while inside a Begin() / End() block. Next window = next window we will Begin() into. IsWindowAppearing() bool IsWindowAppearing () IsWindowCollapsed() bool IsWindowCollapsed () IsWindowFocused(...) is current window focused? Or its root/child, depending on flags. See flags for options. bool IsWindowFocused ( ImGuiFocusedFlags flags = 0 ) IsWindowHovered(...) is current window hovered (and typically: not blocked by a popup/modal)? See flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ! bool IsWindowHovered ( ImGuiHoveredFlags flags = 0 ) GetWindowDrawList() get draw list associated to the current window , to append your own drawing primitives ImDrawList * GetWindowDrawList () GetWindowPos() get current window position in screen space (useful if you want to do your own drawing via the DrawList API) ImVec2 GetWindowPos () GetWindowSize() get current window size ImVec2 GetWindowSize () GetWindowWidth() get current window width (shortcut for GetWindowSize().x ) float GetWindowWidth () GetWindowHeight() get current window height (shortcut for GetWindowSize().y ) float GetWindowHeight () Next Window Utilities \u00b6 Prefer using SetNextXXX functions (before Begin ) rather than SetXXX functions (after Begin() ). SetNextWindowPos(...) set next window position. Call before Begin(). Use pivot=(0.5f,0.5f) to center on given point, etc. void SetNextWindowPos ( const ImVec2 & pos , ImGuiCond cond = 0 , const ImVec2 & pivot = ImVec2 ( 0 , 0 )) SetNextWindowSize(...) set next window size. Set axis to 0.0f to force an auto-fit on this axis. Call before Begin() . void SetNextWindowSize ( const ImVec2 & size , ImGuiCond cond = 0 ) SetNextWindowSizeConstraints(...) set next window size limits. Use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints. void SetNextWindowSizeConstraints ( const ImVec2 & size_min , const ImVec2 & size_max , ImGuiSizeCallback custom_callback = NULL , void * custom_callback_data = NULL ) SetNextWindowContentSize(...) set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding . Set an axis to 0.0f to leave it automatic. Call before Begin() void SetNextWindowContentSize ( const ImVec2 & size ) SetNextWindowCollapsed(...) set next window collapsed state. Call before Begin() void SetNextWindowCollapsed ( bool collapsed , ImGuiCond cond = 0 ) SetNextWindowFocus() set next window to be focused / top-most. Call before Begin() void SetNextWindowFocus () SetNextWindowBgAlpha(...) set next window background color alpha. Helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. You may also use ImGuiWindowFlags_NoBackground. void SetNextWindowBgAlpha ( float alpha ) SetWindowPos(...) (not recommended) set current window position - call within Begin() / End() . Prefer using SetNextWindowPos(), as this may incur tearing and side-effects. void SetWindowPos ( const ImVec2 & pos , ImGuiCond cond = 0 ) SetWindowSize(...) (not recommended) set current window size - call within Begin()/End(). Set to ImVec2(0,0) to force an auto-fit. Prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects. void SetWindowSize ( const ImVec2 & size , ImGuiCond cond = 0 ) SetWindowCollapsed(...) (not recommended) set current window collapsed state. Prefer using SetNextWindowCollapsed(). void SetWindowCollapsed ( bool collapsed , ImGuiCond cond = 0 ) SetWindowFocus() (not recommended) set current window to be focused / top-most. Prefer using SetNextWindowFocus(). void SetWindowFocus () SetWindowFontScale(...) set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes() . void SetWindowFontScale ( float scale ) SetWindowPos(...) set named window position. void SetWindowPos ( const char * name , const ImVec2 & pos , ImGuiCond cond = 0 ) SetWindowSize(...) set named window size. set axis to 0.0f to force an auto-fit on this axis. void SetWindowSize ( const char * name , const ImVec2 & size , ImGuiCond cond = 0 ) SetWindowCollapsed(...) set named window collapsed state void SetWindowCollapsed ( const char * name , bool collapsed , ImGuiCond cond = 0 ) SetWindowFocus(...) set named window to be focused / top-most. use NULL to remove focus. void SetWindowFocus ( const char * name ) Content region \u00b6 Those functions are bound to be redesigned soon (they are confusing, incomplete and return values in local window coordinates which increases confusion) GetContentRegionMax() current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates ImVec2 GetContentRegionMax () GetContentRegionAvail() == GetContentRegionMax() - GetCursorPos() ImVec2 GetContentRegionAvail () GetWindowContentRegionMin() content boundaries min (roughly (0,0)-Scroll), in window coordinates ImVec2 GetWindowContentRegionMin () GetWindowContentRegionMax() content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates ImVec2 GetWindowContentRegionMax () GetWindowContentRegionWidth() float GetWindowContentRegionWidth () Windows Scrolling \u00b6 GetScrollX() get scrolling amount [0..GetScrollMaxX()] float GetScrollX () GetScrollY() get scrolling amount [0..GetScrollMaxY()] float GetScrollY () GetScrollMaxX() get maximum scrolling amount ~~ ContentSize.X - WindowSize.X float GetScrollMaxX () GetScrollMaxY() get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y float GetScrollMaxY () SetScrollX(...) set scrolling amount [0..GetScrollMaxX()] void SetScrollX ( float scroll_x ) SetScrollY(...) set scrolling amount [0..GetScrollMaxY()] void SetScrollY ( float scroll_y ) SetScrollHereX(...) adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead. void SetScrollHereX ( float center_x_ratio = 0.5f ) SetScrollHereY(...) adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead. void SetScrollHereY ( float center_y_ratio = 0.5f ) SetScrollFromPosX(...) adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position. void SetScrollFromPosX ( float local_x , float center_x_ratio = 0.5f ) SetScrollFromPosY(...) adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position. void SetScrollFromPosY ( float local_y , float center_y_ratio = 0.5f ) Parameters stacks (shared) \u00b6 PushFont(...) use NULL as a shortcut to push default font void PushFont ( ImFont * font ) PopFont() void PopFont () PushStyleColor(...) void PushStyleColor ( ImGuiCol idx , ImU32 col ) PushStyleColor(...) void PushStyleColor ( ImGuiCol idx , const ImVec4 & col ) PopStyleColor(...) void PopStyleColor ( int count = 1 ) PushStyleVar(...) void PushStyleVar ( ImGuiStyleVar idx , float val ) PushStyleVar(...) void PushStyleVar ( ImGuiStyleVar idx , const ImVec2 & val ) PopStyleVar(...) void PopStyleVar ( int count = 1 ) GetFont() get current font ImFont * GetFont () GetFontSize() get current font size (= height in pixels) of current font with current scale applied float GetFontSize () GetFontTexUvWhitePixel() get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API ImVec2 GetFontTexUvWhitePixel () GetColorU32(...) retrieve given style color with style alpha applied and optional extra alpha multiplier ImU32 GetColorU32 ( ImGuiCol idx , float alpha_mul = 1.0f ) GetColorU32(...) retrieve given color with style alpha applied ImU32 GetColorU32 ( const ImVec4 & col ) GetColorU32(...) retrieve given color with style alpha applied ImU32 GetColorU32 ( ImU32 col ) Parameters stacks (current window) \u00b6 PushItemWidth(...) push width of items for common large \"item+label\" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side). 0.0f = default to ~\u2154 of windows width, void PushItemWidth ( float item_width ) PopItemWidth() void PopItemWidth () SetNextItemWidth(...) set width of the next common large \"item+label\" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side) void SetNextItemWidth ( float item_width ) CalcItemWidth() width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions. float CalcItemWidth () PushTextWrapPos(...) push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space void PushTextWrapPos ( float wrap_local_pos_x = 0.0f ) PopTextWrapPos() void PopTextWrapPos () PushAllowKeyboardFocus(...) allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets void PushAllowKeyboardFocus ( bool allow_keyboard_focus ) PopAllowKeyboardFocus() void PopAllowKeyboardFocus () PushButtonRepeat(...) in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame. void PushButtonRepeat ( bool repeat ) PopButtonRepeat() void PopButtonRepeat () Cursor / Layout \u00b6 By \"cursor\" we mean the current output position. The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down. You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceeding widget. Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API: Window-local coordinates: SameLine(), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), GetContentRegionMax(), GetWindowContentRegion*(), PushTextWrapPos() Absolute coordinate: GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions. Separator() separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator. void Separator () SameLine(...) call between widgets or groups to layout them horizontally. X position given in window coordinates. void SameLine ( float offset_from_start_x = 0.0f , float spacing =- 1.0f ) NewLine() undo a SameLine() or force a new line when in an horizontal-layout context. void NewLine () Spacing() add vertical spacing. void Spacing () Dummy(...) add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into. void Dummy ( const ImVec2 & size ) Indent(...) move content position toward the right, by style.IndentSpacing or indent_w if != 0 void Indent ( float indent_w = 0.0f ) Unindent(...) move content position back to the left, by style.IndentSpacing or indent_w if != 0 void Unindent ( float indent_w = 0.0f ) BeginGroup() lock horizontal starting position void BeginGroup () EndGroup() unlock horizontal starting position + capture the whole group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.) void EndGroup () GetCursorPos() cursor position in window coordinates (relative to window position) ImVec2 GetCursorPos () GetCursorPosX() (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc. float GetCursorPosX () GetCursorPosY() other functions such as GetCursorScreenPos or everything in ImDrawList:: float GetCursorPosY () SetCursorPos(...) are using the main, absolute coordinate system. void SetCursorPos ( const ImVec2 & local_pos ) SetCursorPosX(...) GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.) void SetCursorPosX ( float local_x ) SetCursorPosY(...) void SetCursorPosY ( float local_y ) GetCursorStartPos() initial cursor position in window coordinates ImVec2 GetCursorStartPos () GetCursorScreenPos() cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API) ImVec2 GetCursorScreenPos () SetCursorScreenPos(...) cursor position in absolute screen coordinates [0..io.DisplaySize] void SetCursorScreenPos ( const ImVec2 & pos ) AlignTextToFramePadding() vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item) void AlignTextToFramePadding () GetTextLineHeight() ~ FontSize float GetTextLineHeight () GetTextLineHeightWithSpacing() ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text) float GetTextLineHeightWithSpacing () GetFrameHeight() ~ FontSize + style.FramePadding.y * 2 float GetFrameHeight () GetFrameHeightWithSpacing() ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets) float GetFrameHeightWithSpacing () ID stack/scopes \u00b6 Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them. The resulting ID are hashes of the entire stack. You can also use the \"Label##foobar\" syntax within widget label to distinguish them from each others. In this header file we use the \"label\"/\"name\" terminology to denote a string that will be displayed and used as an ID, whereas \"str_id\" denote a string that is only used as an ID and not normally displayed. PushID(...) push string into the ID stack (will hash string). void PushID ( const char * str_id ) PushID(...) push string into the ID stack (will hash string). void PushID ( const char * str_id_begin , const char * str_id_end ) PushID(...) push pointer into the ID stack (will hash pointer). void PushID ( const void * ptr_id ) PushID(...) push integer into the ID stack (will hash integer). void PushID ( int int_id ) PopID() pop from the ID stack. void PopID () GetID(...) calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself ImGuiID GetID ( const char * str_id ) GetID(...) ImGuiID GetID ( const char * str_id_begin , const char * str_id_end ) GetID(...) ImGuiID GetID ( const void * ptr_id ) Widgets: Text \u00b6 TextUnformatted(...) raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text. void TextUnformatted ( const char * text , const char * text_end = NULL ) Text(...) formatted text void Text ( const char * fmt , ...) IM_FMTARGS ( 1 ) TextV(...) void TextV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) TextColored(...) shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor(); void TextColored ( const ImVec4 & col , const char * fmt , ...) IM_FMTARGS ( 2 ) TextColoredV(...) void TextColoredV ( const ImVec4 & col , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) TextDisabled(...) shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor(); void TextDisabled ( const char * fmt , ...) IM_FMTARGS ( 1 ) TextDisabledV(...) void TextDisabledV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) TextWrapped(...) shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize(). void TextWrapped ( const char * fmt , ...) IM_FMTARGS ( 1 ) TextWrappedV(...) void TextWrappedV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) LabelText(...) display text+label aligned the same way as value+label widgets void LabelText ( const char * label , const char * fmt , ...) IM_FMTARGS ( 2 ) LabelTextV(...) void LabelTextV ( const char * label , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) BulletText(...) shortcut for Bullet()+Text() void BulletText ( const char * fmt , ...) IM_FMTARGS ( 1 ) BulletTextV(...) void BulletTextV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) Widgets: Main \u00b6 Most widgets return true when the value has been changed or when pressed/selected You may also use one of the many IsItemXXX functions (e.g. IsItemActive, IsItemHovered, etc.) to query widget state. Button(...) button bool Button ( const char * label , const ImVec2 & size = ImVec2 ( 0 , 0 )) SmallButton(...) button with FramePadding=(0,0) to easily embed within text bool SmallButton ( const char * label ) InvisibleButton(...) button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.) bool InvisibleButton ( const char * str_id , const ImVec2 & size ) ArrowButton(...) square button with an arrow shape bool ArrowButton ( const char * str_id , ImGuiDir dir ) Image(...) void Image ( ImTextureID user_texture_id , const ImVec2 & size , const ImVec2 & uv0 = ImVec2 ( 0 , 0 ), const ImVec2 & uv1 = ImVec2 ( 1 , 1 ), const ImVec4 & tint_col = ImVec4 ( 1 , 1 , 1 , 1 ), const ImVec4 & border_col = ImVec4 ( 0 , 0 , 0 , 0 )) ImageButton(...) <0 frame_padding uses default frame padding settings. 0 for no padding bool ImageButton ( ImTextureID user_texture_id , const ImVec2 & size , const ImVec2 & uv0 = ImVec2 ( 0 , 0 ), const ImVec2 & uv1 = ImVec2 ( 1 , 1 ), int frame_padding = - 1 , const ImVec4 & bg_col = ImVec4 ( 0 , 0 , 0 , 0 ), const ImVec4 & tint_col = ImVec4 ( 1 , 1 , 1 , 1 )) Checkbox(...) bool Checkbox ( const char * label , bool * v ) CheckboxFlags(...) bool CheckboxFlags ( const char * label , unsigned int * flags , unsigned int flags_value ) RadioButton(...) use with e.g. if (RadioButton(\"one\", my_value==1)) { my_value = 1; } bool RadioButton ( const char * label , bool active ) RadioButton(...) shortcut to handle the above pattern when value is an integer bool RadioButton ( const char * label , int * v , int v_button ) ProgressBar(...) void ProgressBar ( float fraction , const ImVec2 & size_arg = ImVec2 ( - 1 , 0 ), const char * overlay = NULL ) Bullet() draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses void Bullet () Widgets: Combo Box \u00b6 The BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items. The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose. BeginCombo(...) bool BeginCombo ( const char * label , const char * preview_value , ImGuiComboFlags flags = 0 ) EndCombo() only call EndCombo() if BeginCombo() returns true! void EndCombo () Combo(...) bool Combo ( const char * label , int * current_item , const char * const items [], int items_count , int popup_max_height_in_items = - 1 ) Combo(...) Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\" bool Combo ( const char * label , int * current_item , const char * items_separated_by_zeros , int popup_max_height_in_items = - 1 ) Combo(...) bool Combo ( const char * label , int * current_item , bool ( * items_getter )( void * data , int idx , const char ** out_text ), void * data , int items_count , int popup_max_height_in_items = - 1 ) Widgets: Drags \u00b6 CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds. For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc. Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision). Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click manual input can override those limits. Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum. Use v_min > v_max to lock edits. DragFloat(...) If v_min >= v_max we have no bound bool DragFloat ( const char * label , float * v , float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloat2(...) bool DragFloat2 ( const char * label , float v [ 2 ], float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloat3(...) bool DragFloat3 ( const char * label , float v [ 3 ], float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloat4(...) bool DragFloat4 ( const char * label , float v [ 4 ], float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloatRange2(...) bool DragFloatRange2 ( const char * label , float * v_current_min , float * v_current_max , float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , const char * format_max = NULL , float power = 1.0f ) DragInt(...) If v_min >= v_max we have no bound bool DragInt ( const char * label , int * v , float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragInt2(...) bool DragInt2 ( const char * label , int v [ 2 ], float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragInt3(...) bool DragInt3 ( const char * label , int v [ 3 ], float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragInt4(...) bool DragInt4 ( const char * label , int v [ 4 ], float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragIntRange2(...) bool DragIntRange2 ( const char * label , int * v_current_min , int * v_current_max , float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" , const char * format_max = NULL ) DragScalar(...) bool DragScalar ( const char * label , ImGuiDataType data_type , void * p_data , float v_speed , const void * p_min = NULL , const void * p_max = NULL , const char * format = NULL , float power = 1.0f ) DragScalarN(...) bool DragScalarN ( const char * label , ImGuiDataType data_type , void * p_data , int components , float v_speed , const void * p_min = NULL , const void * p_max = NULL , const char * format = NULL , float power = 1.0f ) Widgets: Sliders \u00b6 CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds. Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc. SliderFloat(...) adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders bool SliderFloat ( const char * label , float * v , float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderFloat2(...) bool SliderFloat2 ( const char * label , float v [ 2 ], float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderFloat3(...) bool SliderFloat3 ( const char * label , float v [ 3 ], float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderFloat4(...) bool SliderFloat4 ( const char * label , float v [ 4 ], float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderAngle(...) bool SliderAngle ( const char * label , float * v_rad , float v_degrees_min = - 360.0f , float v_degrees_max = + 360.0f , const char * format = \"%.0f deg\" ) SliderInt(...) bool SliderInt ( const char * label , int * v , int v_min , int v_max , const char * format = \"%d\" ) SliderInt2(...) bool SliderInt2 ( const char * label , int v [ 2 ], int v_min , int v_max , const char * format = \"%d\" ) SliderInt3(...) bool SliderInt3 ( const char * label , int v [ 3 ], int v_min , int v_max , const char * format = \"%d\" ) SliderInt4(...) bool SliderInt4 ( const char * label , int v [ 4 ], int v_min , int v_max , const char * format = \"%d\" ) SliderScalar(...) bool SliderScalar ( const char * label , ImGuiDataType data_type , void * p_data , const void * p_min , const void * p_max , const char * format = NULL , float power = 1.0f ) SliderScalarN(...) bool SliderScalarN ( const char * label , ImGuiDataType data_type , void * p_data , int components , const void * p_min , const void * p_max , const char * format = NULL , float power = 1.0f ) VSliderFloat(...) bool VSliderFloat ( const char * label , const ImVec2 & size , float * v , float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) VSliderInt(...) bool VSliderInt ( const char * label , const ImVec2 & size , int * v , int v_min , int v_max , const char * format = \"%d\" ) VSliderScalar(...) bool VSliderScalar ( const char * label , const ImVec2 & size , ImGuiDataType data_type , void * p_data , const void * p_min , const void * p_max , const char * format = NULL , float power = 1.0f ) Widgets: Input with Keyboard \u00b6 If you want to use InputText() with std::string or any custom dynamic string type, see misc/cpp/imgui_stdlib.h and comments in imgui_demo.cpp. Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc. InputText(...) bool InputText ( const char * label , char * buf , size_t buf_size , ImGuiInputTextFlags flags = 0 , ImGuiInputTextCallback callback = NULL , void * user_data = NULL ) InputTextMultiline(...) bool InputTextMultiline ( const char * label , char * buf , size_t buf_size , const ImVec2 & size = ImVec2 ( 0 , 0 ), ImGuiInputTextFlags flags = 0 , ImGuiInputTextCallback callback = NULL , void * user_data = NULL ) InputTextWithHint(...) bool InputTextWithHint ( const char * label , const char * hint , char * buf , size_t buf_size , ImGuiInputTextFlags flags = 0 , ImGuiInputTextCallback callback = NULL , void * user_data = NULL ) InputFloat(...) bool InputFloat ( const char * label , float * v , float step = 0.0f , float step_fast = 0.0f , const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputFloat2(...) bool InputFloat2 ( const char * label , float v [ 2 ], const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputFloat3(...) bool InputFloat3 ( const char * label , float v [ 3 ], const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputFloat4(...) bool InputFloat4 ( const char * label , float v [ 4 ], const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputInt(...) bool InputInt ( const char * label , int * v , int step = 1 , int step_fast = 100 , ImGuiInputTextFlags flags = 0 ) InputInt2(...) bool InputInt2 ( const char * label , int v [ 2 ], ImGuiInputTextFlags flags = 0 ) InputInt3(...) bool InputInt3 ( const char * label , int v [ 3 ], ImGuiInputTextFlags flags = 0 ) InputInt4(...) bool InputInt4 ( const char * label , int v [ 4 ], ImGuiInputTextFlags flags = 0 ) InputDouble(...) bool InputDouble ( const char * label , double * v , double step = 0.0 , double step_fast = 0.0 , const char * format = \"%.6f\" , ImGuiInputTextFlags flags = 0 ) InputScalar(...) bool InputScalar ( const char * label , ImGuiDataType data_type , void * p_data , const void * p_step = NULL , const void * p_step_fast = NULL , const char * format = NULL , ImGuiInputTextFlags flags = 0 ) InputScalarN(...) bool InputScalarN ( const char * label , ImGuiDataType data_type , void * p_data , int components , const void * p_step = NULL , const void * p_step_fast = NULL , const char * format = NULL , ImGuiInputTextFlags flags = 0 ) Widgets: Color Editor/Picker \u00b6 Ttip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu. Note that in C++ a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x ColorEdit3(...) bool ColorEdit3 ( const char * label , float col [ 3 ], ImGuiColorEditFlags flags = 0 ) ColorEdit4(...) bool ColorEdit4 ( const char * label , float col [ 4 ], ImGuiColorEditFlags flags = 0 ) ColorPicker3(...) bool ColorPicker3 ( const char * label , float col [ 3 ], ImGuiColorEditFlags flags = 0 ) ColorPicker4(...) bool ColorPicker4 ( const char * label , float col [ 4 ], ImGuiColorEditFlags flags = 0 , const float * ref_col = NULL ) ColorButton(...) display a colored square/button, hover for details, return true when pressed. bool ColorButton ( const char * desc_id , const ImVec4 & col , ImGuiColorEditFlags flags = 0 , ImVec2 size = ImVec2 ( 0 , 0 )) SetColorEditOptions(...) initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls. void SetColorEditOptions ( ImGuiColorEditFlags flags ) Widgets: Trees \u00b6 TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents. TreeNode(...) bool TreeNode ( const char * label ) TreeNode(...) helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet(). bool TreeNode ( const char * str_id , const char * fmt , ...) IM_FMTARGS ( 2 ) TreeNode(...) \" bool TreeNode ( const void * ptr_id , const char * fmt , ...) IM_FMTARGS ( 2 ) TreeNodeV(...) bool TreeNodeV ( const char * str_id , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) TreeNodeV(...) bool TreeNodeV ( const void * ptr_id , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) TreeNodeEx(...) bool TreeNodeEx ( const char * label , ImGuiTreeNodeFlags flags = 0 ) TreeNodeEx(...) bool TreeNodeEx ( const char * str_id , ImGuiTreeNodeFlags flags , const char * fmt , ...) IM_FMTARGS ( 3 ) TreeNodeEx(...) bool TreeNodeEx ( const void * ptr_id , ImGuiTreeNodeFlags flags , const char * fmt , ...) IM_FMTARGS ( 3 ) TreeNodeExV(...) bool TreeNodeExV ( const char * str_id , ImGuiTreeNodeFlags flags , const char * fmt , va_list args ) IM_FMTLIST ( 3 ) TreeNodeExV(...) bool TreeNodeExV ( const void * ptr_id , ImGuiTreeNodeFlags flags , const char * fmt , va_list args ) IM_FMTLIST ( 3 ) TreePush(...) ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired. void TreePush ( const char * str_id ) TreePush(...) \" void TreePush ( const void * ptr_id = NULL ) TreePop() ~ Unindent()+PopId() void TreePop () GetTreeNodeToLabelSpacing() horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode float GetTreeNodeToLabelSpacing () CollapsingHeader(...) if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop(). bool CollapsingHeader ( const char * label , ImGuiTreeNodeFlags flags = 0 ) CollapsingHeader(...) when 'p_open' isn't NULL, display an additional small close button on upper right of the header bool CollapsingHeader ( const char * label , bool * p_open , ImGuiTreeNodeFlags flags = 0 ) SetNextItemOpen(...) set next TreeNode/CollapsingHeader open state. void SetNextItemOpen ( bool is_open , ImGuiCond cond = 0 ) Widgets: Selectables \u00b6 A selectable highlights when hovered, and can display another color when selected. Neighbors selectable extend their highlight bounds in order to leave no gap between them. This is so a series of selected Selectable appear contiguous. Selectable(...) \"bool selected\" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height bool Selectable ( const char * label , bool selected = false , ImGuiSelectableFlags flags = 0 , const ImVec2 & size = ImVec2 ( 0 , 0 )) Selectable(...) \"bool* p_selected\" point to the selection state (read-write), as a convenient helper. bool Selectable ( const char * label , bool * p_selected , ImGuiSelectableFlags flags = 0 , const ImVec2 & size = ImVec2 ( 0 , 0 )) Widgets: List Boxes \u00b6 FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them. ListBox(...) bool ListBox ( const char * label , int * current_item , const char * const items [], int items_count , int height_in_items = - 1 ) ListBox(...) bool ListBox ( const char * label , int * current_item , bool ( * items_getter )( void * data , int idx , const char ** out_text ), void * data , int items_count , int height_in_items = - 1 ) ListBoxHeader(...) use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards. bool ListBoxHeader ( const char * label , const ImVec2 & size = ImVec2 ( 0 , 0 )) ListBoxHeader(...) \" bool ListBoxHeader ( const char * label , int items_count , int height_in_items = - 1 ) ListBoxFooter() terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true! void ListBoxFooter () Widgets: Data Plotting \u00b6 PlotLines(...) void PlotLines ( const char * label , const float * values , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 ), int stride = sizeof ( float )) PlotLines(...) void PlotLines ( const char * label , float ( * values_getter )( void * data , int idx ), void * data , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 )) PlotHistogram(...) void PlotHistogram ( const char * label , const float * values , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 ), int stride = sizeof ( float )) PlotHistogram(...) void PlotHistogram ( const char * label , float ( * values_getter )( void * data , int idx ), void * data , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 )) Widgets: Value() Helpers. \u00b6 Those are merely shortcut to calling Text() with a format string. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace) Value(...) void Value ( const char * prefix , bool b ) Value(...) void Value ( const char * prefix , int v ) Value(...) void Value ( const char * prefix , unsigned int v ) Value(...) void Value ( const char * prefix , float v , const char * float_format = NULL ) Widgets: Menus \u00b6 Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar. Use BeginMainMenuBar() to create a menu bar at the top of the screen and append to it. Use BeginMenu() to create a menu. You can call BeginMenu() multiple time with the same identifier to append more items to it. BeginMenuBar() append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window). bool BeginMenuBar () EndMenuBar() only call EndMenuBar() if BeginMenuBar() returns true! void EndMenuBar () BeginMainMenuBar() create and append to a full screen menu-bar. bool BeginMainMenuBar () EndMainMenuBar() only call EndMainMenuBar() if BeginMainMenuBar() returns true! void EndMainMenuBar () BeginMenu(...) create a sub-menu entry. only call EndMenu() if this returns true! bool BeginMenu ( const char * label , bool enabled = true ) EndMenu() only call EndMenu() if BeginMenu() returns true! void EndMenu () MenuItem(...) return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment bool MenuItem ( const char * label , const char * shortcut = NULL , bool selected = false , bool enabled = true ) MenuItem(...) return true when activated + toggle (*p_selected) if p_selected != NULL bool MenuItem ( const char * label , const char * shortcut , bool * p_selected , bool enabled = true ) Tooltips \u00b6 Tooltip are windows following the mouse which do not take focus away. BeginTooltip() begin/append a tooltip window. to create full-featured tooltip (with any kind of items). void BeginTooltip () EndTooltip() void EndTooltip () SetTooltip(...) set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip(). void SetTooltip ( const char * fmt , ...) IM_FMTARGS ( 1 ) SetTooltipV(...) void SetTooltipV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) Popups, Modals \u00b6 The properties of popups windows are: - They block normal mouse hovering detection outside them. (*1) - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE. Because hovering detection is disabled outside the popup, when clicking outside the click will not be seen by underlying widgets! (*1) Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as we are used to with regular Begin() calls. User can manipulate the visibility state by calling OpenPopup(), CloseCurrentPopup() etc. We default to use the right mouse (ImGuiMouseButton_Right=1) for the Popup Context functions. Those three properties are connected: we need to retain popup visibility state in the library because popups may be closed as any time. (1.) You can bypass that restriction and detect hovering even when normally blocked by a popup. To do this use the ImGuiHoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or IsWindowHovered() . This is what BeginPopupContextItem() and BeginPopupContextWindow() are doing already, allowing a right-click to reopen another popups without losing the click. OpenPopup(...) call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level). void OpenPopup ( const char * str_id ) BeginPopup(...) return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true! bool BeginPopup ( const char * str_id , ImGuiWindowFlags flags = 0 ) BeginPopupContextItem(...) helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp! bool BeginPopupContextItem ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 ) BeginPopupContextWindow(...) helper to open and begin popup when clicked on current window. bool BeginPopupContextWindow ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 , bool also_over_items = true ) BeginPopupContextVoid(...) helper to open and begin popup when clicked in void (where there are no imgui windows). bool BeginPopupContextVoid ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 ) BeginPopupModal(...) modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside) bool BeginPopupModal ( const char * name , bool * p_open = NULL , ImGuiWindowFlags flags = 0 ) EndPopup() only call EndPopup() if BeginPopupXXX() returns true! void EndPopup () OpenPopupOnItemClick(...) helper to open popup when clicked on last item (note: actually triggers on the mouse released event to be consistent with popup behaviors). return true when just opened. bool OpenPopupOnItemClick ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 ) IsPopupOpen(...) return true if the popup is open at the current begin-ed level of the popup stack. bool IsPopupOpen ( const char * str_id ) CloseCurrentPopup() close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup. void CloseCurrentPopup () Columns \u00b6 You can also use SameLine(pos_x) to mimic simplified columns. The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!) There is a maximum of 64 columns. Currently working on new 'Tables' api which will replace columns around Q2 2020 (see GitHub #2957 ). Columns(...) void Columns ( int count = 1 , const char * id = NULL , bool border = true ) NextColumn() next column, defaults to current row or next row if the current row is finished void NextColumn () GetColumnIndex() get current column index int GetColumnIndex () GetColumnWidth(...) get column width (in pixels). pass -1 to use current column float GetColumnWidth ( int column_index = - 1 ) SetColumnWidth(...) set column width (in pixels). pass -1 to use current column void SetColumnWidth ( int column_index , float width ) GetColumnOffset(...) get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f float GetColumnOffset ( int column_index = - 1 ) SetColumnOffset(...) set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column void SetColumnOffset ( int column_index , float offset_x ) GetColumnsCount() int GetColumnsCount () Tab Bars, Tabs \u00b6 BeginTabBar(...) create and append into a TabBar bool BeginTabBar ( const char * str_id , ImGuiTabBarFlags flags = 0 ) EndTabBar() only call EndTabBar() if BeginTabBar() returns true! void EndTabBar () BeginTabItem(...) create a Tab. Returns true if the Tab is selected. bool BeginTabItem ( const char * label , bool * p_open = NULL , ImGuiTabItemFlags flags = 0 ) EndTabItem() only call EndTabItem() if BeginTabItem() returns true! void EndTabItem () SetTabItemClosed(...) notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name. void SetTabItemClosed ( const char * tab_or_docked_window_label ) Logging/Capture \u00b6 All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging. LogToTTY(...) start logging to tty (stdout) void LogToTTY ( int auto_open_depth = - 1 ) LogToFile(...) start logging to file void LogToFile ( int auto_open_depth = - 1 , const char * filename = NULL ) LogToClipboard(...) start logging to OS clipboard void LogToClipboard ( int auto_open_depth = - 1 ) LogFinish() stop logging (close file, etc.) void LogFinish () LogButtons() helper to display buttons for logging to tty/file/clipboard void LogButtons () LogText(...) pass text data straight to log (without being displayed) void LogText ( const char * fmt , ...) IM_FMTARGS ( 1 ) Drag and Drop \u00b6 Warning [BETA API] API may evolve! BeginDragDropSource(...) call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource() bool BeginDragDropSource ( ImGuiDragDropFlags flags = 0 ) SetDragDropPayload(...) type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. bool SetDragDropPayload ( const char * type , const void * data , size_t sz , ImGuiCond cond = 0 ) EndDragDropSource() only call EndDragDropSource() if BeginDragDropSource() returns true! void EndDragDropSource () BeginDragDropTarget() call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget() bool BeginDragDropTarget () EndDragDropTarget() only call EndDragDropTarget() if BeginDragDropTarget() returns true! void EndDragDropTarget () Clipping \u00b6 PushClipRect(...) void PushClipRect ( const ImVec2 & clip_rect_min , const ImVec2 & clip_rect_max , bool intersect_with_current_clip_rect ) PopClipRect() void PopClipRect () Focus, Activation \u00b6 Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHereY()\" when applicable to signify \"this is the default item\" SetItemDefaultFocus() make last item the default focused item of a window. void SetItemDefaultFocus () SetKeyboardFocusHere(...) focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget. void SetKeyboardFocusHere ( int offset = 0 ) Item/Widgets Utilities \u00b6 Most of the functions are referring to the last/previous item we submitted. See Demo Window under \"Widgets->Querying Status\" for an interactive visualization of most of those functions. IsItemHovered(...) is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options. bool IsItemHovered ( ImGuiHoveredFlags flags = 0 ) IsItemActive() is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false) bool IsItemActive () IsItemFocused() is the last item focused for keyboard/gamepad navigation? bool IsItemFocused () IsItemClicked(...) is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered() bool IsItemClicked ( ImGuiMouseButton mouse_button = 0 ) IsItemVisible() is the last item visible? (items may be out of sight because of clipping/scrolling) bool IsItemVisible () IsItemEdited() did the last item modify its underlying value this frame? or was pressed? This is generally the same as the \"bool\" return value of many widgets. bool IsItemEdited () IsItemActivated() was the last item just made active (item was previously inactive). bool IsItemActivated () IsItemDeactivated() was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing. bool IsItemDeactivated () IsItemDeactivatedAfterEdit() was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item). bool IsItemDeactivatedAfterEdit () IsItemToggledOpen() was the last item open state toggled? set by TreeNode(). bool IsItemToggledOpen () IsAnyItemHovered() is any item hovered? bool IsAnyItemHovered () IsAnyItemActive() is any item active? bool IsAnyItemActive () IsAnyItemFocused() is any item focused? bool IsAnyItemFocused () GetItemRectMin() get upper-left bounding rectangle of the last item (screen space) ImVec2 GetItemRectMin () GetItemRectMax() get lower-right bounding rectangle of the last item (screen space) ImVec2 GetItemRectMax () GetItemRectSize() get size of last item ImVec2 GetItemRectSize () SetItemAllowOverlap() allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area. void SetItemAllowOverlap () Miscellaneous Utilities \u00b6 IsRectVisible(...) test if rectangle (of given size, starting from cursor position) is visible / not clipped. bool IsRectVisible ( const ImVec2 & size ) IsRectVisible(...) test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side. bool IsRectVisible ( const ImVec2 & rect_min , const ImVec2 & rect_max ) GetTime() get global imgui time. incremented by io.DeltaTime every frame. double GetTime () GetFrameCount() get global imgui frame count. incremented by 1 every frame. int GetFrameCount () GetBackgroundDrawList() this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents. ImDrawList * GetBackgroundDrawList () GetForegroundDrawList() this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents. ImDrawList * GetForegroundDrawList () GetDrawListSharedData() you may use this when creating your own ImDrawList instances. ImDrawListSharedData * GetDrawListSharedData () SetStateStorage(...) replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it) void SetStateStorage ( ImGuiStorage * storage ) GetStateStorage() ImGuiStorage * GetStateStorage () CalcListClipping(...) calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can. void CalcListClipping ( int items_count , float items_height , int * out_items_display_start , int * out_items_display_end ) BeginChildFrame(...) helper to create a child window / scrolling region that looks like a normal widget frame bool BeginChildFrame ( ImGuiID id , const ImVec2 & size , ImGuiWindowFlags flags = 0 ) EndChildFrame() always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window) void EndChildFrame () Text Utilities \u00b6 CalcTextSize(...) ImVec2 CalcTextSize ( const char * text , const char * text_end = NULL , bool hide_text_after_double_hash = false , float wrap_width = - 1.0f ) Color Utilities \u00b6 ColorConvertU32ToFloat4(...) ImVec4 ColorConvertU32ToFloat4 ( ImU32 in ) ColorConvertFloat4ToU32(...) ImU32 ColorConvertFloat4ToU32 ( const ImVec4 & in ) ColorConvertRGBtoHSV(...) void ColorConvertRGBtoHSV ( float r , float g , float b , float & out_h , float & out_s , float & out_v ) ColorConvertHSVtoRGB(...) void ColorConvertHSVtoRGB ( float h , float s , float v , float & out_r , float & out_g , float & out_b ) Inputs Utilities: Keyboard \u00b6 For 'int user_key_index' you can use your own indices/enums according to how your backend/engine stored them in io.KeysDown[]. We don't know the meaning of those value. You can use GetKeyIndex() to map a ImGuiKey_ value into the user index. GetKeyIndex(...) map ImGuiKey_* values into user's key index. == io.KeyMap[key] int GetKeyIndex ( ImGuiKey imgui_key ) IsKeyDown(...) is key being held. == io.KeysDown[user_key_index]. bool IsKeyDown ( int user_key_index ) IsKeyPressed(...) was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate bool IsKeyPressed ( int user_key_index , bool repeat = true ) IsKeyReleased(...) was key released (went from Down to !Down)? bool IsKeyReleased ( int user_key_index ) GetKeyPressedAmount(...) uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate int GetKeyPressedAmount ( int key_index , float repeat_delay , float rate ) CaptureKeyboardFromApp(...) attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting \"io.WantCaptureKeyboard = want_capture_keyboard_value\"; after the next NewFrame() call. void CaptureKeyboardFromApp ( bool want_capture_keyboard_value = true ) Inputs Utilities: Mouse \u00b6 To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right. You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle. Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold') IsMouseDown(...) is mouse button held? bool IsMouseDown ( ImGuiMouseButton button ) IsMouseClicked(...) did mouse button clicked? (went from !Down to Down) bool IsMouseClicked ( ImGuiMouseButton button , bool repeat = false ) IsMouseReleased(...) did mouse button released? (went from Down to !Down) bool IsMouseReleased ( ImGuiMouseButton button ) IsMouseDoubleClicked(...) did mouse button double-clicked? a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime. bool IsMouseDoubleClicked ( ImGuiMouseButton button ) IsMouseHoveringRect(...) is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block. bool IsMouseHoveringRect ( const ImVec2 & r_min , const ImVec2 & r_max , bool clip = true ) IsMousePosValid(...) by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available bool IsMousePosValid ( const ImVec2 * mouse_pos = NULL ) IsAnyMouseDown() is any mouse button held? bool IsAnyMouseDown () GetMousePos() shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls ImVec2 GetMousePos () GetMousePosOnOpeningCurrentPopup() retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves) ImVec2 GetMousePosOnOpeningCurrentPopup () IsMouseDragging(...) is mouse dragging? (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold) bool IsMouseDragging ( ImGuiMouseButton button , float lock_threshold = - 1.0f ) GetMouseDragDelta(...) return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold) ImVec2 GetMouseDragDelta ( ImGuiMouseButton button = 0 , float lock_threshold = - 1.0f ) ResetMouseDragDelta(...) void ResetMouseDragDelta ( ImGuiMouseButton button = 0 ) GetMouseCursor() get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you ImGuiMouseCursor GetMouseCursor () SetMouseCursor(...) set desired cursor type void SetMouseCursor ( ImGuiMouseCursor cursor_type ) CaptureMouseFromApp(...) attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting \"io.WantCaptureMouse = want_capture_mouse_value;\" after the next NewFrame() call. void CaptureMouseFromApp ( bool want_capture_mouse_value = true ) Clipboard Utilities \u00b6 Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard. SetClipboardText(...) void SetClipboardText ( const char * text ) Settings/.Ini Utilities \u00b6 The disk functions are automatically called if io.IniFilename != NULL (default is \"imgui.ini\"). Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually. LoadIniSettingsFromDisk(...) call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename). void LoadIniSettingsFromDisk ( const char * ini_filename ) LoadIniSettingsFromMemory(...) call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source. void LoadIniSettingsFromMemory ( const char * ini_data , size_t ini_size = 0 ) SaveIniSettingsToDisk(...) this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext). void SaveIniSettingsToDisk ( const char * ini_filename ) Debug Utilities \u00b6 DebugCheckVersionAndDataLayout(...) This is called by IMGUI_CHECKVERSION() macro. bool DebugCheckVersionAndDataLayout ( const char * version_str , size_t sz_io , size_t sz_style , size_t sz_vec2 , size_t sz_vec4 , size_t sz_drawvert , size_t sz_drawidx ) Memory Allocators \u00b6 All those functions are not reliant on the current context. If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again because we use global storage for those. SetAllocatorFunctions(...) void SetAllocatorFunctions ( void * ( * alloc_func )( size_t sz , void * user_data ), void ( * free_func )( void * ptr , void * user_data ), void * user_data = NULL ) MemAlloc(...) void * MemAlloc ( size_t size ) MemFree(...) void MemFree ( void * ptr )","title":"API ImGui"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#imgui-dear-imgui-end-user-api","text":"// (This is a namespace. You can add extra ImGui:: functions in your own separate file. Please don't modify imgui source files!)","title":"ImGui: Dear ImGui end-user API"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#context-creation-and-access","text":"Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between imgui contexts. None of those functions is reliant on the current context. CreateContext(...) ImGuiContext * CreateContext ( ImFontAtlas * shared_font_atlas = NULL ) DestroyContext(...) NULL = destroy current context void DestroyContext ( ImGuiContext * ctx = NULL ) GetCurrentContext() ImGuiContext * GetCurrentContext () SetCurrentContext(...) void SetCurrentContext ( ImGuiContext * ctx )","title":"Context creation and access"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#main","text":"GetIO() access the IO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags) ImGuiIO & GetIO () GetStyle() access the Style structure (colors, sizes). Always use PushStyleCol(), PushStyleVar() to modify style mid-frame! ImGuiStyle & GetStyle () NewFrame() start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame(). void NewFrame () EndFrame() ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all! void EndFrame () Render() ends the Dear ImGui frame, finalize the draw data. You can get call GetDrawData() to obtain it and run your rendering function (up to v1.60, this used to call io.RenderDrawListsFn(). Nowadays, we allow and prefer calling your render function yourself.) void Render () GetDrawData() valid after Render() and until the next call to NewFrame(). this is what you have to render. ImDrawData * GetDrawData ()","title":"Main"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#demo-debug-information","text":"ShowDemoWindow(...) create Demo window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application! void ShowDemoWindow ( bool * p_open = NULL ) ShowAboutWindow(...) create About window. display Dear ImGui version, credits and build/system information. void ShowAboutWindow ( bool * p_open = NULL ) ShowMetricsWindow(...) create Debug/Metrics window. display Dear ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc. void ShowMetricsWindow ( bool * p_open = NULL ) ShowStyleEditor(...) add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style) void ShowStyleEditor ( ImGuiStyle * ref = NULL ) ShowStyleSelector(...) add style selector block (not a window), essentially a combo listing the default styles. bool ShowStyleSelector ( const char * label ) ShowFontSelector(...) add font selector block (not a window), essentially a combo listing the loaded fonts. void ShowFontSelector ( const char * label ) ShowUserGuide() add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls). void ShowUserGuide ()","title":"Demo, Debug, Information"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#styles","text":"StyleColorsDark(...) new, recommended style (default) void StyleColorsDark ( ImGuiStyle * dst = NULL ) StyleColorsClassic(...) classic imgui style void StyleColorsClassic ( ImGuiStyle * dst = NULL ) StyleColorsLight(...) best used with borders and a custom, thicker font void StyleColorsLight ( ImGuiStyle * dst = NULL )","title":"Styles"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#windows","text":"Begin() = push window to the stack and start appending to it. End() = pop window from the stack. You may append multiple times to the same window during the same frame. Passing bool* p_open != NULL shows a window-closing widget in the upper-right corner of the window, which clicking will set the boolean to false when clicked. Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window. Always call a matching End() for each Begin() call, regardless of its return value! [Important: due to legacy reason, this is inconsistent with most other functions such as BeginMenu / EndMenu , BeginPopup / EndPopup , etc. where the EndXXX call should only be called if the corresponding BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.] Note that the bottom of window stack always contains a window called \"Debug\". Begin(...) bool Begin ( const char * name , bool * p_open = NULL , ImGuiWindowFlags flags = 0 ) End() void End ()","title":"Windows"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#child-windows","text":"Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child. For each independent axis of size : == 0.0f -> use remaining host window size > 0.0f -> fixed size < 0.0f -> use remaining window size minus abs(size) Each axis can use a different mode, e.g. ImVec2(0,400) . BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting anything to the window. Tip Always call a matching EndChild() for each BeginChild() call, regardless of its return value [as with Begin : this is due to legacy reason and inconsistent with most BeginXXX functions apart from the regular Begin() which behaves like BeginChild() .] BeginChild(...) bool BeginChild ( const char * str_id , const ImVec2 & size = ImVec2 ( 0 , 0 ), bool border = false , ImGuiWindowFlags flags = 0 ) BeginChild(...) bool BeginChild ( ImGuiID id , const ImVec2 & size = ImVec2 ( 0 , 0 ), bool border = false , ImGuiWindowFlags flags = 0 ) EndChild() void EndChild ()","title":"Child Windows"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#windows-utilities","text":"Current window = the window we are appending into while inside a Begin() / End() block. Next window = next window we will Begin() into. IsWindowAppearing() bool IsWindowAppearing () IsWindowCollapsed() bool IsWindowCollapsed () IsWindowFocused(...) is current window focused? Or its root/child, depending on flags. See flags for options. bool IsWindowFocused ( ImGuiFocusedFlags flags = 0 ) IsWindowHovered(...) is current window hovered (and typically: not blocked by a popup/modal)? See flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ! bool IsWindowHovered ( ImGuiHoveredFlags flags = 0 ) GetWindowDrawList() get draw list associated to the current window , to append your own drawing primitives ImDrawList * GetWindowDrawList () GetWindowPos() get current window position in screen space (useful if you want to do your own drawing via the DrawList API) ImVec2 GetWindowPos () GetWindowSize() get current window size ImVec2 GetWindowSize () GetWindowWidth() get current window width (shortcut for GetWindowSize().x ) float GetWindowWidth () GetWindowHeight() get current window height (shortcut for GetWindowSize().y ) float GetWindowHeight ()","title":"Windows Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#next-window-utilities","text":"Prefer using SetNextXXX functions (before Begin ) rather than SetXXX functions (after Begin() ). SetNextWindowPos(...) set next window position. Call before Begin(). Use pivot=(0.5f,0.5f) to center on given point, etc. void SetNextWindowPos ( const ImVec2 & pos , ImGuiCond cond = 0 , const ImVec2 & pivot = ImVec2 ( 0 , 0 )) SetNextWindowSize(...) set next window size. Set axis to 0.0f to force an auto-fit on this axis. Call before Begin() . void SetNextWindowSize ( const ImVec2 & size , ImGuiCond cond = 0 ) SetNextWindowSizeConstraints(...) set next window size limits. Use -1,-1 on either X/Y axis to preserve the current size. Sizes will be rounded down. Use callback to apply non-trivial programmatic constraints. void SetNextWindowSizeConstraints ( const ImVec2 & size_min , const ImVec2 & size_max , ImGuiSizeCallback custom_callback = NULL , void * custom_callback_data = NULL ) SetNextWindowContentSize(...) set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding . Set an axis to 0.0f to leave it automatic. Call before Begin() void SetNextWindowContentSize ( const ImVec2 & size ) SetNextWindowCollapsed(...) set next window collapsed state. Call before Begin() void SetNextWindowCollapsed ( bool collapsed , ImGuiCond cond = 0 ) SetNextWindowFocus() set next window to be focused / top-most. Call before Begin() void SetNextWindowFocus () SetNextWindowBgAlpha(...) set next window background color alpha. Helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. You may also use ImGuiWindowFlags_NoBackground. void SetNextWindowBgAlpha ( float alpha ) SetWindowPos(...) (not recommended) set current window position - call within Begin() / End() . Prefer using SetNextWindowPos(), as this may incur tearing and side-effects. void SetWindowPos ( const ImVec2 & pos , ImGuiCond cond = 0 ) SetWindowSize(...) (not recommended) set current window size - call within Begin()/End(). Set to ImVec2(0,0) to force an auto-fit. Prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects. void SetWindowSize ( const ImVec2 & size , ImGuiCond cond = 0 ) SetWindowCollapsed(...) (not recommended) set current window collapsed state. Prefer using SetNextWindowCollapsed(). void SetWindowCollapsed ( bool collapsed , ImGuiCond cond = 0 ) SetWindowFocus() (not recommended) set current window to be focused / top-most. Prefer using SetNextWindowFocus(). void SetWindowFocus () SetWindowFontScale(...) set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes() . void SetWindowFontScale ( float scale ) SetWindowPos(...) set named window position. void SetWindowPos ( const char * name , const ImVec2 & pos , ImGuiCond cond = 0 ) SetWindowSize(...) set named window size. set axis to 0.0f to force an auto-fit on this axis. void SetWindowSize ( const char * name , const ImVec2 & size , ImGuiCond cond = 0 ) SetWindowCollapsed(...) set named window collapsed state void SetWindowCollapsed ( const char * name , bool collapsed , ImGuiCond cond = 0 ) SetWindowFocus(...) set named window to be focused / top-most. use NULL to remove focus. void SetWindowFocus ( const char * name )","title":"Next Window Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#content-region","text":"Those functions are bound to be redesigned soon (they are confusing, incomplete and return values in local window coordinates which increases confusion) GetContentRegionMax() current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates ImVec2 GetContentRegionMax () GetContentRegionAvail() == GetContentRegionMax() - GetCursorPos() ImVec2 GetContentRegionAvail () GetWindowContentRegionMin() content boundaries min (roughly (0,0)-Scroll), in window coordinates ImVec2 GetWindowContentRegionMin () GetWindowContentRegionMax() content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates ImVec2 GetWindowContentRegionMax () GetWindowContentRegionWidth() float GetWindowContentRegionWidth ()","title":"Content region"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#windows-scrolling","text":"GetScrollX() get scrolling amount [0..GetScrollMaxX()] float GetScrollX () GetScrollY() get scrolling amount [0..GetScrollMaxY()] float GetScrollY () GetScrollMaxX() get maximum scrolling amount ~~ ContentSize.X - WindowSize.X float GetScrollMaxX () GetScrollMaxY() get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y float GetScrollMaxY () SetScrollX(...) set scrolling amount [0..GetScrollMaxX()] void SetScrollX ( float scroll_x ) SetScrollY(...) set scrolling amount [0..GetScrollMaxY()] void SetScrollY ( float scroll_y ) SetScrollHereX(...) adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead. void SetScrollHereX ( float center_x_ratio = 0.5f ) SetScrollHereY(...) adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a \"default/current item\" visible, consider using SetItemDefaultFocus() instead. void SetScrollHereY ( float center_y_ratio = 0.5f ) SetScrollFromPosX(...) adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position. void SetScrollFromPosX ( float local_x , float center_x_ratio = 0.5f ) SetScrollFromPosY(...) adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position. void SetScrollFromPosY ( float local_y , float center_y_ratio = 0.5f )","title":"Windows Scrolling"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#parameters-stacks-shared","text":"PushFont(...) use NULL as a shortcut to push default font void PushFont ( ImFont * font ) PopFont() void PopFont () PushStyleColor(...) void PushStyleColor ( ImGuiCol idx , ImU32 col ) PushStyleColor(...) void PushStyleColor ( ImGuiCol idx , const ImVec4 & col ) PopStyleColor(...) void PopStyleColor ( int count = 1 ) PushStyleVar(...) void PushStyleVar ( ImGuiStyleVar idx , float val ) PushStyleVar(...) void PushStyleVar ( ImGuiStyleVar idx , const ImVec2 & val ) PopStyleVar(...) void PopStyleVar ( int count = 1 ) GetFont() get current font ImFont * GetFont () GetFontSize() get current font size (= height in pixels) of current font with current scale applied float GetFontSize () GetFontTexUvWhitePixel() get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API ImVec2 GetFontTexUvWhitePixel () GetColorU32(...) retrieve given style color with style alpha applied and optional extra alpha multiplier ImU32 GetColorU32 ( ImGuiCol idx , float alpha_mul = 1.0f ) GetColorU32(...) retrieve given color with style alpha applied ImU32 GetColorU32 ( const ImVec4 & col ) GetColorU32(...) retrieve given color with style alpha applied ImU32 GetColorU32 ( ImU32 col )","title":"Parameters stacks (shared)"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#parameters-stacks-current-window","text":"PushItemWidth(...) push width of items for common large \"item+label\" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side). 0.0f = default to ~\u2154 of windows width, void PushItemWidth ( float item_width ) PopItemWidth() void PopItemWidth () SetNextItemWidth(...) set width of the next common large \"item+label\" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side) void SetNextItemWidth ( float item_width ) CalcItemWidth() width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions. float CalcItemWidth () PushTextWrapPos(...) push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space void PushTextWrapPos ( float wrap_local_pos_x = 0.0f ) PopTextWrapPos() void PopTextWrapPos () PushAllowKeyboardFocus(...) allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets void PushAllowKeyboardFocus ( bool allow_keyboard_focus ) PopAllowKeyboardFocus() void PopAllowKeyboardFocus () PushButtonRepeat(...) in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame. void PushButtonRepeat ( bool repeat ) PopButtonRepeat() void PopButtonRepeat ()","title":"Parameters stacks (current window)"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#cursor-layout","text":"By \"cursor\" we mean the current output position. The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down. You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceeding widget. Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API: Window-local coordinates: SameLine(), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), GetContentRegionMax(), GetWindowContentRegion*(), PushTextWrapPos() Absolute coordinate: GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions. Separator() separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator. void Separator () SameLine(...) call between widgets or groups to layout them horizontally. X position given in window coordinates. void SameLine ( float offset_from_start_x = 0.0f , float spacing =- 1.0f ) NewLine() undo a SameLine() or force a new line when in an horizontal-layout context. void NewLine () Spacing() add vertical spacing. void Spacing () Dummy(...) add a dummy item of given size. unlike InvisibleButton(), Dummy() won't take the mouse click or be navigable into. void Dummy ( const ImVec2 & size ) Indent(...) move content position toward the right, by style.IndentSpacing or indent_w if != 0 void Indent ( float indent_w = 0.0f ) Unindent(...) move content position back to the left, by style.IndentSpacing or indent_w if != 0 void Unindent ( float indent_w = 0.0f ) BeginGroup() lock horizontal starting position void BeginGroup () EndGroup() unlock horizontal starting position + capture the whole group bounding box into one \"item\" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.) void EndGroup () GetCursorPos() cursor position in window coordinates (relative to window position) ImVec2 GetCursorPos () GetCursorPosX() (some functions are using window-relative coordinates, such as: GetCursorPos, GetCursorStartPos, GetContentRegionMax, GetWindowContentRegion* etc. float GetCursorPosX () GetCursorPosY() other functions such as GetCursorScreenPos or everything in ImDrawList:: float GetCursorPosY () SetCursorPos(...) are using the main, absolute coordinate system. void SetCursorPos ( const ImVec2 & local_pos ) SetCursorPosX(...) GetWindowPos() + GetCursorPos() == GetCursorScreenPos() etc.) void SetCursorPosX ( float local_x ) SetCursorPosY(...) void SetCursorPosY ( float local_y ) GetCursorStartPos() initial cursor position in window coordinates ImVec2 GetCursorStartPos () GetCursorScreenPos() cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API) ImVec2 GetCursorScreenPos () SetCursorScreenPos(...) cursor position in absolute screen coordinates [0..io.DisplaySize] void SetCursorScreenPos ( const ImVec2 & pos ) AlignTextToFramePadding() vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item) void AlignTextToFramePadding () GetTextLineHeight() ~ FontSize float GetTextLineHeight () GetTextLineHeightWithSpacing() ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text) float GetTextLineHeightWithSpacing () GetFrameHeight() ~ FontSize + style.FramePadding.y * 2 float GetFrameHeight () GetFrameHeightWithSpacing() ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets) float GetFrameHeightWithSpacing ()","title":"Cursor / Layout"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#id-stackscopes","text":"Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them. The resulting ID are hashes of the entire stack. You can also use the \"Label##foobar\" syntax within widget label to distinguish them from each others. In this header file we use the \"label\"/\"name\" terminology to denote a string that will be displayed and used as an ID, whereas \"str_id\" denote a string that is only used as an ID and not normally displayed. PushID(...) push string into the ID stack (will hash string). void PushID ( const char * str_id ) PushID(...) push string into the ID stack (will hash string). void PushID ( const char * str_id_begin , const char * str_id_end ) PushID(...) push pointer into the ID stack (will hash pointer). void PushID ( const void * ptr_id ) PushID(...) push integer into the ID stack (will hash integer). void PushID ( int int_id ) PopID() pop from the ID stack. void PopID () GetID(...) calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself ImGuiID GetID ( const char * str_id ) GetID(...) ImGuiID GetID ( const char * str_id_begin , const char * str_id_end ) GetID(...) ImGuiID GetID ( const void * ptr_id )","title":"ID stack/scopes"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-text","text":"TextUnformatted(...) raw text without formatting. Roughly equivalent to Text(\"%s\", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text. void TextUnformatted ( const char * text , const char * text_end = NULL ) Text(...) formatted text void Text ( const char * fmt , ...) IM_FMTARGS ( 1 ) TextV(...) void TextV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) TextColored(...) shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor(); void TextColored ( const ImVec4 & col , const char * fmt , ...) IM_FMTARGS ( 2 ) TextColoredV(...) void TextColoredV ( const ImVec4 & col , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) TextDisabled(...) shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor(); void TextDisabled ( const char * fmt , ...) IM_FMTARGS ( 1 ) TextDisabledV(...) void TextDisabledV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) TextWrapped(...) shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize(). void TextWrapped ( const char * fmt , ...) IM_FMTARGS ( 1 ) TextWrappedV(...) void TextWrappedV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 ) LabelText(...) display text+label aligned the same way as value+label widgets void LabelText ( const char * label , const char * fmt , ...) IM_FMTARGS ( 2 ) LabelTextV(...) void LabelTextV ( const char * label , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) BulletText(...) shortcut for Bullet()+Text() void BulletText ( const char * fmt , ...) IM_FMTARGS ( 1 ) BulletTextV(...) void BulletTextV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 )","title":"Widgets: Text"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-main","text":"Most widgets return true when the value has been changed or when pressed/selected You may also use one of the many IsItemXXX functions (e.g. IsItemActive, IsItemHovered, etc.) to query widget state. Button(...) button bool Button ( const char * label , const ImVec2 & size = ImVec2 ( 0 , 0 )) SmallButton(...) button with FramePadding=(0,0) to easily embed within text bool SmallButton ( const char * label ) InvisibleButton(...) button behavior without the visuals, frequently useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.) bool InvisibleButton ( const char * str_id , const ImVec2 & size ) ArrowButton(...) square button with an arrow shape bool ArrowButton ( const char * str_id , ImGuiDir dir ) Image(...) void Image ( ImTextureID user_texture_id , const ImVec2 & size , const ImVec2 & uv0 = ImVec2 ( 0 , 0 ), const ImVec2 & uv1 = ImVec2 ( 1 , 1 ), const ImVec4 & tint_col = ImVec4 ( 1 , 1 , 1 , 1 ), const ImVec4 & border_col = ImVec4 ( 0 , 0 , 0 , 0 )) ImageButton(...) <0 frame_padding uses default frame padding settings. 0 for no padding bool ImageButton ( ImTextureID user_texture_id , const ImVec2 & size , const ImVec2 & uv0 = ImVec2 ( 0 , 0 ), const ImVec2 & uv1 = ImVec2 ( 1 , 1 ), int frame_padding = - 1 , const ImVec4 & bg_col = ImVec4 ( 0 , 0 , 0 , 0 ), const ImVec4 & tint_col = ImVec4 ( 1 , 1 , 1 , 1 )) Checkbox(...) bool Checkbox ( const char * label , bool * v ) CheckboxFlags(...) bool CheckboxFlags ( const char * label , unsigned int * flags , unsigned int flags_value ) RadioButton(...) use with e.g. if (RadioButton(\"one\", my_value==1)) { my_value = 1; } bool RadioButton ( const char * label , bool active ) RadioButton(...) shortcut to handle the above pattern when value is an integer bool RadioButton ( const char * label , int * v , int v_button ) ProgressBar(...) void ProgressBar ( float fraction , const ImVec2 & size_arg = ImVec2 ( - 1 , 0 ), const char * overlay = NULL ) Bullet() draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses void Bullet ()","title":"Widgets: Main"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-combo-box","text":"The BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it, by creating e.g. Selectable() items. The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose. BeginCombo(...) bool BeginCombo ( const char * label , const char * preview_value , ImGuiComboFlags flags = 0 ) EndCombo() only call EndCombo() if BeginCombo() returns true! void EndCombo () Combo(...) bool Combo ( const char * label , int * current_item , const char * const items [], int items_count , int popup_max_height_in_items = - 1 ) Combo(...) Separate items with \\0 within a string, end item-list with \\0\\0. e.g. \"One\\0Two\\0Three\\0\" bool Combo ( const char * label , int * current_item , const char * items_separated_by_zeros , int popup_max_height_in_items = - 1 ) Combo(...) bool Combo ( const char * label , int * current_item , bool ( * items_getter )( void * data , int idx , const char ** out_text ), void * data , int items_count , int popup_max_height_in_items = - 1 )","title":"Widgets: Combo Box"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-drags","text":"CTRL+Click on any drag box to turn them into an input box. Manually input values aren't clamped and can go off-bounds. For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc. Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision). Use v_min < v_max to clamp edits to given limits. Note that CTRL+Click manual input can override those limits. Use v_max = FLT_MAX / INT_MAX etc to avoid clamping to a maximum, same with v_min = -FLT_MAX / INT_MIN to avoid clamping to a minimum. Use v_min > v_max to lock edits. DragFloat(...) If v_min >= v_max we have no bound bool DragFloat ( const char * label , float * v , float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloat2(...) bool DragFloat2 ( const char * label , float v [ 2 ], float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloat3(...) bool DragFloat3 ( const char * label , float v [ 3 ], float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloat4(...) bool DragFloat4 ( const char * label , float v [ 4 ], float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , float power = 1.0f ) DragFloatRange2(...) bool DragFloatRange2 ( const char * label , float * v_current_min , float * v_current_max , float v_speed = 1.0f , float v_min = 0.0f , float v_max = 0.0f , const char * format = \"%.3f\" , const char * format_max = NULL , float power = 1.0f ) DragInt(...) If v_min >= v_max we have no bound bool DragInt ( const char * label , int * v , float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragInt2(...) bool DragInt2 ( const char * label , int v [ 2 ], float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragInt3(...) bool DragInt3 ( const char * label , int v [ 3 ], float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragInt4(...) bool DragInt4 ( const char * label , int v [ 4 ], float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" ) DragIntRange2(...) bool DragIntRange2 ( const char * label , int * v_current_min , int * v_current_max , float v_speed = 1.0f , int v_min = 0 , int v_max = 0 , const char * format = \"%d\" , const char * format_max = NULL ) DragScalar(...) bool DragScalar ( const char * label , ImGuiDataType data_type , void * p_data , float v_speed , const void * p_min = NULL , const void * p_max = NULL , const char * format = NULL , float power = 1.0f ) DragScalarN(...) bool DragScalarN ( const char * label , ImGuiDataType data_type , void * p_data , int components , float v_speed , const void * p_min = NULL , const void * p_max = NULL , const char * format = NULL , float power = 1.0f )","title":"Widgets: Drags"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-sliders","text":"CTRL+Click on any slider to turn them into an input box. Manually input values aren't clamped and can go off-bounds. Adjust format string to decorate the value with a prefix, a suffix, or adapt the editing and display precision e.g. \"%.3f\" -> 1.234; \"%5.2f secs\" -> 01.23 secs; \"Biscuit: %.0f\" -> Biscuit: 1; etc. SliderFloat(...) adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders bool SliderFloat ( const char * label , float * v , float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderFloat2(...) bool SliderFloat2 ( const char * label , float v [ 2 ], float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderFloat3(...) bool SliderFloat3 ( const char * label , float v [ 3 ], float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderFloat4(...) bool SliderFloat4 ( const char * label , float v [ 4 ], float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) SliderAngle(...) bool SliderAngle ( const char * label , float * v_rad , float v_degrees_min = - 360.0f , float v_degrees_max = + 360.0f , const char * format = \"%.0f deg\" ) SliderInt(...) bool SliderInt ( const char * label , int * v , int v_min , int v_max , const char * format = \"%d\" ) SliderInt2(...) bool SliderInt2 ( const char * label , int v [ 2 ], int v_min , int v_max , const char * format = \"%d\" ) SliderInt3(...) bool SliderInt3 ( const char * label , int v [ 3 ], int v_min , int v_max , const char * format = \"%d\" ) SliderInt4(...) bool SliderInt4 ( const char * label , int v [ 4 ], int v_min , int v_max , const char * format = \"%d\" ) SliderScalar(...) bool SliderScalar ( const char * label , ImGuiDataType data_type , void * p_data , const void * p_min , const void * p_max , const char * format = NULL , float power = 1.0f ) SliderScalarN(...) bool SliderScalarN ( const char * label , ImGuiDataType data_type , void * p_data , int components , const void * p_min , const void * p_max , const char * format = NULL , float power = 1.0f ) VSliderFloat(...) bool VSliderFloat ( const char * label , const ImVec2 & size , float * v , float v_min , float v_max , const char * format = \"%.3f\" , float power = 1.0f ) VSliderInt(...) bool VSliderInt ( const char * label , const ImVec2 & size , int * v , int v_min , int v_max , const char * format = \"%d\" ) VSliderScalar(...) bool VSliderScalar ( const char * label , const ImVec2 & size , ImGuiDataType data_type , void * p_data , const void * p_min , const void * p_max , const char * format = NULL , float power = 1.0f )","title":"Widgets: Sliders"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-input-with-keyboard","text":"If you want to use InputText() with std::string or any custom dynamic string type, see misc/cpp/imgui_stdlib.h and comments in imgui_demo.cpp. Most of the ImGuiInputTextFlags flags are only useful for InputText() and not for InputFloatX, InputIntX, InputDouble etc. InputText(...) bool InputText ( const char * label , char * buf , size_t buf_size , ImGuiInputTextFlags flags = 0 , ImGuiInputTextCallback callback = NULL , void * user_data = NULL ) InputTextMultiline(...) bool InputTextMultiline ( const char * label , char * buf , size_t buf_size , const ImVec2 & size = ImVec2 ( 0 , 0 ), ImGuiInputTextFlags flags = 0 , ImGuiInputTextCallback callback = NULL , void * user_data = NULL ) InputTextWithHint(...) bool InputTextWithHint ( const char * label , const char * hint , char * buf , size_t buf_size , ImGuiInputTextFlags flags = 0 , ImGuiInputTextCallback callback = NULL , void * user_data = NULL ) InputFloat(...) bool InputFloat ( const char * label , float * v , float step = 0.0f , float step_fast = 0.0f , const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputFloat2(...) bool InputFloat2 ( const char * label , float v [ 2 ], const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputFloat3(...) bool InputFloat3 ( const char * label , float v [ 3 ], const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputFloat4(...) bool InputFloat4 ( const char * label , float v [ 4 ], const char * format = \"%.3f\" , ImGuiInputTextFlags flags = 0 ) InputInt(...) bool InputInt ( const char * label , int * v , int step = 1 , int step_fast = 100 , ImGuiInputTextFlags flags = 0 ) InputInt2(...) bool InputInt2 ( const char * label , int v [ 2 ], ImGuiInputTextFlags flags = 0 ) InputInt3(...) bool InputInt3 ( const char * label , int v [ 3 ], ImGuiInputTextFlags flags = 0 ) InputInt4(...) bool InputInt4 ( const char * label , int v [ 4 ], ImGuiInputTextFlags flags = 0 ) InputDouble(...) bool InputDouble ( const char * label , double * v , double step = 0.0 , double step_fast = 0.0 , const char * format = \"%.6f\" , ImGuiInputTextFlags flags = 0 ) InputScalar(...) bool InputScalar ( const char * label , ImGuiDataType data_type , void * p_data , const void * p_step = NULL , const void * p_step_fast = NULL , const char * format = NULL , ImGuiInputTextFlags flags = 0 ) InputScalarN(...) bool InputScalarN ( const char * label , ImGuiDataType data_type , void * p_data , int components , const void * p_step = NULL , const void * p_step_fast = NULL , const char * format = NULL , ImGuiInputTextFlags flags = 0 )","title":"Widgets: Input with Keyboard"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-color-editorpicker","text":"Ttip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu. Note that in C++ a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass the address of a first float element out of a contiguous structure, e.g. &myvector.x ColorEdit3(...) bool ColorEdit3 ( const char * label , float col [ 3 ], ImGuiColorEditFlags flags = 0 ) ColorEdit4(...) bool ColorEdit4 ( const char * label , float col [ 4 ], ImGuiColorEditFlags flags = 0 ) ColorPicker3(...) bool ColorPicker3 ( const char * label , float col [ 3 ], ImGuiColorEditFlags flags = 0 ) ColorPicker4(...) bool ColorPicker4 ( const char * label , float col [ 4 ], ImGuiColorEditFlags flags = 0 , const float * ref_col = NULL ) ColorButton(...) display a colored square/button, hover for details, return true when pressed. bool ColorButton ( const char * desc_id , const ImVec4 & col , ImGuiColorEditFlags flags = 0 , ImVec2 size = ImVec2 ( 0 , 0 )) SetColorEditOptions(...) initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls. void SetColorEditOptions ( ImGuiColorEditFlags flags )","title":"Widgets: Color Editor/Picker"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-trees","text":"TreeNode functions return true when the node is open, in which case you need to also call TreePop() when you are finished displaying the tree node contents. TreeNode(...) bool TreeNode ( const char * label ) TreeNode(...) helper variation to easily decorelate the id from the displayed string. Read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet(). bool TreeNode ( const char * str_id , const char * fmt , ...) IM_FMTARGS ( 2 ) TreeNode(...) \" bool TreeNode ( const void * ptr_id , const char * fmt , ...) IM_FMTARGS ( 2 ) TreeNodeV(...) bool TreeNodeV ( const char * str_id , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) TreeNodeV(...) bool TreeNodeV ( const void * ptr_id , const char * fmt , va_list args ) IM_FMTLIST ( 2 ) TreeNodeEx(...) bool TreeNodeEx ( const char * label , ImGuiTreeNodeFlags flags = 0 ) TreeNodeEx(...) bool TreeNodeEx ( const char * str_id , ImGuiTreeNodeFlags flags , const char * fmt , ...) IM_FMTARGS ( 3 ) TreeNodeEx(...) bool TreeNodeEx ( const void * ptr_id , ImGuiTreeNodeFlags flags , const char * fmt , ...) IM_FMTARGS ( 3 ) TreeNodeExV(...) bool TreeNodeExV ( const char * str_id , ImGuiTreeNodeFlags flags , const char * fmt , va_list args ) IM_FMTLIST ( 3 ) TreeNodeExV(...) bool TreeNodeExV ( const void * ptr_id , ImGuiTreeNodeFlags flags , const char * fmt , va_list args ) IM_FMTLIST ( 3 ) TreePush(...) ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call TreePush/TreePop yourself if desired. void TreePush ( const char * str_id ) TreePush(...) \" void TreePush ( const void * ptr_id = NULL ) TreePop() ~ Unindent()+PopId() void TreePop () GetTreeNodeToLabelSpacing() horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode float GetTreeNodeToLabelSpacing () CollapsingHeader(...) if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop(). bool CollapsingHeader ( const char * label , ImGuiTreeNodeFlags flags = 0 ) CollapsingHeader(...) when 'p_open' isn't NULL, display an additional small close button on upper right of the header bool CollapsingHeader ( const char * label , bool * p_open , ImGuiTreeNodeFlags flags = 0 ) SetNextItemOpen(...) set next TreeNode/CollapsingHeader open state. void SetNextItemOpen ( bool is_open , ImGuiCond cond = 0 )","title":"Widgets: Trees"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-selectables","text":"A selectable highlights when hovered, and can display another color when selected. Neighbors selectable extend their highlight bounds in order to leave no gap between them. This is so a series of selected Selectable appear contiguous. Selectable(...) \"bool selected\" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height bool Selectable ( const char * label , bool selected = false , ImGuiSelectableFlags flags = 0 , const ImVec2 & size = ImVec2 ( 0 , 0 )) Selectable(...) \"bool* p_selected\" point to the selection state (read-write), as a convenient helper. bool Selectable ( const char * label , bool * p_selected , ImGuiSelectableFlags flags = 0 , const ImVec2 & size = ImVec2 ( 0 , 0 ))","title":"Widgets: Selectables"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-list-boxes","text":"FIXME: To be consistent with all the newer API, ListBoxHeader/ListBoxFooter should in reality be called BeginListBox/EndListBox. Will rename them. ListBox(...) bool ListBox ( const char * label , int * current_item , const char * const items [], int items_count , int height_in_items = - 1 ) ListBox(...) bool ListBox ( const char * label , int * current_item , bool ( * items_getter )( void * data , int idx , const char ** out_text ), void * data , int items_count , int height_in_items = - 1 ) ListBoxHeader(...) use if you want to reimplement ListBox() will custom data or interactions. if the function return true, you can output elements then call ListBoxFooter() afterwards. bool ListBoxHeader ( const char * label , const ImVec2 & size = ImVec2 ( 0 , 0 )) ListBoxHeader(...) \" bool ListBoxHeader ( const char * label , int items_count , int height_in_items = - 1 ) ListBoxFooter() terminate the scrolling region. only call ListBoxFooter() if ListBoxHeader() returned true! void ListBoxFooter ()","title":"Widgets: List Boxes"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-data-plotting","text":"PlotLines(...) void PlotLines ( const char * label , const float * values , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 ), int stride = sizeof ( float )) PlotLines(...) void PlotLines ( const char * label , float ( * values_getter )( void * data , int idx ), void * data , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 )) PlotHistogram(...) void PlotHistogram ( const char * label , const float * values , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 ), int stride = sizeof ( float )) PlotHistogram(...) void PlotHistogram ( const char * label , float ( * values_getter )( void * data , int idx ), void * data , int values_count , int values_offset = 0 , const char * overlay_text = NULL , float scale_min = FLT_MAX , float scale_max = FLT_MAX , ImVec2 graph_size = ImVec2 ( 0 , 0 ))","title":"Widgets: Data Plotting"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-value-helpers","text":"Those are merely shortcut to calling Text() with a format string. Output single value in \"name: value\" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace) Value(...) void Value ( const char * prefix , bool b ) Value(...) void Value ( const char * prefix , int v ) Value(...) void Value ( const char * prefix , unsigned int v ) Value(...) void Value ( const char * prefix , float v , const char * float_format = NULL )","title":"Widgets: Value() Helpers."},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#widgets-menus","text":"Use BeginMenuBar() on a window ImGuiWindowFlags_MenuBar to append to its menu bar. Use BeginMainMenuBar() to create a menu bar at the top of the screen and append to it. Use BeginMenu() to create a menu. You can call BeginMenu() multiple time with the same identifier to append more items to it. BeginMenuBar() append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window). bool BeginMenuBar () EndMenuBar() only call EndMenuBar() if BeginMenuBar() returns true! void EndMenuBar () BeginMainMenuBar() create and append to a full screen menu-bar. bool BeginMainMenuBar () EndMainMenuBar() only call EndMainMenuBar() if BeginMainMenuBar() returns true! void EndMainMenuBar () BeginMenu(...) create a sub-menu entry. only call EndMenu() if this returns true! bool BeginMenu ( const char * label , bool enabled = true ) EndMenu() only call EndMenu() if BeginMenu() returns true! void EndMenu () MenuItem(...) return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment bool MenuItem ( const char * label , const char * shortcut = NULL , bool selected = false , bool enabled = true ) MenuItem(...) return true when activated + toggle (*p_selected) if p_selected != NULL bool MenuItem ( const char * label , const char * shortcut , bool * p_selected , bool enabled = true )","title":"Widgets: Menus"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#tooltips","text":"Tooltip are windows following the mouse which do not take focus away. BeginTooltip() begin/append a tooltip window. to create full-featured tooltip (with any kind of items). void BeginTooltip () EndTooltip() void EndTooltip () SetTooltip(...) set a text-only tooltip, typically use with ImGui::IsItemHovered(). override any previous call to SetTooltip(). void SetTooltip ( const char * fmt , ...) IM_FMTARGS ( 1 ) SetTooltipV(...) void SetTooltipV ( const char * fmt , va_list args ) IM_FMTLIST ( 1 )","title":"Tooltips"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#popups-modals","text":"The properties of popups windows are: - They block normal mouse hovering detection outside them. (*1) - Unless modal, they can be closed by clicking anywhere outside them, or by pressing ESCAPE. Because hovering detection is disabled outside the popup, when clicking outside the click will not be seen by underlying widgets! (*1) Their visibility state (~bool) is held internally by Dear ImGui instead of being held by the programmer as we are used to with regular Begin() calls. User can manipulate the visibility state by calling OpenPopup(), CloseCurrentPopup() etc. We default to use the right mouse (ImGuiMouseButton_Right=1) for the Popup Context functions. Those three properties are connected: we need to retain popup visibility state in the library because popups may be closed as any time. (1.) You can bypass that restriction and detect hovering even when normally blocked by a popup. To do this use the ImGuiHoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or IsWindowHovered() . This is what BeginPopupContextItem() and BeginPopupContextWindow() are doing already, allowing a right-click to reopen another popups without losing the click. OpenPopup(...) call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level). void OpenPopup ( const char * str_id ) BeginPopup(...) return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true! bool BeginPopup ( const char * str_id , ImGuiWindowFlags flags = 0 ) BeginPopupContextItem(...) helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp! bool BeginPopupContextItem ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 ) BeginPopupContextWindow(...) helper to open and begin popup when clicked on current window. bool BeginPopupContextWindow ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 , bool also_over_items = true ) BeginPopupContextVoid(...) helper to open and begin popup when clicked in void (where there are no imgui windows). bool BeginPopupContextVoid ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 ) BeginPopupModal(...) modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside) bool BeginPopupModal ( const char * name , bool * p_open = NULL , ImGuiWindowFlags flags = 0 ) EndPopup() only call EndPopup() if BeginPopupXXX() returns true! void EndPopup () OpenPopupOnItemClick(...) helper to open popup when clicked on last item (note: actually triggers on the mouse released event to be consistent with popup behaviors). return true when just opened. bool OpenPopupOnItemClick ( const char * str_id = NULL , ImGuiMouseButton mouse_button = 1 ) IsPopupOpen(...) return true if the popup is open at the current begin-ed level of the popup stack. bool IsPopupOpen ( const char * str_id ) CloseCurrentPopup() close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup. void CloseCurrentPopup ()","title":"Popups, Modals"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#columns","text":"You can also use SameLine(pos_x) to mimic simplified columns. The columns API is work-in-progress and rather lacking (columns are arguably the worst part of dear imgui at the moment!) There is a maximum of 64 columns. Currently working on new 'Tables' api which will replace columns around Q2 2020 (see GitHub #2957 ). Columns(...) void Columns ( int count = 1 , const char * id = NULL , bool border = true ) NextColumn() next column, defaults to current row or next row if the current row is finished void NextColumn () GetColumnIndex() get current column index int GetColumnIndex () GetColumnWidth(...) get column width (in pixels). pass -1 to use current column float GetColumnWidth ( int column_index = - 1 ) SetColumnWidth(...) set column width (in pixels). pass -1 to use current column void SetColumnWidth ( int column_index , float width ) GetColumnOffset(...) get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f float GetColumnOffset ( int column_index = - 1 ) SetColumnOffset(...) set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column void SetColumnOffset ( int column_index , float offset_x ) GetColumnsCount() int GetColumnsCount ()","title":"Columns"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#tab-bars-tabs","text":"BeginTabBar(...) create and append into a TabBar bool BeginTabBar ( const char * str_id , ImGuiTabBarFlags flags = 0 ) EndTabBar() only call EndTabBar() if BeginTabBar() returns true! void EndTabBar () BeginTabItem(...) create a Tab. Returns true if the Tab is selected. bool BeginTabItem ( const char * label , bool * p_open = NULL , ImGuiTabItemFlags flags = 0 ) EndTabItem() only call EndTabItem() if BeginTabItem() returns true! void EndTabItem () SetTabItemClosed(...) notify TabBar or Docking system of a closed tab/window ahead (useful to reduce visual flicker on reorderable tab bars). For tab-bar: call after BeginTabBar() and before Tab submissions. Otherwise call with a window name. void SetTabItemClosed ( const char * tab_or_docked_window_label )","title":"Tab Bars, Tabs"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#loggingcapture","text":"All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging. LogToTTY(...) start logging to tty (stdout) void LogToTTY ( int auto_open_depth = - 1 ) LogToFile(...) start logging to file void LogToFile ( int auto_open_depth = - 1 , const char * filename = NULL ) LogToClipboard(...) start logging to OS clipboard void LogToClipboard ( int auto_open_depth = - 1 ) LogFinish() stop logging (close file, etc.) void LogFinish () LogButtons() helper to display buttons for logging to tty/file/clipboard void LogButtons () LogText(...) pass text data straight to log (without being displayed) void LogText ( const char * fmt , ...) IM_FMTARGS ( 1 )","title":"Logging/Capture"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#drag-and-drop","text":"Warning [BETA API] API may evolve! BeginDragDropSource(...) call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource() bool BeginDragDropSource ( ImGuiDragDropFlags flags = 0 ) SetDragDropPayload(...) type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. bool SetDragDropPayload ( const char * type , const void * data , size_t sz , ImGuiCond cond = 0 ) EndDragDropSource() only call EndDragDropSource() if BeginDragDropSource() returns true! void EndDragDropSource () BeginDragDropTarget() call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget() bool BeginDragDropTarget () EndDragDropTarget() only call EndDragDropTarget() if BeginDragDropTarget() returns true! void EndDragDropTarget ()","title":"Drag and Drop"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#clipping","text":"PushClipRect(...) void PushClipRect ( const ImVec2 & clip_rect_min , const ImVec2 & clip_rect_max , bool intersect_with_current_clip_rect ) PopClipRect() void PopClipRect ()","title":"Clipping"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#focus-activation","text":"Prefer using \"SetItemDefaultFocus()\" over \"if (IsWindowAppearing()) SetScrollHereY()\" when applicable to signify \"this is the default item\" SetItemDefaultFocus() make last item the default focused item of a window. void SetItemDefaultFocus () SetKeyboardFocusHere(...) focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget. void SetKeyboardFocusHere ( int offset = 0 )","title":"Focus, Activation"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#itemwidgets-utilities","text":"Most of the functions are referring to the last/previous item we submitted. See Demo Window under \"Widgets->Querying Status\" for an interactive visualization of most of those functions. IsItemHovered(...) is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options. bool IsItemHovered ( ImGuiHoveredFlags flags = 0 ) IsItemActive() is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false) bool IsItemActive () IsItemFocused() is the last item focused for keyboard/gamepad navigation? bool IsItemFocused () IsItemClicked(...) is the last item clicked? (e.g. button/node just clicked on) == IsMouseClicked(mouse_button) && IsItemHovered() bool IsItemClicked ( ImGuiMouseButton mouse_button = 0 ) IsItemVisible() is the last item visible? (items may be out of sight because of clipping/scrolling) bool IsItemVisible () IsItemEdited() did the last item modify its underlying value this frame? or was pressed? This is generally the same as the \"bool\" return value of many widgets. bool IsItemEdited () IsItemActivated() was the last item just made active (item was previously inactive). bool IsItemActivated () IsItemDeactivated() was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that requires continuous editing. bool IsItemDeactivated () IsItemDeactivatedAfterEdit() was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that requires continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item). bool IsItemDeactivatedAfterEdit () IsItemToggledOpen() was the last item open state toggled? set by TreeNode(). bool IsItemToggledOpen () IsAnyItemHovered() is any item hovered? bool IsAnyItemHovered () IsAnyItemActive() is any item active? bool IsAnyItemActive () IsAnyItemFocused() is any item focused? bool IsAnyItemFocused () GetItemRectMin() get upper-left bounding rectangle of the last item (screen space) ImVec2 GetItemRectMin () GetItemRectMax() get lower-right bounding rectangle of the last item (screen space) ImVec2 GetItemRectMax () GetItemRectSize() get size of last item ImVec2 GetItemRectSize () SetItemAllowOverlap() allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area. void SetItemAllowOverlap ()","title":"Item/Widgets Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#miscellaneous-utilities","text":"IsRectVisible(...) test if rectangle (of given size, starting from cursor position) is visible / not clipped. bool IsRectVisible ( const ImVec2 & size ) IsRectVisible(...) test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side. bool IsRectVisible ( const ImVec2 & rect_min , const ImVec2 & rect_max ) GetTime() get global imgui time. incremented by io.DeltaTime every frame. double GetTime () GetFrameCount() get global imgui frame count. incremented by 1 every frame. int GetFrameCount () GetBackgroundDrawList() this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents. ImDrawList * GetBackgroundDrawList () GetForegroundDrawList() this draw list will be the last rendered one. Useful to quickly draw shapes/text over dear imgui contents. ImDrawList * GetForegroundDrawList () GetDrawListSharedData() you may use this when creating your own ImDrawList instances. ImDrawListSharedData * GetDrawListSharedData () SetStateStorage(...) replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it) void SetStateStorage ( ImGuiStorage * storage ) GetStateStorage() ImGuiStorage * GetStateStorage () CalcListClipping(...) calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can. void CalcListClipping ( int items_count , float items_height , int * out_items_display_start , int * out_items_display_end ) BeginChildFrame(...) helper to create a child window / scrolling region that looks like a normal widget frame bool BeginChildFrame ( ImGuiID id , const ImVec2 & size , ImGuiWindowFlags flags = 0 ) EndChildFrame() always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window) void EndChildFrame ()","title":"Miscellaneous Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#text-utilities","text":"CalcTextSize(...) ImVec2 CalcTextSize ( const char * text , const char * text_end = NULL , bool hide_text_after_double_hash = false , float wrap_width = - 1.0f )","title":"Text Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#color-utilities","text":"ColorConvertU32ToFloat4(...) ImVec4 ColorConvertU32ToFloat4 ( ImU32 in ) ColorConvertFloat4ToU32(...) ImU32 ColorConvertFloat4ToU32 ( const ImVec4 & in ) ColorConvertRGBtoHSV(...) void ColorConvertRGBtoHSV ( float r , float g , float b , float & out_h , float & out_s , float & out_v ) ColorConvertHSVtoRGB(...) void ColorConvertHSVtoRGB ( float h , float s , float v , float & out_r , float & out_g , float & out_b )","title":"Color Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#inputs-utilities-keyboard","text":"For 'int user_key_index' you can use your own indices/enums according to how your backend/engine stored them in io.KeysDown[]. We don't know the meaning of those value. You can use GetKeyIndex() to map a ImGuiKey_ value into the user index. GetKeyIndex(...) map ImGuiKey_* values into user's key index. == io.KeyMap[key] int GetKeyIndex ( ImGuiKey imgui_key ) IsKeyDown(...) is key being held. == io.KeysDown[user_key_index]. bool IsKeyDown ( int user_key_index ) IsKeyPressed(...) was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate bool IsKeyPressed ( int user_key_index , bool repeat = true ) IsKeyReleased(...) was key released (went from Down to !Down)? bool IsKeyReleased ( int user_key_index ) GetKeyPressedAmount(...) uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate int GetKeyPressedAmount ( int key_index , float repeat_delay , float rate ) CaptureKeyboardFromApp(...) attention: misleading name! manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting \"io.WantCaptureKeyboard = want_capture_keyboard_value\"; after the next NewFrame() call. void CaptureKeyboardFromApp ( bool want_capture_keyboard_value = true )","title":"Inputs Utilities: Keyboard"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#inputs-utilities-mouse","text":"To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right. You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle. Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold') IsMouseDown(...) is mouse button held? bool IsMouseDown ( ImGuiMouseButton button ) IsMouseClicked(...) did mouse button clicked? (went from !Down to Down) bool IsMouseClicked ( ImGuiMouseButton button , bool repeat = false ) IsMouseReleased(...) did mouse button released? (went from Down to !Down) bool IsMouseReleased ( ImGuiMouseButton button ) IsMouseDoubleClicked(...) did mouse button double-clicked? a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime. bool IsMouseDoubleClicked ( ImGuiMouseButton button ) IsMouseHoveringRect(...) is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block. bool IsMouseHoveringRect ( const ImVec2 & r_min , const ImVec2 & r_max , bool clip = true ) IsMousePosValid(...) by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available bool IsMousePosValid ( const ImVec2 * mouse_pos = NULL ) IsAnyMouseDown() is any mouse button held? bool IsAnyMouseDown () GetMousePos() shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls ImVec2 GetMousePos () GetMousePosOnOpeningCurrentPopup() retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves) ImVec2 GetMousePosOnOpeningCurrentPopup () IsMouseDragging(...) is mouse dragging? (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold) bool IsMouseDragging ( ImGuiMouseButton button , float lock_threshold = - 1.0f ) GetMouseDragDelta(...) return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (if lock_threshold < -1.0f, uses io.MouseDraggingThreshold) ImVec2 GetMouseDragDelta ( ImGuiMouseButton button = 0 , float lock_threshold = - 1.0f ) ResetMouseDragDelta(...) void ResetMouseDragDelta ( ImGuiMouseButton button = 0 ) GetMouseCursor() get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you ImGuiMouseCursor GetMouseCursor () SetMouseCursor(...) set desired cursor type void SetMouseCursor ( ImGuiMouseCursor cursor_type ) CaptureMouseFromApp(...) attention: misleading name! manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle). This is equivalent to setting \"io.WantCaptureMouse = want_capture_mouse_value;\" after the next NewFrame() call. void CaptureMouseFromApp ( bool want_capture_mouse_value = true )","title":"Inputs Utilities: Mouse"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#clipboard-utilities","text":"Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard. SetClipboardText(...) void SetClipboardText ( const char * text )","title":"Clipboard Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#settingsini-utilities","text":"The disk functions are automatically called if io.IniFilename != NULL (default is \"imgui.ini\"). Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually. LoadIniSettingsFromDisk(...) call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename). void LoadIniSettingsFromDisk ( const char * ini_filename ) LoadIniSettingsFromMemory(...) call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source. void LoadIniSettingsFromMemory ( const char * ini_data , size_t ini_size = 0 ) SaveIniSettingsToDisk(...) this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext). void SaveIniSettingsToDisk ( const char * ini_filename )","title":"Settings/.Ini Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#debug-utilities","text":"DebugCheckVersionAndDataLayout(...) This is called by IMGUI_CHECKVERSION() macro. bool DebugCheckVersionAndDataLayout ( const char * version_str , size_t sz_io , size_t sz_style , size_t sz_vec2 , size_t sz_vec4 , size_t sz_drawvert , size_t sz_drawidx )","title":"Debug Utilities"},{"location":"api-imgui/ImGui--Dear-ImGui-end-user/#memory-allocators","text":"All those functions are not reliant on the current context. If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again because we use global storage for those. SetAllocatorFunctions(...) void SetAllocatorFunctions ( void * ( * alloc_func )( size_t sz , void * user_data ), void ( * free_func )( void * ptr , void * user_data ), void * user_data = NULL ) MemAlloc(...) void * MemAlloc ( size_t size ) MemFree(...) void MemFree ( void * ptr )","title":"Memory Allocators"},{"location":"api-imgui/ImGuiIO/","text":"ImGuiIO \u00b6 // Communicate most settings and inputs/outputs to Dear ImGui using this structure. // Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.","title":"ImGuiIO"},{"location":"api-imgui/ImGuiIO/#imguiio","text":"// Communicate most settings and inputs/outputs to Dear ImGui using this structure. // Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.","title":"ImGuiIO"},{"location":"api-imgui/Initial/","text":"Initial \u00b6 (headers) \u00b6 (headers) Help: \u00b6 Read FAQ at http://dearimgui.org/faq Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase. Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that. Read imgui.cpp for details, links and comments. Help: - Read FAQ at http://dearimgui.org/faq - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase. - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that. Read imgui.cpp for details, links and comments. Resources: \u00b6 FAQ http://dearimgui.org/faq Homepage & latest https://github.com/ocornut/imgui Releases & changelog https://github.com/ocornut/imgui/releases Gallery https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!) Glossary https://github.com/ocornut/imgui/wiki/Glossary Wiki https://github.com/ocornut/imgui/wiki Issues & support https://github.com/ocornut/imgui/issues Resources: - FAQ http://dearimgui.org/faq - Homepage & latest https://github.com/ocornut/imgui - Releases & changelog https://github.com/ocornut/imgui/releases - Gallery https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!) - Glossary https://github.com/ocornut/imgui/wiki/Glossary - Wiki https://github.com/ocornut/imgui/wiki - Issues & support https://github.com/ocornut/imgui/issues Index of this file: \u00b6 Header mess Forward declarations and basic types ImGui API (Dear ImGui end-user API) Flags & Enumerations Memory allocations macros ImVector<> ImGuiStyle ImGuiIO Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload) Obsolete functions Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor) Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont) Index of this file: - Header mess - Forward declarations and basic types - ImGui API (Dear ImGui end-user API) - Flags & Enumerations - Memory allocations macros - ImVector<> - ImGuiStyle - ImGuiIO - Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload) - Obsolete functions - Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor) - Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) - Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont) Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename) \u00b6 Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename)","title":"Initial"},{"location":"api-imgui/Initial/#initial","text":"","title":"Initial"},{"location":"api-imgui/Initial/#headers","text":"(headers)","title":"(headers)"},{"location":"api-imgui/Initial/#help","text":"Read FAQ at http://dearimgui.org/faq Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase. Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that. Read imgui.cpp for details, links and comments. Help: - Read FAQ at http://dearimgui.org/faq - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase. - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that. Read imgui.cpp for details, links and comments.","title":"Help:"},{"location":"api-imgui/Initial/#resources","text":"FAQ http://dearimgui.org/faq Homepage & latest https://github.com/ocornut/imgui Releases & changelog https://github.com/ocornut/imgui/releases Gallery https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!) Glossary https://github.com/ocornut/imgui/wiki/Glossary Wiki https://github.com/ocornut/imgui/wiki Issues & support https://github.com/ocornut/imgui/issues Resources: - FAQ http://dearimgui.org/faq - Homepage & latest https://github.com/ocornut/imgui - Releases & changelog https://github.com/ocornut/imgui/releases - Gallery https://github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!) - Glossary https://github.com/ocornut/imgui/wiki/Glossary - Wiki https://github.com/ocornut/imgui/wiki - Issues & support https://github.com/ocornut/imgui/issues","title":"Resources:"},{"location":"api-imgui/Initial/#index-of-this-file","text":"Header mess Forward declarations and basic types ImGui API (Dear ImGui end-user API) Flags & Enumerations Memory allocations macros ImVector<> ImGuiStyle ImGuiIO Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload) Obsolete functions Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor) Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont) Index of this file: - Header mess - Forward declarations and basic types - ImGui API (Dear ImGui end-user API) - Flags & Enumerations - Memory allocations macros - ImVector<> - ImGuiStyle - ImGuiIO - Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload) - Obsolete functions - Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor) - Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) - Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)","title":"Index of this file:"},{"location":"api-imgui/Initial/#configuration-file-with-compile-time-options-edit-imconfigh-or-define-imgui_user_config-to-your-own-filename","text":"Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename)","title":"Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename)"},{"location":"api-imgui/Introduction/","text":"Introduction \u00b6 (headers) \u00b6 Help: \u00b6 Read FAQ at http:dearimgui.org/faq Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase. Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that. Read imgui.cpp for details, links and comments. Resources: \u00b6 FAQ http:dearimgui.org/faq Homepage & latest https:github.com/ocornut/imgui Releases & changelog https:github.com/ocornut/imgui/releases Gallery https:github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!) Glossary https:github.com/ocornut/imgui/wiki/Glossary Wiki https:github.com/ocornut/imgui/wiki Issues & support https:github.com/ocornut/imgui/issues Header mess \u00b6 Forward declarations and basic types ImGui API (Dear ImGui end-user API) Flags & Enumerations Memory allocations macros ImVector<> ImGuiStyle ImGuiIO Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload) Obsolete functions Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor) Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont) Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename) \u00b6","title":"API Introduction"},{"location":"api-imgui/Introduction/#introduction","text":"","title":"Introduction"},{"location":"api-imgui/Introduction/#headers","text":"","title":"(headers)"},{"location":"api-imgui/Introduction/#help","text":"Read FAQ at http:dearimgui.org/faq Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase. Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code. All applications in examples/ are doing that. Read imgui.cpp for details, links and comments.","title":"Help:"},{"location":"api-imgui/Introduction/#resources","text":"FAQ http:dearimgui.org/faq Homepage & latest https:github.com/ocornut/imgui Releases & changelog https:github.com/ocornut/imgui/releases Gallery https:github.com/ocornut/imgui/issues/3075 (please post your screenshots/video there!) Glossary https:github.com/ocornut/imgui/wiki/Glossary Wiki https:github.com/ocornut/imgui/wiki Issues & support https:github.com/ocornut/imgui/issues","title":"Resources:"},{"location":"api-imgui/Introduction/#header-mess","text":"Forward declarations and basic types ImGui API (Dear ImGui end-user API) Flags & Enumerations Memory allocations macros ImVector<> ImGuiStyle ImGuiIO Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload) Obsolete functions Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, ImColor) Draw List API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData) Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)","title":"Header mess"},{"location":"api-imgui/Introduction/#configuration-file-with-compile-time-options-edit-imconfigh-or-define-imgui_user_config-to-your-own-filename","text":"","title":"Configuration file with compile-time options (edit imconfig.h or #define IMGUI_USER_CONFIG to your own filename)"},{"location":"api-imgui/Obsolete-functions--Will-be/","text":"Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details) \u00b6 // Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead. OBSOLETED in 1.72 (from July 2019) \u00b6 OBSOLETED in 1.71 (from June 2019) \u00b6 OBSOLETED in 1.70 (from May 2019) \u00b6 OBSOLETED in 1.69 (from Mar 2019) \u00b6 OBSOLETED in 1.66 (from Sep 2018) \u00b6 OBSOLETED in 1.63 (between Aug 2018 and Sept 2018) \u00b6 OBSOLETED in 1.61 (between Apr 2018 and Aug 2018) \u00b6 InputFloat(...) Use the 'const char* format' version instead of 'decimal_precision'! bool InputFloat ( const char * label , float * v , float step , float step_fast , int decimal_precision , ImGuiInputTextFlags flags = 0 ) InputFloat2(...) bool InputFloat2 ( const char * label , float v [ 2 ], int decimal_precision , ImGuiInputTextFlags flags = 0 ) InputFloat3(...) bool InputFloat3 ( const char * label , float v [ 3 ], int decimal_precision , ImGuiInputTextFlags flags = 0 ) InputFloat4(...) bool InputFloat4 ( const char * label , float v [ 4 ], int decimal_precision , ImGuiInputTextFlags flags = 0 ) OBSOLETED in 1.60 (between Dec 2017 and Apr 2018) \u00b6","title":"Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsolete-functions-will-be-removed-read-api-breaking-changes-section-in-imguicpp-for-details","text":"// Please keep your copy of dear imgui up to date! Occasionally set '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in imconfig.h to stay ahead.","title":"Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-172-from-july-2019","text":"","title":"OBSOLETED in 1.72 (from July 2019)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-171-from-june-2019","text":"","title":"OBSOLETED in 1.71 (from June 2019)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-170-from-may-2019","text":"","title":"OBSOLETED in 1.70 (from May 2019)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-169-from-mar-2019","text":"","title":"OBSOLETED in 1.69 (from Mar 2019)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-166-from-sep-2018","text":"","title":"OBSOLETED in 1.66 (from Sep 2018)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-163-between-aug-2018-and-sept-2018","text":"","title":"OBSOLETED in 1.63 (between Aug 2018 and Sept 2018)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-161-between-apr-2018-and-aug-2018","text":"InputFloat(...) Use the 'const char* format' version instead of 'decimal_precision'! bool InputFloat ( const char * label , float * v , float step , float step_fast , int decimal_precision , ImGuiInputTextFlags flags = 0 ) InputFloat2(...) bool InputFloat2 ( const char * label , float v [ 2 ], int decimal_precision , ImGuiInputTextFlags flags = 0 ) InputFloat3(...) bool InputFloat3 ( const char * label , float v [ 3 ], int decimal_precision , ImGuiInputTextFlags flags = 0 ) InputFloat4(...) bool InputFloat4 ( const char * label , float v [ 4 ], int decimal_precision , ImGuiInputTextFlags flags = 0 )","title":"OBSOLETED in 1.61 (between Apr 2018 and Aug 2018)"},{"location":"api-imgui/Obsolete-functions--Will-be/#obsoleted-in-160-between-dec-2017-and-apr-2018","text":"","title":"OBSOLETED in 1.60 (between Dec 2017 and Apr 2018)"}]}